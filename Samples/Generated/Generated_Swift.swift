// Number of generated types: 1754
// Number of generated members: 5662

// MARK: - BEGIN Header
import Foundation

// MARK: - END Header

// MARK: - BEGIN Utils
public struct DNChar: Equatable {
    public let cValue: wchar_t

    public init(cValue: wchar_t) {
        self.cValue = cValue
    }

    public static func == (lhs: DNChar, rhs: DNChar) -> Bool {
        lhs.cValue == rhs.cValue
    }
}

public class DNObject {
    let __handle: UnsafeMutableRawPointer
    var __skipDestroy = false

    public class var typeName: String { "" }
    public class var fullTypeName: String { "" }

    required init(handle: UnsafeMutableRawPointer) {
		self.__handle = handle
	}

	convenience init?(handle: UnsafeMutableRawPointer?) {
		guard let handle else { return nil }

		self.init(handle: handle)
	}

    public class var typeOf: System_Type /* System.Type */ {
        fatalError("Override in subclass")
    }

    internal func destroy() {
        // Override in subclass
    }

    deinit {
        guard !__skipDestroy else { return }
        
        // Enable for debugging
        // print("[DEBUG] Will destroy \(Self.fullTypeName)")

		destroy()

        // Enable for debugging
        // print("[DEBUG] Did destroy \(Self.fullTypeName)")
	}
}

// MARK: - Type Conversion Extensions
public extension DNObject {
    func `is`(_ type: System_Type) -> Bool {
        return DNObjectIs(self.__handle, type.__handle)
    }

    func `is`<T>(_ type: T.Type? = nil) -> Bool where T: DNObject {
        let dnType: System_Type
        
        if let type {
            dnType = type.typeOf
        } else {
            dnType = T.typeOf
        }
        
        return DNObjectIs(self.__handle, dnType.__handle)
    }

    func castAs<T>(_ type: T.Type? = nil) -> T? where T: DNObject {
        let dnType: System_Type
        
        if let type {
            dnType = type.typeOf
        } else {
            dnType = T.typeOf
        }
        
        guard let castedObjectC = DNObjectCastAs(self.__handle, dnType.__handle) else {
            return nil
        }
        
        let castedObject = T(handle: castedObjectC)
        
        return castedObject
    }

    func castTo<T>(_ type: T.Type? = nil) throws -> T where T: DNObject {
        let dnType: System_Type
        
        if let type {
            dnType = type.typeOf
        } else {
            dnType = T.typeOf
        }
    
        var exceptionC: System_Exception_t?
        
        let castedObjectC = DNObjectCastTo(self.__handle, dnType.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
    
        guard let castedObjectC else {
            fatalError("DNObjectCastTo didn't throw an exception but returned nil") 
        }
        
        let castedObject = T(handle: castedObjectC)
        
        return castedObject
    }
}

// MARK: - Primitive Conversion Extensions
public extension DNObject {
    func castToBool() throws -> Bool {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToBool(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromBool(_ boolValue: Bool) -> System_Object {
        let castedObjectC = DNObjectFromBool(boolValue)
		let castedObject = System_Object(handle: castedObjectC)

        return castedObject
	}

    func castToFloat() throws -> Float {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToFloat(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromFloat(_ floatValue: Float) -> System_Object {
        let castedObjectC = DNObjectFromFloat(floatValue)
		let castedObject = System_Object(handle: castedObjectC)

        return castedObject
	}

    func castToDouble() throws -> Double {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToDouble(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromDouble(_ doubleValue: Double) -> System_Object {
        let castedObjectC = DNObjectFromDouble(doubleValue)
		let castedObject = System_Object(handle: castedObjectC)

        return castedObject
	}

    func castToInt8() throws -> Int8 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToInt8(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromInt8(_ int8Value: Int8) -> System_Object {
        let castedObjectC = DNObjectFromInt8(int8Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToUInt8() throws -> UInt8 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToUInt8(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromUInt8(_ uint8Value: UInt8) -> System_Object {
        let castedObjectC = DNObjectFromUInt8(uint8Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToInt16() throws -> Int16 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToInt16(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromInt16(_ int16Value: Int16) -> System_Object {
        let castedObjectC = DNObjectFromInt16(int16Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToUInt16() throws -> UInt16 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToUInt16(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromUInt16(_ uint16Value: UInt16) -> System_Object {
        let castedObjectC = DNObjectFromUInt16(uint16Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToInt32() throws -> Int32 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToInt32(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromInt32(_ int32Value: Int32) -> System_Object {
        let castedObjectC = DNObjectFromInt32(int32Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToUInt32() throws -> UInt32 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToUInt32(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromUInt32(_ uint32Value: UInt32) -> System_Object {
        let castedObjectC = DNObjectFromUInt32(uint32Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToInt64() throws -> Int64 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToInt64(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromInt64(_ int64Value: Int64) -> System_Object {
        let castedObjectC = DNObjectFromInt64(int64Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }

    func castToUInt64() throws -> UInt64 {
        var exceptionC: System_Exception_t?
        
        let castedValue = DNObjectCastToUInt64(self.__handle, &exceptionC)
        
        if let exceptionC {
            let exception = System_Exception(handle: exceptionC)
            let exceptionError = exception.error
            
            throw exceptionError
        }
        
        return castedValue 
    }

    static func fromUInt64(_ uint64Value: UInt64) -> System_Object {
        let castedObjectC = DNObjectFromUInt64(uint64Value)
        let castedObject = System_Object(handle: castedObjectC)

        return castedObject
    }
}

extension Bool {
    public func dotNETObject() -> System_Object {
        return System_Object.fromBool(self)
    }
}

extension Float {
    public func dotNETObject() -> System_Object {
        return System_Object.fromFloat(self)
    }
}

extension Double {
    public func dotNETObject() -> System_Object {
        return System_Object.fromDouble(self)
    }
}

extension Int8 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromInt8(self)
    }
}

extension UInt8 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromUInt8(self)
    }
}

extension Int16 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromInt16(self)
    }
}

extension UInt16 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromUInt16(self)
    }
}

extension Int32 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromInt32(self)
    }
}

extension UInt32 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromUInt32(self)
    }
}

extension Int64 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromInt64(self)
    }
}

extension UInt64 {
    public func dotNETObject() -> System_Object {
        return System_Object.fromUInt64(self)
    }
}

public class DNError: LocalizedError {
    public let exception: System_Exception
    
    public init(exception: System_Exception) {
        self.exception = exception
    }
    
    public func stackTrace() -> String? {
        do {
            return try String(dotNETString: exception.stackTrace)
        } catch {
            return nil
        }
    }
    
    public var errorDescription: String? {
        do {
            return try String(dotNETString: exception.message)
        } catch {
            return nil
        }
    }
}

public extension System_Exception {
    var error: DNError {
        return DNError(exception: self)
    }
}

public enum DNSystemError: LocalizedError {
    case unexpectedNull
    
    public var errorDescription: String? {
        switch self {
            case .unexpectedNull:
                return "Unexpectedly found null"
        }
    }
}

public extension String {
	func dotNETString() -> System_String {
		let dotNetStringHandle = DNStringFromC(self)
		
		return System_String(handle: dotNetStringHandle)
	}
	
	init?(dotNETString: System_String?) {
		guard let dotNETString else { return nil }
		
		self.init(dotNETString: dotNETString)
	}
	
	init(dotNETString: System_String) {
		let cString = DNStringToC(dotNETString.__handle)
		
		self.init(cString: cString)
		
		cString.deallocate()
	}
}

public extension System_String {
    func string() -> String {
        return String(dotNETString: self)
    }
}

public extension [String] {
    /// Converts a Swift String Array into a .NET System.String Array
    func dotNETStringArray() throws -> System_String_Array {
        let arr = try System_String_Array.createInstance(System_String.typeOf,
                                                         .init(count))
        
        for (idx, el) in self.enumerated() {
            let elDN = el.dotNETString()
            
            try arr.setValue(elDN, Int32(idx))
        }
        
        let strArr: System_String_Array = try arr.castTo()
        
        return strArr
    }
}

public extension System_String_Array {
    /// Converts a .NET System.String Array into a Swift String Array
    func array() throws -> [String] {
        let len = try self.length
        
        guard len > 0 else {
            return .init()
        }
        
        var arr = [String]()
        
        for idx in 0..<len {
            guard let el = try self.getValue(idx) else {
                throw DNSystemError.unexpectedNull
            }
            
            let elDNStr: System_String = try el.castTo()
            let elStr = elDNStr.string()
            
            arr.append(elStr)
        }
        
        return arr
    }
}

extension System_Object: Equatable {
    public static func == (lhs: System_Object,
                           rhs: System_Object) -> Bool {
        let result: Bool
        
        do {
            result = try System_Object.equals(lhs, rhs)
        } catch {
            result = false
        }
        
        return result
    }
}

public func == (lhs: System_Object?,
                rhs: System_Object?) -> Bool {
    let result: Bool
    
    do {
        result = try System_Object.equals(lhs, rhs)
    } catch {
        result = false
    }
    
    return result
}

public func != (lhs: System_Object?,
                rhs: System_Object?) -> Bool {
    let result: Bool
    
    do {
        result = try System_Object.equals(lhs, rhs)
    } catch {
        result = false
    }
    
    return !result
}

public func === (lhs: System_Object?,
                 rhs: System_Object?) -> Bool {
    let result: Bool
    
    do {
        result = try System_Object.referenceEquals(lhs, rhs)
    } catch {
        result = false
    }
    
    return result
}

public func !== (lhs: System_Object?,
                 rhs: System_Object?) -> Bool {
    let result: Bool
    
    do {
        result = try System_Object.referenceEquals(lhs, rhs)
    } catch {
        result = false
    }
    
    return !result
}

fileprivate struct DNDateTimeUtils {
    static var calendarForDateTimeToSwiftDateConversions: Calendar {
        var calendar = Calendar(identifier: .gregorian)
        calendar.timeZone = .gmt
        
        return calendar
    }
}

extension System_DateTime {
    public enum DNSystemDateTimeErrors: LocalizedError {
        case dateTimeKindIsUnspecified
        case dateFromCalendarReturnedNil
        
        public var errorDescription: String? {
            switch self {
                case .dateTimeKindIsUnspecified:
                    return "DateTimeKind.Unspecified cannot be safely converted"
                case .dateFromCalendarReturnedNil:
                    return "Failed to get date from calendar"
            }
        }
    }
    
    private func dateComponents(fromSystemDateTime dateTime: System_DateTime) throws -> DateComponents {
        let nanoSecsPerTicks: Int64 = 100
        
        let ticks = try dateTime.ticks
        let ticksPerSecond = System_TimeSpan.ticksPerSecond
        
        // Compute the sub-second fraction of nanoseconds.
        let subsecondTicks = ticks % ticksPerSecond
        let nanoseconds = subsecondTicks * nanoSecsPerTicks
        
        let day = try dateTime.day
        let month = try dateTime.month
        let year = try dateTime.year
        let hour = try dateTime.hour
        let minute = try dateTime.minute
        let second = try dateTime.second
        
        var dateComponents = DateComponents()
        dateComponents.day = Int(day)
        dateComponents.month = Int(month)
        dateComponents.year = Int(year)
        dateComponents.hour = Int(hour)
        dateComponents.minute = Int(minute)
        dateComponents.second = Int(second)
        dateComponents.nanosecond = Int(nanoseconds)
        
        return dateComponents
    }
    
    public func swiftDate() throws -> Date {
        let dateTimeKind = try self.kind
        
        guard dateTimeKind != .unspecified else {
            throw DNSystemDateTimeErrors.dateTimeKindIsUnspecified
        }
        
        let universalDateTime = try self.toUniversalTime()
        
        let dateComponents = try dateComponents(fromSystemDateTime: universalDateTime)
        let calendar = DNDateTimeUtils.calendarForDateTimeToSwiftDateConversions
        
        guard let retDate = calendar.date(from: dateComponents) else {
            throw DNSystemDateTimeErrors.dateFromCalendarReturnedNil
        }
        
        return retDate
    }
}

extension Date {
    public enum DNDateErrors: LocalizedError {
        case dateComponentReturnedNil(_ component: String)
        case dateOutsideOfSystemDateTimeRange(_ secondsSinceReferenceDate: TimeInterval? = nil)

        public var errorDescription: String? {
            switch self {
                case .dateComponentReturnedNil(let component):
                    return "Failed to get \(component) from calendar components"
                case .dateOutsideOfSystemDateTimeRange(let secondsSinceReferenceDate):
                    let baseDescription = "The date is outside the range of System.DateTime"

                    if let secondsSinceReferenceDate {
                        return "\(baseDescription): \(secondsSinceReferenceDate)"
                    } else {
                        return baseDescription
                    }
            }
        }
    }

    public func dotNETDateTime() throws -> System_DateTime {
        let nanoSecsPerTick = 100
        let nanoSecsPerMicrosec = 1000
        let nanoSecsPerMillisec = 1000000

        let referenceSwiftDate = Date(timeIntervalSince1970: 0)

        let components: Set<Calendar.Component> = [
            .era,
            .year,
            .month,
            .day,
            .hour,
            .minute,
            .second,
            .nanosecond,
            .calendar
        ]

        var calendar = Calendar(identifier: .gregorian)
        calendar.timeZone = .gmt

        let calComponents = calendar.dateComponents(components,
                                                    from: referenceSwiftDate)

        if let year = calComponents.year,
           year >= 10_000 {
            if self.timeIntervalSinceReferenceDate == 252423993600 {
                let dateTime = try System_DateTime.specifyKind(.maxValue,
                                                               .utc)

                return dateTime
            } else {
                throw DNDateErrors.dateOutsideOfSystemDateTimeRange(self.timeIntervalSinceReferenceDate)
            }
        }

        if let era = calComponents.era,
           era != 1 {
            throw DNDateErrors.dateOutsideOfSystemDateTimeRange()
        }

        guard var nanosecondsLeft = calComponents.nanosecond else {
            throw DNDateErrors.dateComponentReturnedNil("nanosencond")
        }

        let milliseconds = nanosecondsLeft / nanoSecsPerMillisec
        nanosecondsLeft -= milliseconds * nanoSecsPerMillisec
        let microseconds = nanosecondsLeft / nanoSecsPerMicrosec
        nanosecondsLeft -= microseconds * nanoSecsPerMicrosec
        let ticks = nanosecondsLeft / nanoSecsPerTick

        guard let year = calComponents.year else {
            throw DNDateErrors.dateComponentReturnedNil("year")
        }

        guard let month = calComponents.month else {
            throw DNDateErrors.dateComponentReturnedNil("month")
        }

        guard let day = calComponents.day else {
            throw DNDateErrors.dateComponentReturnedNil("day")
        }

        guard let hour = calComponents.hour else {
            throw DNDateErrors.dateComponentReturnedNil("hour")
        }

        guard let minute = calComponents.minute else {
            throw DNDateErrors.dateComponentReturnedNil("minute")
        }

        guard let second = calComponents.second else {
            throw DNDateErrors.dateComponentReturnedNil("second")
        }

        var retDate = try System_DateTime(Int32(year),
                                          Int32(month),
                                          Int32(day),
                                          Int32(hour),
                                          Int32(minute),
                                          Int32(second),
                                          Int32(milliseconds),
                                          Int32(microseconds),
                                          .utc)

        if ticks > 0 {
            let adjustedRetDate = try retDate.addTicks(.init(ticks))
            retDate = adjustedRetDate
        }

        return retDate
    }
}

public extension Data {
    /// Creates a .NET byte array by copying the data from the Swift Data object
    func dotNETByteArray() throws -> System_Byte_Array {
        let bytesCount = Int32(self.count)
        
        let systemArray = try System_Array.createInstance(System_Byte.typeOf, bytesCount)
        
        let systemByteArray: System_Byte_Array = try systemArray.castTo()
        
        guard bytesCount > 0 else {
            return systemByteArray
        }
        
        try self.withUnsafeBytes {
            guard let unsafeBytesPointer = $0.baseAddress else {
                throw DNSystemError.unexpectedNull
            }
            
            try System_Runtime_InteropServices_Marshal.copy(.init(mutating: unsafeBytesPointer),
                                                            systemByteArray,
                                                            0,
                                                            bytesCount)
        }
        
        return systemByteArray
    }
}

public extension System_Byte_Array {
    /// Creates a Swift Data object by either copying the data from the .NET byte array or getting a pinned pointer to the underlying data in .NET which is freed as soon as the Swift Data object is deallocated. 
    func data(noCopy: Bool = false) throws -> Data {
        let bytesCount = try self.length
        
        guard bytesCount > 0 else {
            return .init()
        }
        
        if noCopy {
            var __exceptionC: System_Exception_t?
            var __gcHandleC: System_Runtime_InteropServices_GCHandle_t?
            
            let ptr = DNGetPinnedPointerToByteArray(self.__handle,
                                                    &__gcHandleC,
                                                    &__exceptionC)
                                                    
            if let __exceptionC {
                let __exception = System_Exception(handle: __exceptionC)
                let __error = __exception.error
                
                throw __error
            }
            
            guard let ptr else {
                if let __gcHandleC {
                    System_Runtime_InteropServices_GCHandle_Destroy(__gcHandleC)
                }
                
                throw DNSystemError.unexpectedNull
            }
            
            guard let __gcHandleC else {
                  throw DNSystemError.unexpectedNull
            }
            
            let data = Data(bytesNoCopy: .init(mutating: ptr),
                count: .init(bytesCount),
                deallocator: .custom({ _ /* ptr */, _ /* count */ in
                defer {
                    System_Runtime_InteropServices_GCHandle_Destroy(__gcHandleC)
                }
                
                let isAllocated = System_Runtime_InteropServices_GCHandle_IsAllocated_Get(__gcHandleC,
                                                                                          nil)
                
                guard isAllocated else {
                    // If the GCHandle is not allocated, there's nothing to do here
                    return
                }
                
                var __freeExceptionC: System_Exception_t?
                
                System_Runtime_InteropServices_GCHandle_Free(__gcHandleC, 
                                                             &__freeExceptionC)
                
                if let __freeExceptionC {
                    let errorMessage: String
                    
                    if let exceptionMessage = System_String(handle: System_Exception_ToString(__freeExceptionC, nil))?.string() {
                        errorMessage = exceptionMessage
                    } else {
                        errorMessage = "N/A"
                    }
                    
                    fatalError("An error occurred while freeing a GCHandle of a pinned pointer to a .NET byte[]: \(errorMessage)")
                }
            }))
            
            return data
        } else {
            var data = Data(count: .init(bytesCount))
            
            try data.withUnsafeMutableBytes {
                guard let unsafeBytesPointer = $0.baseAddress else {
                    throw DNSystemError.unexpectedNull
                }
                
                try System_Runtime_InteropServices_Marshal.copy(self,
                                                                0,
                                                                unsafeBytesPointer,
                                                                bytesCount)
            }
            
            return data
        }
    }
}

fileprivate extension Data {
    init?(readOnlySpanOfByte: DNReadOnlySpanOfByte) {
        guard let dataPointer = readOnlySpanOfByte.dataPointer,
              readOnlySpanOfByte.dataLength > 0 else {
            return nil
        }

        let dataLength = Int(readOnlySpanOfByte.dataLength)
        
        self.init(bytesNoCopy: .init(mutating: dataPointer),
                  count: dataLength, 
                  deallocator: .free)
    }
}

extension DNReadOnlySpanOfByte {
    static let empty = DNReadOnlySpanOfByte(dataPointer: nil,
                                            dataLength: 0)
    
    func data() -> Data? {
        .init(readOnlySpanOfByte: self)
    }
}

extension Data {
    func readOnlySpanOfByte() -> DNReadOnlySpanOfByte {
        let length = self.count
        
        guard length > 0 else {
            return .empty
        }
        
        guard let lengthInt32 = Int32(exactly: length) else {
            fatalError("Data is larger than \(Int32.max) bytes which cannot be represented by .NET")
        }
        
        let bufferPointer = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: length)
        _ = bufferPointer.initialize(from: self)
        
        guard let dataPointer = bufferPointer.baseAddress else {
            fatalError("Failed to get the baseAddress of a buffer pointer")
        }
        
        let span = DNReadOnlySpanOfByte(dataPointer: dataPointer,
                                        dataLength: lengthInt32)
        
        return span
    }
}

extension Data? {
    func readOnlySpanOfByte() -> DNReadOnlySpanOfByte {
        guard let self else {
            return .empty
        }
        
        return self.readOnlySpanOfByte()
    }
}

public final class NativeBox<T> {
    public let value: T
    
    public init(value: T) {
        self.value = value
    }
    
    public convenience init(_ value: T) {
        self.init(value: value)
    }
    
//    deinit {
//        print("Deinitializing \(Self.self)")
//    }
}

// MARK: - To Pointer
public extension NativeBox {
    func unretainedPointer() -> UnsafeRawPointer {
        pointer(retained: false)
    }
    
    func retainedPointer() -> UnsafeRawPointer {
        pointer(retained: true)
    }
}

private extension NativeBox {
    func pointer(retained: Bool) -> UnsafeRawPointer {
        let unmanaged: Unmanaged<NativeBox<T>>
        
        if retained {
            unmanaged = Unmanaged.passRetained(self)
        } else {
            unmanaged = Unmanaged.passUnretained(self)
        }
        
        let opaque = unmanaged.toOpaque()
        
        let pointer = UnsafeRawPointer(opaque)
        
        return pointer
    }
}

// MARK: - From Pointer
public extension NativeBox {
    static func fromPointer(_ pointer: UnsafeRawPointer) -> Self {
        let unmanaged = Unmanaged<Self>.fromOpaque(pointer)
        
        let box = unmanaged.takeUnretainedValue()
        
        return box
    }
}

// MARK: - Release
public extension NativeBox {
    static func release(_ pointer: UnsafeRawPointer) {
        let unmanaged = Unmanaged<Self>.fromOpaque(pointer)
        
        unmanaged.release()
    }
    
    func release(_ pointer: UnsafeRawPointer) {
        Self.release(pointer)
    }
}

extension UUID {
    public func dotNETGuid() -> System_Guid? {
        let guidString = self.uuidString
        let guidStringDN = guidString.dotNETString()
        
        var guid = System_Guid.empty
        
        guard (try? System_Guid.tryParse(guidStringDN,
                                         &guid)) ?? false else {
            return nil
        }
        
        return guid
    }
    
    public init?(dotNETGuid: System_Guid) {
        guard let uuidStringDN = try? dotNETGuid.toString() else {
            return nil
        }
        
        let uuidString = uuidStringDN.string()
        
        self.init(uuidString: uuidString)
    }
}

extension System_Guid {
    public func uuid() -> UUID? {
        return UUID(dotNETGuid: self)
    }
}

extension System_Array: Collection {
	public typealias Index = Int32
	public typealias Element = System_Object?
	
	public struct Iterator: IteratorProtocol {
		private let array: System_Array
		private var index: Index = 0
		
		private var length: Int32 {
			let arrayLength = (try? self.array.length) ?? 0
			
			return arrayLength
		}
		
		init(_ array: System_Array) {
			self.array = array
		}
		
		public mutating func next() -> Element? {
			defer { index += 1 }
			guard index < length else { return nil }
			
			let element = try? self.array.getValue(index)
			
			return element
		}
	}
	
	public var startIndex: Index {
		return 0
	}
	
	public var endIndex: Index {
		let length = (try? self.length) ?? 0
		
		guard length > 0 else {
			return 0
		}
		
		let theEndIndex = length - 1
		
		return theEndIndex
	}
	
	public func index(after i: Index) -> Index {
		return i + 1
	}
	
	public subscript (position: Index) -> System_Object? {
		precondition(position >= startIndex && position <= endIndex, "Out of bounds")
		
		guard let element = try? self.getValue(position) else {
			return nil
		}
		
		return element
	}
	
	public func makeIterator() -> Iterator {
		return Iterator(self)
	}
}



// MARK: - END Utils

// MARK: - BEGIN Common Types


// MARK: - END Common Types

// MARK: - BEGIN Unsupported Types
// Unsupported Type "IEnumerator`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IBitwiseOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparisonOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IModulusOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Span`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IComparable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparisonOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IModulusOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Numerics.INumberBase`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Char&": Excluded
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.IUtfChar`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.SByte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.SByte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.SByte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.SByte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.Span`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1": Excluded
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtfChar`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.ArraySegment`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1+Enumerator[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Void*": Is Managed Pointer Type
// Unsupported Type "System.ValueTuple`2[[System.SByte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.SByte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IBinaryNumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IBitwiseOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparisonOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IModulusOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IFloatingPointIeee754`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IExponentialFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IFloatingPoint`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISignedNumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IHyperbolicFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ILogarithmicFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IPowerFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IRootFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ITrigonometricFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Numerics.INumberBase`1[[System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IExponentialFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IFloatingPoint`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparisonOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IModulusOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISignedNumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IHyperbolicFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ILogarithmicFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IPowerFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IRootFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ITrigonometricFunctions`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparisonOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IModulusOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISignedNumber`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "IFloatingPointConstants`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "ValueTuple`2": Is unsupported Type
// Unsupported Type "System.ValueTuple`2[[System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryFloatParseAndFormatInfo`1[[System.Single, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Double, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Double, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ValueTuple`2[[System.Double, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Double, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryFloatParseAndFormatInfo`1[[System.Double, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Decimal, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Decimal, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Runtime.Serialization.DeserializationToken": Excluded
// Unsupported Type "ValueTask`1": Is unsupported Type
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ValueTuple`2[[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.Action`1[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`2[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.CancellationToken, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "ValueTask`1": Is unsupported Type
// Unsupported Type "System.TypedReference": Excluded
// Unsupported Type "ValueTask`1": Is unsupported Type
// Unsupported Type "System.EventHandler`1[[System.Threading.Tasks.UnobservedTaskExceptionEventArgs, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Nullable Value Type, but not a struct (System.Int32?)
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerator`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Func`2[[System.Exception, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Action`1[[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`3[[System.AsyncCallback, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`4": Is Generic Delegate Type
// Unsupported Type "Func`4": Is Generic Delegate Type
// Unsupported Type "Func`5": Is Generic Delegate Type
// Unsupported Type "Func`5": Is Generic Delegate Type
// Unsupported Type "Func`6": Is Generic Delegate Type
// Unsupported Type "Func`6": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`4": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`4": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`5": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`5": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`6": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`6": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.ITaskAwaiter": Is Not Visible (public)
// Unsupported Type "System.Runtime.CompilerServices.IConfiguredTaskAwaiter": Is Not Visible (public)
// Unsupported Type "System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter": Is Not Visible (public)
// Unsupported Type "System.Action`2[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "System.Func`1[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "TaskFactory`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "TaskAwaiter`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ConfiguredTaskAwaitable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Action`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`4": Is Generic Delegate Type
// Unsupported Type "Func`4": Is Generic Delegate Type
// Unsupported Type "Func`5": Is Generic Delegate Type
// Unsupported Type "Func`5": Is Generic Delegate Type
// Unsupported Type "Func`6": Is Generic Delegate Type
// Unsupported Type "Func`6": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "ConfiguredTaskAwaiter": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ConfiguredTaskAwaiter": Is nested type inside generic type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Action`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Func`1": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "ConfiguredTaskAwaiter": Is nested type inside generic type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Action`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "System.Func`2[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task`1[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`2[[System.Threading.Tasks.Task`1[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1[]": Is Array of Generic Type
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Task`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Func`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`2[[System.Threading.Tasks.Task`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "System.Threading.Tasks.ValueTask`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Memory`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlyMemory`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Nullable`1[[System.IO.UnixFileMode, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Nullable Value Type, but not a struct (System.IO.UnixFileMode?)
// Unsupported Type "SpanAction`2": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.DefaultInterpolatedStringHandler&": Is unsupported Type
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.ReadOnlySpan`1[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Char*": Is Managed Pointer Type
// Unsupported Type "System.SByte*": Is Managed Pointer Type
// Unsupported Type "System.Byte*": Is Managed Pointer Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "ReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Converter`2": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Comparison`1": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Reflection.AssemblyName, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.Assembly, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`4[[System.Reflection.Assembly, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Type, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Runtime.InteropServices.ComTypes.ITypeInfo": Excluded
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ValueTuple`2[[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.TimeSpan, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.GCGenerationInfo, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.EventHandler`1[[System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Nullable`1[[System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Nullable Value Type, but not a struct (System.Boolean?)
// Unsupported Type "ReadOnlySpan`1": Is unsupported Type
// Unsupported Type "Span`1": Is unsupported Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ReadOnlySpan`1": Is unsupported Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Span`1": Is unsupported Type
// Unsupported Type "System.ReadOnlyMemory`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Func`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`2[[System.Threading.Tasks.Task`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "System.Threading.Tasks.ValueTask`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Memory`1[[System.Char, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IAsyncEnumerator`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Threading.Tasks.ValueTask`1[[System.Boolean, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Func`1[[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter[[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task`1[[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`2[[System.Threading.Tasks.Task`1[[System.Byte[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "System.Func`1[[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.IAsyncResult, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Func`2[[System.Threading.Tasks.Task, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter[[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Action`1[[System.Threading.Tasks.Task`1[[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`2[[System.Threading.Tasks.Task`1[[System.String[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`2": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "Func`3": Is Generic Delegate Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Half, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Half, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ValueTuple`2[[System.Half, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Half, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryFloatParseAndFormatInfo`1[[System.Half, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.Numerics.IBinaryInteger`1[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Numerics.INumberBase`1[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IUtf8SpanParsable`1[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.IBinaryIntegerParseAndFormatInfo`1[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Not Visible (public)
// Unsupported Type "System.ValueTuple`2[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.ValueTuple`2[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "INumberBase`1": Is unsupported Type
// Unsupported Type "IAdditionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IAdditiveIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDecrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IDivisionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEquatable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IIncrementOperators`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplicativeIdentity`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IMultiplyOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISpanParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IParsable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ISubtractionOperators`3": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryPlusOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUnaryNegationOperators`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IUtf8SpanParsable`1": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.UInt16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.Int16, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.UInt32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.UInt64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.Int64, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.UIntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.IntPtr, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.UInt128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.ReadOnlySpan`1[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "System.Span`1[[System.Int128, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is unsupported Type
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "CreateValueCallback": Is Generic Delegate Type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "List`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Converter`2": Is Generic Delegate Type
// Unsupported Type "Predicate`1": Is Generic Delegate Type
// Unsupported Type "Action`1": Is Generic Delegate Type
// Unsupported Type "Enumerator": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Comparison`1": Is Generic Delegate Type
// Unsupported Type "IDictionary`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyDictionary`2": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEqualityComparer`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "KeyCollection": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ValueCollection": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "Enumerator": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.ITupleInternal": Is Not Visible (public)
// Unsupported Type "Converter`2": Is Generic Delegate Type
// Unsupported Type "System.Predicate`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Action`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Collections.Generic.List`1+Enumerator[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Comparison`1[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is Generic Delegate Type
// Unsupported Type "System.Collections.Generic.KeyValuePair`2[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Exception, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]][]": Is Array of Generic Type
// Unsupported Type "System.Collections.Generic.Dictionary`2+KeyCollection[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Exception, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Collections.Generic.Dictionary`2+ValueCollection[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Exception, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "System.Collections.Generic.Dictionary`2+Enumerator[[System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Exception, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]": Is nested type inside generic type
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "ICollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IEnumerable`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyList`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "IReadOnlyCollection`1": Is Constructed Generic Type with non-constructed generic types
// Unsupported Type "System.Span`1[[System.Byte, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]&": Is unsupported Type
// Unsupported Type "System.Nullable`1": Excluded

// MARK: - END Unsupported Types

// MARK: - BEGIN APIs
public enum System_TypeCode: Int32 {
	init(cValue: System_TypeCode_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_TypeCode_t { get {
		System_TypeCode_t(rawValue: rawValue)!
	}}

	case empty = 0
	case object = 1
	case dBNull = 2
	case boolean = 3
	case char = 4
	case sByte = 5
	case byte = 6
	case int16 = 7
	case uInt16 = 8
	case int32 = 9
	case uInt32 = 10
	case int64 = 11
	case uInt64 = 12
	case single = 13
	case double = 14
	case decimal = 15
	case dateTime = 16
	case string = 18
}

extension System_TypeCode {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TypeCode_TypeOf())
		
	}}
	
	
	
}

public struct System_Globalization_CultureTypes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Globalization_CultureTypes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Globalization_CultureTypes_t { get {
		System_Globalization_CultureTypes_t(rawValue: rawValue)
	}}

	public static let neutralCultures = System_Globalization_CultureTypes(rawValue: 1)
	public static let specificCultures = System_Globalization_CultureTypes(rawValue: 2)
	public static let installedWin32Cultures = System_Globalization_CultureTypes(rawValue: 4)
	public static let allCultures = System_Globalization_CultureTypes(rawValue: 7)
	public static let userCustomCulture = System_Globalization_CultureTypes(rawValue: 8)
	public static let replacementCultures = System_Globalization_CultureTypes(rawValue: 16)
	public static let windowsOnlyCultures = System_Globalization_CultureTypes(rawValue: 32)
	public static let frameworkCultures = System_Globalization_CultureTypes(rawValue: 64)
}

extension System_Globalization_CultureTypes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_CultureTypes_TypeOf())
		
	}}
	
	
	
}

public struct System_Globalization_NumberStyles: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Globalization_NumberStyles_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Globalization_NumberStyles_t { get {
		System_Globalization_NumberStyles_t(rawValue: rawValue)
	}}

	public static let none = System_Globalization_NumberStyles([])
	public static let allowLeadingWhite = System_Globalization_NumberStyles(rawValue: 1)
	public static let allowTrailingWhite = System_Globalization_NumberStyles(rawValue: 2)
	public static let allowLeadingSign = System_Globalization_NumberStyles(rawValue: 4)
	public static let integer = System_Globalization_NumberStyles(rawValue: 7)
	public static let allowTrailingSign = System_Globalization_NumberStyles(rawValue: 8)
	public static let allowParentheses = System_Globalization_NumberStyles(rawValue: 16)
	public static let allowDecimalPoint = System_Globalization_NumberStyles(rawValue: 32)
	public static let allowThousands = System_Globalization_NumberStyles(rawValue: 64)
	public static let number = System_Globalization_NumberStyles(rawValue: 111)
	public static let allowExponent = System_Globalization_NumberStyles(rawValue: 128)
	public static let float = System_Globalization_NumberStyles(rawValue: 167)
	public static let allowCurrencySymbol = System_Globalization_NumberStyles(rawValue: 256)
	public static let currency = System_Globalization_NumberStyles(rawValue: 383)
	public static let any = System_Globalization_NumberStyles(rawValue: 511)
	public static let allowHexSpecifier = System_Globalization_NumberStyles(rawValue: 512)
	public static let hexNumber = System_Globalization_NumberStyles(rawValue: 515)
	public static let allowBinarySpecifier = System_Globalization_NumberStyles(rawValue: 1024)
	public static let binaryNumber = System_Globalization_NumberStyles(rawValue: 1027)
}

extension System_Globalization_NumberStyles {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_NumberStyles_TypeOf())
		
	}}
	
	
	
}

public enum System_MidpointRounding: Int32 {
	init(cValue: System_MidpointRounding_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_MidpointRounding_t { get {
		System_MidpointRounding_t(rawValue: rawValue)!
	}}

	case toEven = 0
	case awayFromZero = 1
	case toZero = 2
	case toNegativeInfinity = 3
	case toPositiveInfinity = 4
}

extension System_MidpointRounding {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_MidpointRounding_TypeOf())
		
	}}
	
	
	
}

public struct System_Globalization_TimeSpanStyles: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Globalization_TimeSpanStyles_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Globalization_TimeSpanStyles_t { get {
		System_Globalization_TimeSpanStyles_t(rawValue: rawValue)
	}}

	public static let none = System_Globalization_TimeSpanStyles([])
	public static let assumeNegative = System_Globalization_TimeSpanStyles(rawValue: 1)
}

extension System_Globalization_TimeSpanStyles {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_TimeSpanStyles_TypeOf())
		
	}}
	
	
	
}

public enum System_DateTimeKind: Int32 {
	init(cValue: System_DateTimeKind_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_DateTimeKind_t { get {
		System_DateTimeKind_t(rawValue: rawValue)!
	}}

	case unspecified = 0
	case utc = 1
	case local = 2
}

extension System_DateTimeKind {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_DateTimeKind_TypeOf())
		
	}}
	
	
	
}

public enum System_DayOfWeek: Int32 {
	init(cValue: System_DayOfWeek_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_DayOfWeek_t { get {
		System_DayOfWeek_t(rawValue: rawValue)!
	}}

	case sunday = 0
	case monday = 1
	case tuesday = 2
	case wednesday = 3
	case thursday = 4
	case friday = 5
	case saturday = 6
}

extension System_DayOfWeek {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_DayOfWeek_TypeOf())
		
	}}
	
	
	
}

public struct System_Globalization_DateTimeStyles: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Globalization_DateTimeStyles_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Globalization_DateTimeStyles_t { get {
		System_Globalization_DateTimeStyles_t(rawValue: rawValue)
	}}

	public static let none = System_Globalization_DateTimeStyles([])
	public static let allowLeadingWhite = System_Globalization_DateTimeStyles(rawValue: 1)
	public static let allowTrailingWhite = System_Globalization_DateTimeStyles(rawValue: 2)
	public static let allowInnerWhite = System_Globalization_DateTimeStyles(rawValue: 4)
	public static let allowWhiteSpaces = System_Globalization_DateTimeStyles(rawValue: 7)
	public static let noCurrentDateDefault = System_Globalization_DateTimeStyles(rawValue: 8)
	public static let adjustToUniversal = System_Globalization_DateTimeStyles(rawValue: 16)
	public static let assumeLocal = System_Globalization_DateTimeStyles(rawValue: 32)
	public static let assumeUniversal = System_Globalization_DateTimeStyles(rawValue: 64)
	public static let roundtripKind = System_Globalization_DateTimeStyles(rawValue: 128)
}

extension System_Globalization_DateTimeStyles {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_DateTimeStyles_TypeOf())
		
	}}
	
	
	
}

public enum System_Globalization_CalendarAlgorithmType: Int32 {
	init(cValue: System_Globalization_CalendarAlgorithmType_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Globalization_CalendarAlgorithmType_t { get {
		System_Globalization_CalendarAlgorithmType_t(rawValue: rawValue)!
	}}

	case unknown = 0
	case solarCalendar = 1
	case lunarCalendar = 2
	case lunisolarCalendar = 3
}

extension System_Globalization_CalendarAlgorithmType {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_CalendarAlgorithmType_TypeOf())
		
	}}
	
	
	
}

public enum System_Globalization_CalendarWeekRule: Int32 {
	init(cValue: System_Globalization_CalendarWeekRule_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Globalization_CalendarWeekRule_t { get {
		System_Globalization_CalendarWeekRule_t(rawValue: rawValue)!
	}}

	case firstDay = 0
	case firstFullWeek = 1
	case firstFourDayWeek = 2
}

extension System_Globalization_CalendarWeekRule {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_CalendarWeekRule_TypeOf())
		
	}}
	
	
	
}

public struct System_Runtime_Serialization_StreamingContextStates: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Runtime_Serialization_StreamingContextStates_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Runtime_Serialization_StreamingContextStates_t { get {
		System_Runtime_Serialization_StreamingContextStates_t(rawValue: rawValue)
	}}

	public static let crossProcess = System_Runtime_Serialization_StreamingContextStates(rawValue: 1)
	public static let crossMachine = System_Runtime_Serialization_StreamingContextStates(rawValue: 2)
	public static let file = System_Runtime_Serialization_StreamingContextStates(rawValue: 4)
	public static let persistence = System_Runtime_Serialization_StreamingContextStates(rawValue: 8)
	public static let remoting = System_Runtime_Serialization_StreamingContextStates(rawValue: 16)
	public static let other = System_Runtime_Serialization_StreamingContextStates(rawValue: 32)
	public static let clone = System_Runtime_Serialization_StreamingContextStates(rawValue: 64)
	public static let crossAppDomain = System_Runtime_Serialization_StreamingContextStates(rawValue: 128)
	public static let all = System_Runtime_Serialization_StreamingContextStates(rawValue: 255)
}

extension System_Runtime_Serialization_StreamingContextStates {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_StreamingContextStates_TypeOf())
		
	}}
	
	
	
}

public enum System_Reflection_ProcessorArchitecture: Int32 {
	init(cValue: System_Reflection_ProcessorArchitecture_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Reflection_ProcessorArchitecture_t { get {
		System_Reflection_ProcessorArchitecture_t(rawValue: rawValue)!
	}}

	case none = 0
	case mSIL = 1
	case x86 = 2
	case iA64 = 3
	case amd64 = 4
	case arm = 5
}

extension System_Reflection_ProcessorArchitecture {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ProcessorArchitecture_TypeOf())
		
	}}
	
	
	
}

public enum System_Reflection_AssemblyContentType: Int32 {
	init(cValue: System_Reflection_AssemblyContentType_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Reflection_AssemblyContentType_t { get {
		System_Reflection_AssemblyContentType_t(rawValue: rawValue)!
	}}

	case `default` = 0
	case windowsRuntime = 1
}

extension System_Reflection_AssemblyContentType {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_AssemblyContentType_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_AssemblyNameFlags: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_AssemblyNameFlags_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_AssemblyNameFlags_t { get {
		System_Reflection_AssemblyNameFlags_t(rawValue: rawValue)
	}}

	public static let none = System_Reflection_AssemblyNameFlags([])
	public static let publicKey = System_Reflection_AssemblyNameFlags(rawValue: 1)
	public static let retargetable = System_Reflection_AssemblyNameFlags(rawValue: 256)
	public static let enableJITcompileOptimizer = System_Reflection_AssemblyNameFlags(rawValue: 16384)
	public static let enableJITcompileTracking = System_Reflection_AssemblyNameFlags(rawValue: 32768)
}

extension System_Reflection_AssemblyNameFlags {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_AssemblyNameFlags_TypeOf())
		
	}}
	
	
	
}

public enum System_Configuration_Assemblies_AssemblyHashAlgorithm: Int32 {
	init(cValue: System_Configuration_Assemblies_AssemblyHashAlgorithm_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Configuration_Assemblies_AssemblyHashAlgorithm_t { get {
		System_Configuration_Assemblies_AssemblyHashAlgorithm_t(rawValue: rawValue)!
	}}

	case none = 0
	case mD5 = 32771
	case sHA1 = 32772
	case sHA256 = 32780
	case sHA384 = 32781
	case sHA512 = 32782
}

extension System_Configuration_Assemblies_AssemblyHashAlgorithm {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Configuration_Assemblies_AssemblyHashAlgorithm_TypeOf())
		
	}}
	
	
	
}

public enum System_Configuration_Assemblies_AssemblyVersionCompatibility: Int32 {
	init(cValue: System_Configuration_Assemblies_AssemblyVersionCompatibility_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Configuration_Assemblies_AssemblyVersionCompatibility_t { get {
		System_Configuration_Assemblies_AssemblyVersionCompatibility_t(rawValue: rawValue)!
	}}

	case sameMachine = 1
	case sameProcess = 2
	case sameDomain = 3
}

extension System_Configuration_Assemblies_AssemblyVersionCompatibility {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Configuration_Assemblies_AssemblyVersionCompatibility_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_ParameterAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_ParameterAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_ParameterAttributes_t { get {
		System_Reflection_ParameterAttributes_t(rawValue: rawValue)
	}}

	public static let none = System_Reflection_ParameterAttributes([])
	public static let `in` = System_Reflection_ParameterAttributes(rawValue: 1)
	public static let out = System_Reflection_ParameterAttributes(rawValue: 2)
	public static let lcid = System_Reflection_ParameterAttributes(rawValue: 4)
	public static let retval = System_Reflection_ParameterAttributes(rawValue: 8)
	public static let optional = System_Reflection_ParameterAttributes(rawValue: 16)
	public static let hasDefault = System_Reflection_ParameterAttributes(rawValue: 4096)
	public static let hasFieldMarshal = System_Reflection_ParameterAttributes(rawValue: 8192)
	public static let reserved3 = System_Reflection_ParameterAttributes(rawValue: 16384)
	public static let reserved4 = System_Reflection_ParameterAttributes(rawValue: 32768)
	public static let reservedMask = System_Reflection_ParameterAttributes(rawValue: 61440)
}

extension System_Reflection_ParameterAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ParameterAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_PortableExecutableKinds: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_PortableExecutableKinds_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_PortableExecutableKinds_t { get {
		System_Reflection_PortableExecutableKinds_t(rawValue: rawValue)
	}}

	public static let notAPortableExecutableImage = System_Reflection_PortableExecutableKinds([])
	public static let iLOnly = System_Reflection_PortableExecutableKinds(rawValue: 1)
	public static let required32Bit = System_Reflection_PortableExecutableKinds(rawValue: 2)
	public static let pE32Plus = System_Reflection_PortableExecutableKinds(rawValue: 4)
	public static let unmanaged32Bit = System_Reflection_PortableExecutableKinds(rawValue: 8)
	public static let preferred32Bit = System_Reflection_PortableExecutableKinds(rawValue: 16)
}

extension System_Reflection_PortableExecutableKinds {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_PortableExecutableKinds_TypeOf())
		
	}}
	
	
	
}

public enum System_Reflection_ImageFileMachine: Int32 {
	init(cValue: System_Reflection_ImageFileMachine_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Reflection_ImageFileMachine_t { get {
		System_Reflection_ImageFileMachine_t(rawValue: rawValue)!
	}}

	case i386 = 332
	case aRM = 452
	case iA64 = 512
	case aMD64 = 34404
}

extension System_Reflection_ImageFileMachine {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ImageFileMachine_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_MemberTypes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_MemberTypes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_MemberTypes_t { get {
		System_Reflection_MemberTypes_t(rawValue: rawValue)
	}}

	public static let constructor = System_Reflection_MemberTypes(rawValue: 1)
	public static let event = System_Reflection_MemberTypes(rawValue: 2)
	public static let field = System_Reflection_MemberTypes(rawValue: 4)
	public static let method = System_Reflection_MemberTypes(rawValue: 8)
	public static let property = System_Reflection_MemberTypes(rawValue: 16)
	public static let typeInfo = System_Reflection_MemberTypes(rawValue: 32)
	public static let custom = System_Reflection_MemberTypes(rawValue: 64)
	public static let nestedType = System_Reflection_MemberTypes(rawValue: 128)
	public static let all = System_Reflection_MemberTypes(rawValue: 191)
}

extension System_Reflection_MemberTypes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MemberTypes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_BindingFlags: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_BindingFlags_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_BindingFlags_t { get {
		System_Reflection_BindingFlags_t(rawValue: rawValue)
	}}

	public static let `default` = System_Reflection_BindingFlags([])
	public static let ignoreCase = System_Reflection_BindingFlags(rawValue: 1)
	public static let declaredOnly = System_Reflection_BindingFlags(rawValue: 2)
	public static let instance = System_Reflection_BindingFlags(rawValue: 4)
	public static let `static` = System_Reflection_BindingFlags(rawValue: 8)
	public static let `public` = System_Reflection_BindingFlags(rawValue: 16)
	public static let nonPublic = System_Reflection_BindingFlags(rawValue: 32)
	public static let flattenHierarchy = System_Reflection_BindingFlags(rawValue: 64)
	public static let invokeMethod = System_Reflection_BindingFlags(rawValue: 256)
	public static let createInstance = System_Reflection_BindingFlags(rawValue: 512)
	public static let getField = System_Reflection_BindingFlags(rawValue: 1024)
	public static let setField = System_Reflection_BindingFlags(rawValue: 2048)
	public static let getProperty = System_Reflection_BindingFlags(rawValue: 4096)
	public static let setProperty = System_Reflection_BindingFlags(rawValue: 8192)
	public static let putDispProperty = System_Reflection_BindingFlags(rawValue: 16384)
	public static let putRefDispProperty = System_Reflection_BindingFlags(rawValue: 32768)
	public static let exactBinding = System_Reflection_BindingFlags(rawValue: 65536)
	public static let suppressChangeType = System_Reflection_BindingFlags(rawValue: 131072)
	public static let optionalParamBinding = System_Reflection_BindingFlags(rawValue: 262144)
	public static let ignoreReturn = System_Reflection_BindingFlags(rawValue: 16777216)
	public static let doNotWrapExceptions = System_Reflection_BindingFlags(rawValue: 33554432)
}

extension System_Reflection_BindingFlags {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_BindingFlags_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_FieldAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_FieldAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_FieldAttributes_t { get {
		System_Reflection_FieldAttributes_t(rawValue: rawValue)
	}}

	public static let privateScope = System_Reflection_FieldAttributes([])
	public static let `private` = System_Reflection_FieldAttributes(rawValue: 1)
	public static let famANDAssem = System_Reflection_FieldAttributes(rawValue: 2)
	public static let assembly = System_Reflection_FieldAttributes(rawValue: 3)
	public static let family = System_Reflection_FieldAttributes(rawValue: 4)
	public static let famORAssem = System_Reflection_FieldAttributes(rawValue: 5)
	public static let `public` = System_Reflection_FieldAttributes(rawValue: 6)
	public static let fieldAccessMask = System_Reflection_FieldAttributes(rawValue: 7)
	public static let `static` = System_Reflection_FieldAttributes(rawValue: 16)
	public static let initOnly = System_Reflection_FieldAttributes(rawValue: 32)
	public static let literal = System_Reflection_FieldAttributes(rawValue: 64)
	public static let notSerialized = System_Reflection_FieldAttributes(rawValue: 128)
	public static let hasFieldRVA = System_Reflection_FieldAttributes(rawValue: 256)
	public static let specialName = System_Reflection_FieldAttributes(rawValue: 512)
	public static let rTSpecialName = System_Reflection_FieldAttributes(rawValue: 1024)
	public static let hasFieldMarshal = System_Reflection_FieldAttributes(rawValue: 4096)
	public static let pinvokeImpl = System_Reflection_FieldAttributes(rawValue: 8192)
	public static let hasDefault = System_Reflection_FieldAttributes(rawValue: 32768)
	public static let reservedMask = System_Reflection_FieldAttributes(rawValue: 38144)
}

extension System_Reflection_FieldAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_FieldAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_PropertyAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_PropertyAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_PropertyAttributes_t { get {
		System_Reflection_PropertyAttributes_t(rawValue: rawValue)
	}}

	public static let none = System_Reflection_PropertyAttributes([])
	public static let specialName = System_Reflection_PropertyAttributes(rawValue: 512)
	public static let rTSpecialName = System_Reflection_PropertyAttributes(rawValue: 1024)
	public static let hasDefault = System_Reflection_PropertyAttributes(rawValue: 4096)
	public static let reserved2 = System_Reflection_PropertyAttributes(rawValue: 8192)
	public static let reserved3 = System_Reflection_PropertyAttributes(rawValue: 16384)
	public static let reserved4 = System_Reflection_PropertyAttributes(rawValue: 32768)
	public static let reservedMask = System_Reflection_PropertyAttributes(rawValue: 62464)
}

extension System_Reflection_PropertyAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_PropertyAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_CallingConventions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_CallingConventions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_CallingConventions_t { get {
		System_Reflection_CallingConventions_t(rawValue: rawValue)
	}}

	public static let standard = System_Reflection_CallingConventions(rawValue: 1)
	public static let varArgs = System_Reflection_CallingConventions(rawValue: 2)
	public static let any = System_Reflection_CallingConventions(rawValue: 3)
	public static let hasThis = System_Reflection_CallingConventions(rawValue: 32)
	public static let explicitThis = System_Reflection_CallingConventions(rawValue: 64)
}

extension System_Reflection_CallingConventions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_CallingConventions_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_MethodAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_MethodAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_MethodAttributes_t { get {
		System_Reflection_MethodAttributes_t(rawValue: rawValue)
	}}

	public static let privateScope = System_Reflection_MethodAttributes([])
	public static let reuseSlot = System_Reflection_MethodAttributes([])
	public static let `private` = System_Reflection_MethodAttributes(rawValue: 1)
	public static let famANDAssem = System_Reflection_MethodAttributes(rawValue: 2)
	public static let assembly = System_Reflection_MethodAttributes(rawValue: 3)
	public static let family = System_Reflection_MethodAttributes(rawValue: 4)
	public static let famORAssem = System_Reflection_MethodAttributes(rawValue: 5)
	public static let `public` = System_Reflection_MethodAttributes(rawValue: 6)
	public static let memberAccessMask = System_Reflection_MethodAttributes(rawValue: 7)
	public static let unmanagedExport = System_Reflection_MethodAttributes(rawValue: 8)
	public static let `static` = System_Reflection_MethodAttributes(rawValue: 16)
	public static let `final` = System_Reflection_MethodAttributes(rawValue: 32)
	public static let virtual = System_Reflection_MethodAttributes(rawValue: 64)
	public static let hideBySig = System_Reflection_MethodAttributes(rawValue: 128)
	public static let newSlot = System_Reflection_MethodAttributes(rawValue: 256)
	public static let vtableLayoutMask = System_Reflection_MethodAttributes(rawValue: 256)
	public static let checkAccessOnOverride = System_Reflection_MethodAttributes(rawValue: 512)
	public static let abstract = System_Reflection_MethodAttributes(rawValue: 1024)
	public static let specialName = System_Reflection_MethodAttributes(rawValue: 2048)
	public static let rTSpecialName = System_Reflection_MethodAttributes(rawValue: 4096)
	public static let pinvokeImpl = System_Reflection_MethodAttributes(rawValue: 8192)
	public static let hasSecurity = System_Reflection_MethodAttributes(rawValue: 16384)
	public static let requireSecObject = System_Reflection_MethodAttributes(rawValue: 32768)
	public static let reservedMask = System_Reflection_MethodAttributes(rawValue: 53248)
}

extension System_Reflection_MethodAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MethodAttributes_TypeOf())
		
	}}
	
	
	
}

public enum System_Reflection_MethodImplAttributes: Int32 {
	init(cValue: System_Reflection_MethodImplAttributes_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Reflection_MethodImplAttributes_t { get {
		System_Reflection_MethodImplAttributes_t(rawValue: rawValue)!
	}}

	case iL = 0
	public static let managed = System_Reflection_MethodImplAttributes.iL
	case native = 1
	case oPTIL = 2
	case codeTypeMask = 3
	public static let runtime = System_Reflection_MethodImplAttributes.codeTypeMask
	case managedMask = 4
	public static let unmanaged = System_Reflection_MethodImplAttributes.managedMask
	case noInlining = 8
	case forwardRef = 16
	case synchronized = 32
	case noOptimization = 64
	case preserveSig = 128
	case aggressiveInlining = 256
	case aggressiveOptimization = 512
	case internalCall = 4096
	case maxMethodImplVal = 65535
}

extension System_Reflection_MethodImplAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MethodImplAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_ExceptionHandlingClauseOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_ExceptionHandlingClauseOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_ExceptionHandlingClauseOptions_t { get {
		System_Reflection_ExceptionHandlingClauseOptions_t(rawValue: rawValue)
	}}

	public static let clause = System_Reflection_ExceptionHandlingClauseOptions([])
	public static let filter = System_Reflection_ExceptionHandlingClauseOptions(rawValue: 1)
	public static let finally = System_Reflection_ExceptionHandlingClauseOptions(rawValue: 2)
	public static let fault = System_Reflection_ExceptionHandlingClauseOptions(rawValue: 4)
}

extension System_Reflection_ExceptionHandlingClauseOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ExceptionHandlingClauseOptions_TypeOf())
		
	}}
	
	
	
}

public enum System_Threading_Tasks_TaskStatus: Int32 {
	init(cValue: System_Threading_Tasks_TaskStatus_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Threading_Tasks_TaskStatus_t { get {
		System_Threading_Tasks_TaskStatus_t(rawValue: rawValue)!
	}}

	case created = 0
	case waitingForActivation = 1
	case waitingToRun = 2
	case running = 3
	case waitingForChildrenToComplete = 4
	case ranToCompletion = 5
	case canceled = 6
	case faulted = 7
}

extension System_Threading_Tasks_TaskStatus {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_TaskStatus_TypeOf())
		
	}}
	
	
	
}

public struct System_Threading_Tasks_TaskCreationOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Threading_Tasks_TaskCreationOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Threading_Tasks_TaskCreationOptions_t { get {
		System_Threading_Tasks_TaskCreationOptions_t(rawValue: rawValue)
	}}

	public static let none = System_Threading_Tasks_TaskCreationOptions([])
	public static let preferFairness = System_Threading_Tasks_TaskCreationOptions(rawValue: 1)
	public static let longRunning = System_Threading_Tasks_TaskCreationOptions(rawValue: 2)
	public static let attachedToParent = System_Threading_Tasks_TaskCreationOptions(rawValue: 4)
	public static let denyChildAttach = System_Threading_Tasks_TaskCreationOptions(rawValue: 8)
	public static let hideScheduler = System_Threading_Tasks_TaskCreationOptions(rawValue: 16)
	public static let runContinuationsAsynchronously = System_Threading_Tasks_TaskCreationOptions(rawValue: 64)
}

extension System_Threading_Tasks_TaskCreationOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_TaskCreationOptions_TypeOf())
		
	}}
	
	
	
}

public struct System_Threading_Tasks_TaskContinuationOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Threading_Tasks_TaskContinuationOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Threading_Tasks_TaskContinuationOptions_t { get {
		System_Threading_Tasks_TaskContinuationOptions_t(rawValue: rawValue)
	}}

	public static let none = System_Threading_Tasks_TaskContinuationOptions([])
	public static let preferFairness = System_Threading_Tasks_TaskContinuationOptions(rawValue: 1)
	public static let longRunning = System_Threading_Tasks_TaskContinuationOptions(rawValue: 2)
	public static let attachedToParent = System_Threading_Tasks_TaskContinuationOptions(rawValue: 4)
	public static let denyChildAttach = System_Threading_Tasks_TaskContinuationOptions(rawValue: 8)
	public static let hideScheduler = System_Threading_Tasks_TaskContinuationOptions(rawValue: 16)
	public static let lazyCancellation = System_Threading_Tasks_TaskContinuationOptions(rawValue: 32)
	public static let runContinuationsAsynchronously = System_Threading_Tasks_TaskContinuationOptions(rawValue: 64)
	public static let notOnRanToCompletion = System_Threading_Tasks_TaskContinuationOptions(rawValue: 65536)
	public static let notOnFaulted = System_Threading_Tasks_TaskContinuationOptions(rawValue: 131072)
	public static let onlyOnCanceled = System_Threading_Tasks_TaskContinuationOptions(rawValue: 196608)
	public static let notOnCanceled = System_Threading_Tasks_TaskContinuationOptions(rawValue: 262144)
	public static let onlyOnFaulted = System_Threading_Tasks_TaskContinuationOptions(rawValue: 327680)
	public static let onlyOnRanToCompletion = System_Threading_Tasks_TaskContinuationOptions(rawValue: 393216)
	public static let executeSynchronously = System_Threading_Tasks_TaskContinuationOptions(rawValue: 524288)
}

extension System_Threading_Tasks_TaskContinuationOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_TaskContinuationOptions_TypeOf())
		
	}}
	
	
	
}

public struct System_Threading_Tasks_ConfigureAwaitOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Threading_Tasks_ConfigureAwaitOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Threading_Tasks_ConfigureAwaitOptions_t { get {
		System_Threading_Tasks_ConfigureAwaitOptions_t(rawValue: rawValue)
	}}

	public static let none = System_Threading_Tasks_ConfigureAwaitOptions([])
	public static let continueOnCapturedContext = System_Threading_Tasks_ConfigureAwaitOptions(rawValue: 1)
	public static let suppressThrowing = System_Threading_Tasks_ConfigureAwaitOptions(rawValue: 2)
	public static let forceYielding = System_Threading_Tasks_ConfigureAwaitOptions(rawValue: 4)
}

extension System_Threading_Tasks_ConfigureAwaitOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_ConfigureAwaitOptions_TypeOf())
		
	}}
	
	
	
}

public enum System_Threading_Tasks_Sources_ValueTaskSourceStatus: Int32 {
	init(cValue: System_Threading_Tasks_Sources_ValueTaskSourceStatus_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Threading_Tasks_Sources_ValueTaskSourceStatus_t { get {
		System_Threading_Tasks_Sources_ValueTaskSourceStatus_t(rawValue: rawValue)!
	}}

	case pending = 0
	case succeeded = 1
	case faulted = 2
	case canceled = 3
}

extension System_Threading_Tasks_Sources_ValueTaskSourceStatus {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_Sources_ValueTaskSourceStatus_TypeOf())
		
	}}
	
	
	
}

public struct System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags_t { get {
		System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags_t(rawValue: rawValue)
	}}

	public static let none = System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags([])
	public static let useSchedulingContext = System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags(rawValue: 1)
	public static let flowExecutionContext = System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags(rawValue: 2)
}

extension System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags_TypeOf())
		
	}}
	
	
	
}

public enum System_IO_SeekOrigin: Int32 {
	init(cValue: System_IO_SeekOrigin_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_IO_SeekOrigin_t { get {
		System_IO_SeekOrigin_t(rawValue: rawValue)!
	}}

	case begin = 0
	case current = 1
	case end = 2
}

extension System_IO_SeekOrigin {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_SeekOrigin_TypeOf())
		
	}}
	
	
	
}

public struct System_IO_FileAccess: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_IO_FileAccess_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_IO_FileAccess_t { get {
		System_IO_FileAccess_t(rawValue: rawValue)
	}}

	public static let read = System_IO_FileAccess(rawValue: 1)
	public static let write = System_IO_FileAccess(rawValue: 2)
	public static let readWrite = System_IO_FileAccess(rawValue: 3)
}

extension System_IO_FileAccess {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileAccess_TypeOf())
		
	}}
	
	
	
}

public enum System_IO_FileMode: Int32 {
	init(cValue: System_IO_FileMode_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_IO_FileMode_t { get {
		System_IO_FileMode_t(rawValue: rawValue)!
	}}

	case createNew = 1
	case create = 2
	case `open` = 3
	case openOrCreate = 4
	case truncate = 5
	case append = 6
}

extension System_IO_FileMode {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileMode_TypeOf())
		
	}}
	
	
	
}

public struct System_IO_FileShare: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_IO_FileShare_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_IO_FileShare_t { get {
		System_IO_FileShare_t(rawValue: rawValue)
	}}

	public static let none = System_IO_FileShare([])
	public static let read = System_IO_FileShare(rawValue: 1)
	public static let write = System_IO_FileShare(rawValue: 2)
	public static let readWrite = System_IO_FileShare(rawValue: 3)
	public static let delete = System_IO_FileShare(rawValue: 4)
	public static let inheritable = System_IO_FileShare(rawValue: 16)
}

extension System_IO_FileShare {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileShare_TypeOf())
		
	}}
	
	
	
}

public struct System_IO_FileOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_IO_FileOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_IO_FileOptions_t { get {
		System_IO_FileOptions_t(rawValue: rawValue)
	}}

	public static let none = System_IO_FileOptions([])
	public static let encrypted = System_IO_FileOptions(rawValue: 16384)
	public static let deleteOnClose = System_IO_FileOptions(rawValue: 67108864)
	public static let sequentialScan = System_IO_FileOptions(rawValue: 134217728)
	public static let randomAccess = System_IO_FileOptions(rawValue: 268435456)
	public static let asynchronous = System_IO_FileOptions(rawValue: 1073741824)
	public static let writeThrough = System_IO_FileOptions(rawValue: -2147483648)
}

extension System_IO_FileOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileOptions_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_EventAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_EventAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_EventAttributes_t { get {
		System_Reflection_EventAttributes_t(rawValue: rawValue)
	}}

	public static let none = System_Reflection_EventAttributes([])
	public static let specialName = System_Reflection_EventAttributes(rawValue: 512)
	public static let rTSpecialName = System_Reflection_EventAttributes(rawValue: 1024)
	public static let reservedMask = System_Reflection_EventAttributes(rawValue: 1024)
}

extension System_Reflection_EventAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_EventAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_ResourceLocation: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_ResourceLocation_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_ResourceLocation_t { get {
		System_Reflection_ResourceLocation_t(rawValue: rawValue)
	}}

	public static let embedded = System_Reflection_ResourceLocation(rawValue: 1)
	public static let containedInAnotherAssembly = System_Reflection_ResourceLocation(rawValue: 2)
	public static let containedInManifestFile = System_Reflection_ResourceLocation(rawValue: 4)
}

extension System_Reflection_ResourceLocation {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ResourceLocation_TypeOf())
		
	}}
	
	
	
}

public enum System_Security_SecurityRuleSet: UInt8 {
	init(cValue: System_Security_SecurityRuleSet_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Security_SecurityRuleSet_t { get {
		System_Security_SecurityRuleSet_t(rawValue: rawValue)!
	}}

	case none = 0
	case level1 = 1
	case level2 = 2
}

extension System_Security_SecurityRuleSet {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_SecurityRuleSet_TypeOf())
		
	}}
	
	
	
}

public enum System_Buffers_OperationStatus: Int32 {
	init(cValue: System_Buffers_OperationStatus_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Buffers_OperationStatus_t { get {
		System_Buffers_OperationStatus_t(rawValue: rawValue)!
	}}

	case done = 0
	case destinationTooSmall = 1
	case needMoreData = 2
	case invalidData = 3
}

extension System_Buffers_OperationStatus {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Buffers_OperationStatus_TypeOf())
		
	}}
	
	
	
}

public enum System_Globalization_UnicodeCategory: Int32 {
	init(cValue: System_Globalization_UnicodeCategory_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Globalization_UnicodeCategory_t { get {
		System_Globalization_UnicodeCategory_t(rawValue: rawValue)!
	}}

	case uppercaseLetter = 0
	case lowercaseLetter = 1
	case titlecaseLetter = 2
	case modifierLetter = 3
	case otherLetter = 4
	case nonSpacingMark = 5
	case spacingCombiningMark = 6
	case enclosingMark = 7
	case decimalDigitNumber = 8
	case letterNumber = 9
	case otherNumber = 10
	case spaceSeparator = 11
	case lineSeparator = 12
	case paragraphSeparator = 13
	case control = 14
	case format = 15
	case surrogate = 16
	case privateUse = 17
	case connectorPunctuation = 18
	case dashPunctuation = 19
	case openPunctuation = 20
	case closePunctuation = 21
	case initialQuotePunctuation = 22
	case finalQuotePunctuation = 23
	case otherPunctuation = 24
	case mathSymbol = 25
	case currencySymbol = 26
	case modifierSymbol = 27
	case otherSymbol = 28
	case otherNotAssigned = 29
}

extension System_Globalization_UnicodeCategory {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_UnicodeCategory_TypeOf())
		
	}}
	
	
	
}

public struct System_Globalization_CompareOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Globalization_CompareOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Globalization_CompareOptions_t { get {
		System_Globalization_CompareOptions_t(rawValue: rawValue)
	}}

	public static let none = System_Globalization_CompareOptions([])
	public static let ignoreCase = System_Globalization_CompareOptions(rawValue: 1)
	public static let ignoreNonSpace = System_Globalization_CompareOptions(rawValue: 2)
	public static let ignoreSymbols = System_Globalization_CompareOptions(rawValue: 4)
	public static let ignoreKanaType = System_Globalization_CompareOptions(rawValue: 8)
	public static let ignoreWidth = System_Globalization_CompareOptions(rawValue: 16)
	public static let ordinalIgnoreCase = System_Globalization_CompareOptions(rawValue: 268435456)
	public static let stringSort = System_Globalization_CompareOptions(rawValue: 536870912)
	public static let ordinal = System_Globalization_CompareOptions(rawValue: 1073741824)
}

extension System_Globalization_CompareOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_CompareOptions_TypeOf())
		
	}}
	
	
	
}

public enum System_Globalization_DigitShapes: Int32 {
	init(cValue: System_Globalization_DigitShapes_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Globalization_DigitShapes_t { get {
		System_Globalization_DigitShapes_t(rawValue: rawValue)!
	}}

	case context = 0
	case none = 1
	case nativeNational = 2
}

extension System_Globalization_DigitShapes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_DigitShapes_TypeOf())
		
	}}
	
	
	
}

public enum System_StringComparison: Int32 {
	init(cValue: System_StringComparison_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_StringComparison_t { get {
		System_StringComparison_t(rawValue: rawValue)!
	}}

	case currentCulture = 0
	case currentCultureIgnoreCase = 1
	case invariantCulture = 2
	case invariantCultureIgnoreCase = 3
	case ordinal = 4
	case ordinalIgnoreCase = 5
}

extension System_StringComparison {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_StringComparison_TypeOf())
		
	}}
	
	
	
}

public enum System_Text_NormalizationForm: Int32 {
	init(cValue: System_Text_NormalizationForm_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Text_NormalizationForm_t { get {
		System_Text_NormalizationForm_t(rawValue: rawValue)!
	}}

	case formC = 1
	case formD = 2
	case formKC = 5
	case formKD = 6
}

extension System_Text_NormalizationForm {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_NormalizationForm_TypeOf())
		
	}}
	
	
	
}

public struct System_StringSplitOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_StringSplitOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_StringSplitOptions_t { get {
		System_StringSplitOptions_t(rawValue: rawValue)
	}}

	public static let none = System_StringSplitOptions([])
	public static let removeEmptyEntries = System_StringSplitOptions(rawValue: 1)
	public static let trimEntries = System_StringSplitOptions(rawValue: 2)
}

extension System_StringSplitOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_StringSplitOptions_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_GenericParameterAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_GenericParameterAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_GenericParameterAttributes_t { get {
		System_Reflection_GenericParameterAttributes_t(rawValue: rawValue)
	}}

	public static let none = System_Reflection_GenericParameterAttributes([])
	public static let covariant = System_Reflection_GenericParameterAttributes(rawValue: 1)
	public static let contravariant = System_Reflection_GenericParameterAttributes(rawValue: 2)
	public static let varianceMask = System_Reflection_GenericParameterAttributes(rawValue: 3)
	public static let referenceTypeConstraint = System_Reflection_GenericParameterAttributes(rawValue: 4)
	public static let notNullableValueTypeConstraint = System_Reflection_GenericParameterAttributes(rawValue: 8)
	public static let defaultConstructorConstraint = System_Reflection_GenericParameterAttributes(rawValue: 16)
	public static let specialConstraintMask = System_Reflection_GenericParameterAttributes(rawValue: 28)
}

extension System_Reflection_GenericParameterAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_GenericParameterAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_Reflection_TypeAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Reflection_TypeAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Reflection_TypeAttributes_t { get {
		System_Reflection_TypeAttributes_t(rawValue: rawValue)
	}}

	public static let notPublic = System_Reflection_TypeAttributes([])
	public static let autoLayout = System_Reflection_TypeAttributes([])
	public static let ansiClass = System_Reflection_TypeAttributes([])
	public static let `class` = System_Reflection_TypeAttributes([])
	public static let `public` = System_Reflection_TypeAttributes(rawValue: 1)
	public static let nestedPublic = System_Reflection_TypeAttributes(rawValue: 2)
	public static let nestedPrivate = System_Reflection_TypeAttributes(rawValue: 3)
	public static let nestedFamily = System_Reflection_TypeAttributes(rawValue: 4)
	public static let nestedAssembly = System_Reflection_TypeAttributes(rawValue: 5)
	public static let nestedFamANDAssem = System_Reflection_TypeAttributes(rawValue: 6)
	public static let visibilityMask = System_Reflection_TypeAttributes(rawValue: 7)
	public static let nestedFamORAssem = System_Reflection_TypeAttributes(rawValue: 7)
	public static let sequentialLayout = System_Reflection_TypeAttributes(rawValue: 8)
	public static let explicitLayout = System_Reflection_TypeAttributes(rawValue: 16)
	public static let layoutMask = System_Reflection_TypeAttributes(rawValue: 24)
	public static let interface = System_Reflection_TypeAttributes(rawValue: 32)
	public static let classSemanticsMask = System_Reflection_TypeAttributes(rawValue: 32)
	public static let abstract = System_Reflection_TypeAttributes(rawValue: 128)
	public static let sealed = System_Reflection_TypeAttributes(rawValue: 256)
	public static let specialName = System_Reflection_TypeAttributes(rawValue: 1024)
	public static let rTSpecialName = System_Reflection_TypeAttributes(rawValue: 2048)
	public static let `import` = System_Reflection_TypeAttributes(rawValue: 4096)
	public static let serializable = System_Reflection_TypeAttributes(rawValue: 8192)
	public static let windowsRuntime = System_Reflection_TypeAttributes(rawValue: 16384)
	public static let unicodeClass = System_Reflection_TypeAttributes(rawValue: 65536)
	public static let autoClass = System_Reflection_TypeAttributes(rawValue: 131072)
	public static let stringFormatMask = System_Reflection_TypeAttributes(rawValue: 196608)
	public static let customFormatClass = System_Reflection_TypeAttributes(rawValue: 196608)
	public static let hasSecurity = System_Reflection_TypeAttributes(rawValue: 262144)
	public static let reservedMask = System_Reflection_TypeAttributes(rawValue: 264192)
	public static let beforeFieldInit = System_Reflection_TypeAttributes(rawValue: 1048576)
	public static let customFormatMask = System_Reflection_TypeAttributes(rawValue: 12582912)
}

extension System_Reflection_TypeAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_TypeAttributes_TypeOf())
		
	}}
	
	
	
}

public enum System_Runtime_InteropServices_LayoutKind: Int32 {
	init(cValue: System_Runtime_InteropServices_LayoutKind_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Runtime_InteropServices_LayoutKind_t { get {
		System_Runtime_InteropServices_LayoutKind_t(rawValue: rawValue)!
	}}

	case sequential = 0
	case explicit = 2
	case auto = 3
}

extension System_Runtime_InteropServices_LayoutKind {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_LayoutKind_TypeOf())
		
	}}
	
	
	
}

public enum System_Runtime_InteropServices_CharSet: Int32 {
	init(cValue: System_Runtime_InteropServices_CharSet_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Runtime_InteropServices_CharSet_t { get {
		System_Runtime_InteropServices_CharSet_t(rawValue: rawValue)!
	}}

	case none = 1
	case ansi = 2
	case unicode = 3
	case auto = 4
}

extension System_Runtime_InteropServices_CharSet {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_CharSet_TypeOf())
		
	}}
	
	
	
}

public enum System_Runtime_InteropServices_CustomQueryInterfaceMode: Int32 {
	init(cValue: System_Runtime_InteropServices_CustomQueryInterfaceMode_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Runtime_InteropServices_CustomQueryInterfaceMode_t { get {
		System_Runtime_InteropServices_CustomQueryInterfaceMode_t(rawValue: rawValue)!
	}}

	case ignore = 0
	case allow = 1
}

extension System_Runtime_InteropServices_CustomQueryInterfaceMode {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_CustomQueryInterfaceMode_TypeOf())
		
	}}
	
	
	
}

public enum System_Runtime_InteropServices_GCHandleType: Int32 {
	init(cValue: System_Runtime_InteropServices_GCHandleType_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Runtime_InteropServices_GCHandleType_t { get {
		System_Runtime_InteropServices_GCHandleType_t(rawValue: rawValue)!
	}}

	case `weak` = 0
	case weakTrackResurrection = 1
	case normal = 2
	case pinned = 3
}

extension System_Runtime_InteropServices_GCHandleType {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_GCHandleType_TypeOf())
		
	}}
	
	
	
}

public enum System_GCKind: Int32 {
	init(cValue: System_GCKind_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_GCKind_t { get {
		System_GCKind_t(rawValue: rawValue)!
	}}

	case any = 0
	case ephemeral = 1
	case fullBlocking = 2
	case background = 3
}

extension System_GCKind {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_GCKind_TypeOf())
		
	}}
	
	
	
}

public enum System_GCCollectionMode: Int32 {
	init(cValue: System_GCCollectionMode_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_GCCollectionMode_t { get {
		System_GCCollectionMode_t(rawValue: rawValue)!
	}}

	case `default` = 0
	case forced = 1
	case optimized = 2
	case aggressive = 3
}

extension System_GCCollectionMode {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_GCCollectionMode_TypeOf())
		
	}}
	
	
	
}

public enum System_GCNotificationStatus: Int32 {
	init(cValue: System_GCNotificationStatus_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_GCNotificationStatus_t { get {
		System_GCNotificationStatus_t(rawValue: rawValue)!
	}}

	case succeeded = 0
	case failed = 1
	case canceled = 2
	case timeout = 3
	case notApplicable = 4
}

extension System_GCNotificationStatus {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_GCNotificationStatus_TypeOf())
		
	}}
	
	
	
}

public struct System_Base64FormattingOptions: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Base64FormattingOptions_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Base64FormattingOptions_t { get {
		System_Base64FormattingOptions_t(rawValue: rawValue)
	}}

	public static let none = System_Base64FormattingOptions([])
	public static let insertLineBreaks = System_Base64FormattingOptions(rawValue: 1)
}

extension System_Base64FormattingOptions {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Base64FormattingOptions_TypeOf())
		
	}}
	
	
	
}

public enum System_Threading_ThreadPriority: Int32 {
	init(cValue: System_Threading_ThreadPriority_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Threading_ThreadPriority_t { get {
		System_Threading_ThreadPriority_t(rawValue: rawValue)!
	}}

	case lowest = 0
	case belowNormal = 1
	case normal = 2
	case aboveNormal = 3
	case highest = 4
}

extension System_Threading_ThreadPriority {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ThreadPriority_TypeOf())
		
	}}
	
	
	
}

public struct System_Threading_ThreadState: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_Threading_ThreadState_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_Threading_ThreadState_t { get {
		System_Threading_ThreadState_t(rawValue: rawValue)
	}}

	public static let running = System_Threading_ThreadState([])
	public static let stopRequested = System_Threading_ThreadState(rawValue: 1)
	public static let suspendRequested = System_Threading_ThreadState(rawValue: 2)
	public static let background = System_Threading_ThreadState(rawValue: 4)
	public static let unstarted = System_Threading_ThreadState(rawValue: 8)
	public static let stopped = System_Threading_ThreadState(rawValue: 16)
	public static let waitSleepJoin = System_Threading_ThreadState(rawValue: 32)
	public static let suspended = System_Threading_ThreadState(rawValue: 64)
	public static let abortRequested = System_Threading_ThreadState(rawValue: 128)
	public static let aborted = System_Threading_ThreadState(rawValue: 256)
}

extension System_Threading_ThreadState {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ThreadState_TypeOf())
		
	}}
	
	
	
}

public enum System_Threading_ApartmentState: Int32 {
	init(cValue: System_Threading_ApartmentState_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Threading_ApartmentState_t { get {
		System_Threading_ApartmentState_t(rawValue: rawValue)!
	}}

	case sTA = 0
	case mTA = 1
	case unknown = 2
}

extension System_Threading_ApartmentState {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ApartmentState_TypeOf())
		
	}}
	
	
	
}

public enum System_Security_Permissions_PermissionState: Int32 {
	init(cValue: System_Security_Permissions_PermissionState_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Security_Permissions_PermissionState_t { get {
		System_Security_Permissions_PermissionState_t(rawValue: rawValue)!
	}}

	case none = 0
	case unrestricted = 1
}

extension System_Security_Permissions_PermissionState {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_Permissions_PermissionState_TypeOf())
		
	}}
	
	
	
}

public enum System_Security_Principal_PrincipalPolicy: Int32 {
	init(cValue: System_Security_Principal_PrincipalPolicy_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_Security_Principal_PrincipalPolicy_t { get {
		System_Security_Principal_PrincipalPolicy_t(rawValue: rawValue)!
	}}

	case unauthenticatedPrincipal = 0
	case noPrincipal = 1
	case windowsPrincipal = 2
}

extension System_Security_Principal_PrincipalPolicy {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_Principal_PrincipalPolicy_TypeOf())
		
	}}
	
	
	
}

public struct System_IO_FileAttributes: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_IO_FileAttributes_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_IO_FileAttributes_t { get {
		System_IO_FileAttributes_t(rawValue: rawValue)
	}}

	public static let none = System_IO_FileAttributes([])
	public static let readOnly = System_IO_FileAttributes(rawValue: 1)
	public static let hidden = System_IO_FileAttributes(rawValue: 2)
	public static let system = System_IO_FileAttributes(rawValue: 4)
	public static let directory = System_IO_FileAttributes(rawValue: 16)
	public static let archive = System_IO_FileAttributes(rawValue: 32)
	public static let device = System_IO_FileAttributes(rawValue: 64)
	public static let normal = System_IO_FileAttributes(rawValue: 128)
	public static let temporary = System_IO_FileAttributes(rawValue: 256)
	public static let sparseFile = System_IO_FileAttributes(rawValue: 512)
	public static let reparsePoint = System_IO_FileAttributes(rawValue: 1024)
	public static let compressed = System_IO_FileAttributes(rawValue: 2048)
	public static let offline = System_IO_FileAttributes(rawValue: 4096)
	public static let notContentIndexed = System_IO_FileAttributes(rawValue: 8192)
	public static let encrypted = System_IO_FileAttributes(rawValue: 16384)
	public static let integrityStream = System_IO_FileAttributes(rawValue: 32768)
	public static let noScrubData = System_IO_FileAttributes(rawValue: 131072)
}

extension System_IO_FileAttributes {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileAttributes_TypeOf())
		
	}}
	
	
	
}

public struct System_IO_UnixFileMode: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_IO_UnixFileMode_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_IO_UnixFileMode_t { get {
		System_IO_UnixFileMode_t(rawValue: rawValue)
	}}

	public static let none = System_IO_UnixFileMode([])
	public static let otherExecute = System_IO_UnixFileMode(rawValue: 1)
	public static let otherWrite = System_IO_UnixFileMode(rawValue: 2)
	public static let otherRead = System_IO_UnixFileMode(rawValue: 4)
	public static let groupExecute = System_IO_UnixFileMode(rawValue: 8)
	public static let groupWrite = System_IO_UnixFileMode(rawValue: 16)
	public static let groupRead = System_IO_UnixFileMode(rawValue: 32)
	public static let userExecute = System_IO_UnixFileMode(rawValue: 64)
	public static let userWrite = System_IO_UnixFileMode(rawValue: 128)
	public static let userRead = System_IO_UnixFileMode(rawValue: 256)
	public static let stickyBit = System_IO_UnixFileMode(rawValue: 512)
	public static let setGroup = System_IO_UnixFileMode(rawValue: 1024)
	public static let setUser = System_IO_UnixFileMode(rawValue: 2048)
}

extension System_IO_UnixFileMode {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_UnixFileMode_TypeOf())
		
	}}
	
	
	
}

public enum System_IO_SearchOption: Int32 {
	init(cValue: System_IO_SearchOption_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_IO_SearchOption_t { get {
		System_IO_SearchOption_t(rawValue: rawValue)!
	}}

	case topDirectoryOnly = 0
	case allDirectories = 1
}

extension System_IO_SearchOption {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_SearchOption_TypeOf())
		
	}}
	
	
	
}

public enum System_IO_MatchType: Int32 {
	init(cValue: System_IO_MatchType_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_IO_MatchType_t { get {
		System_IO_MatchType_t(rawValue: rawValue)!
	}}

	case simple = 0
	case win32 = 1
}

extension System_IO_MatchType {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_MatchType_TypeOf())
		
	}}
	
	
	
}

public enum System_IO_MatchCasing: Int32 {
	init(cValue: System_IO_MatchCasing_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_IO_MatchCasing_t { get {
		System_IO_MatchCasing_t(rawValue: rawValue)!
	}}

	case platformDefault = 0
	case caseSensitive = 1
	case caseInsensitive = 2
}

extension System_IO_MatchCasing {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_MatchCasing_TypeOf())
		
	}}
	
	
	
}

public enum Beyond_NET_Sample_NiceLevels: UInt32 {
	init(cValue: Beyond_NET_Sample_NiceLevels_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: Beyond_NET_Sample_NiceLevels_t { get {
		Beyond_NET_Sample_NiceLevels_t(rawValue: rawValue)!
	}}

	case notNice = 0
	case littleBitNice = 1
	case nice = 2
	case veryNice = 3
}

extension Beyond_NET_Sample_NiceLevels {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_NiceLevels_TypeOf())
		
	}}
	
	
	
}

public enum System_UriHostNameType: Int32 {
	init(cValue: System_UriHostNameType_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_UriHostNameType_t { get {
		System_UriHostNameType_t(rawValue: rawValue)!
	}}

	case unknown = 0
	case basic = 1
	case dns = 2
	case iPv4 = 3
	case iPv6 = 4
}

extension System_UriHostNameType {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UriHostNameType_TypeOf())
		
	}}
	
	
	
}

public enum System_UriPartial: Int32 {
	init(cValue: System_UriPartial_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_UriPartial_t { get {
		System_UriPartial_t(rawValue: rawValue)!
	}}

	case scheme = 0
	case authority = 1
	case path = 2
	case query = 3
}

extension System_UriPartial {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UriPartial_TypeOf())
		
	}}
	
	
	
}

public enum System_UriKind: Int32 {
	init(cValue: System_UriKind_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_UriKind_t { get {
		System_UriKind_t(rawValue: rawValue)!
	}}

	case relativeOrAbsolute = 0
	case absolute = 1
	case relative = 2
}

extension System_UriKind {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UriKind_TypeOf())
		
	}}
	
	
	
}

public struct System_UriComponents: OptionSet {
	public typealias RawValue = Int32
	public let rawValue: RawValue

	public init(rawValue: RawValue) {
		self.rawValue = rawValue
	}

	init(cValue: System_UriComponents_t) {
		self.init(rawValue: cValue.rawValue)
	}

	var cValue: System_UriComponents_t { get {
		System_UriComponents_t(rawValue: rawValue)
	}}

	public static let scheme = System_UriComponents(rawValue: 1)
	public static let userInfo = System_UriComponents(rawValue: 2)
	public static let host = System_UriComponents(rawValue: 4)
	public static let port = System_UriComponents(rawValue: 8)
	public static let schemeAndServer = System_UriComponents(rawValue: 13)
	public static let path = System_UriComponents(rawValue: 16)
	public static let query = System_UriComponents(rawValue: 32)
	public static let pathAndQuery = System_UriComponents(rawValue: 48)
	public static let httpRequestUrl = System_UriComponents(rawValue: 61)
	public static let fragment = System_UriComponents(rawValue: 64)
	public static let absoluteUri = System_UriComponents(rawValue: 127)
	public static let strongPort = System_UriComponents(rawValue: 128)
	public static let hostAndPort = System_UriComponents(rawValue: 132)
	public static let strongAuthority = System_UriComponents(rawValue: 134)
	public static let normalizedHost = System_UriComponents(rawValue: 256)
	public static let keepDelimiter = System_UriComponents(rawValue: 1073741824)
	public static let serializationInfoString = System_UriComponents(rawValue: -2147483648)
}

extension System_UriComponents {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UriComponents_TypeOf())
		
	}}
	
	
	
}

public enum System_UriFormat: Int32 {
	init(cValue: System_UriFormat_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: System_UriFormat_t { get {
		System_UriFormat_t(rawValue: rawValue)!
	}}

	case uriEscaped = 1
	case unescaped = 2
	case safeUnescaped = 3
}

extension System_UriFormat {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UriFormat_TypeOf())
		
	}}
	
	
	
}

public enum Beyond_NET_Sample_TestEnum: Int32 {
	init(cValue: Beyond_NET_Sample_TestEnum_t) {
		self.init(rawValue: cValue.rawValue)!
	}

	var cValue: Beyond_NET_Sample_TestEnum_t { get {
		Beyond_NET_Sample_TestEnum_t(rawValue: rawValue)!
	}}

	case firstCase = 0
	case secondCase = 1
}

extension Beyond_NET_Sample_TestEnum {
	public static var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_TestEnum_TypeOf())
		
	}}
	
	
	
}

public class System_Object /* System.Object */: DNObject {
	public override class var typeName: String { get {
		"Object"
	}}

	public override class var fullTypeName: String { get {
		"System.Object"
	}}

	public func getType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_GetType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ objA: System_Object? /* System.Object */, _ objB: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objAC = objA?.__handle
		let objBC = objB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_Equals_1(objAC, objBC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func referenceEquals(_ objA: System_Object? /* System.Object */, _ objB: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objAC = objA?.__handle
		let objBC = objB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_ReferenceEquals(objAC, objBC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Object_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Object_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Object_Destroy(self.__handle)
		
	}
	
	
}


public class System_Type /* System.Type */: System_Reflection_MemberInfo {
	public override class var typeName: String { get {
		"Type"
	}}

	public override class var fullTypeName: String { get {
		"System.Type"
	}}

	public class func getType(_ typeName: System_String /* System.String */, _ throwOnError: Bool /* System.Boolean */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetType(typeNameC, throwOnError, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getType(_ typeName: System_String /* System.String */, _ throwOnError: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetType_1(typeNameC, throwOnError, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getType(_ typeName: System_String /* System.String */) throws -> System_Type? /* System.Type */ {
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetType_2(typeNameC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromHandle(_ handle: System_RuntimeTypeHandle /* System.RuntimeTypeHandle */) throws -> System_Type? /* System.Type */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromHandle(handleC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetType_3(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getElementType() throws -> System_Type? /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetElementType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getArrayRank() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetArrayRank(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getGenericTypeDefinition() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetGenericTypeDefinition(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getGenericArguments() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetGenericArguments(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getOptionalCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetOptionalCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRequiredCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetRequiredCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getGenericParameterConstraints() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetGenericParameterConstraints(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isAssignableTo(_ targetType: System_Type? /* System.Type */) throws -> Bool /* System.Boolean */ {
		let targetTypeC = targetType?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsAssignableTo(self.__handle, targetTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getConstructor(_ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_ConstructorInfo? /* System.Reflection.ConstructorInfo */ {
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetConstructor(self.__handle, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getConstructor(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_ConstructorInfo? /* System.Reflection.ConstructorInfo */ {
		let bindingAttrC = bindingAttr.cValue
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetConstructor_1(self.__handle, bindingAttrC, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getConstructor(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_ConstructorInfo? /* System.Reflection.ConstructorInfo */ {
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetConstructor_2(self.__handle, bindingAttrC, binderC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getConstructor(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ callConvention: System_Reflection_CallingConventions /* System.Reflection.CallingConventions */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_ConstructorInfo? /* System.Reflection.ConstructorInfo */ {
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let callConventionC = callConvention.cValue
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetConstructor_3(self.__handle, bindingAttrC, binderC, callConventionC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getConstructors() throws -> System_Reflection_ConstructorInfo_Array /* System.Reflection.ConstructorInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetConstructors(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getConstructors(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_ConstructorInfo_Array /* System.Reflection.ConstructorInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetConstructors_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEvent(_ name: System_String /* System.String */) throws -> System_Reflection_EventInfo? /* System.Reflection.EventInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEvent(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_EventInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEvent(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_EventInfo? /* System.Reflection.EventInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEvent_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_EventInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEvents() throws -> System_Reflection_EventInfo_Array /* System.Reflection.EventInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEvents(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_EventInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEvents(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_EventInfo_Array /* System.Reflection.EventInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEvents_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_EventInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getField(_ name: System_String /* System.String */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetField(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getField(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetField_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFields() throws -> System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetFields(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFields(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetFields_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFunctionPointerCallingConventions() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetFunctionPointerCallingConventions(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFunctionPointerReturnType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetFunctionPointerReturnType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFunctionPointerParameterTypes() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetFunctionPointerParameterTypes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMember(_ name: System_String /* System.String */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMember(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMember(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMember_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMember(_ name: System_String /* System.String */, _ type: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let nameC = name.__handle
		let typeC = type.cValue
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMember_2(self.__handle, nameC, typeC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMembers() throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMembers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMemberWithSameMetadataDefinitionAs(_ member: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */) throws -> System_Reflection_MemberInfo /* System.Reflection.MemberInfo */ {
		let memberC = member.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMemberWithSameMetadataDefinitionAs(self.__handle, memberC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMembers(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMembers_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_2(self.__handle, nameC, bindingAttrC, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_3(self.__handle, nameC, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_4(self.__handle, nameC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_5(self.__handle, nameC, bindingAttrC, binderC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ callConvention: System_Reflection_CallingConventions /* System.Reflection.CallingConventions */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let callConventionC = callConvention.cValue
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_6(self.__handle, nameC, bindingAttrC, binderC, callConventionC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ genericParameterCount: Int32 /* System.Int32 */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_7(self.__handle, nameC, genericParameterCount, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ genericParameterCount: Int32 /* System.Int32 */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_8(self.__handle, nameC, genericParameterCount, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ genericParameterCount: Int32 /* System.Int32 */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_9(self.__handle, nameC, genericParameterCount, bindingAttrC, binderC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ genericParameterCount: Int32 /* System.Int32 */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ callConvention: System_Reflection_CallingConventions /* System.Reflection.CallingConventions */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let callConventionC = callConvention.cValue
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethod_10(self.__handle, nameC, genericParameterCount, bindingAttrC, binderC, callConventionC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethods() throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethods(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethods(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetMethods_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getNestedType(_ name: System_String /* System.String */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetNestedType(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getNestedType(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetNestedType_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getNestedTypes() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetNestedTypes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getNestedTypes(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Type_Array /* System.Type[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetNestedTypes_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ returnType: System_Type? /* System.Type */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let returnTypeC = returnType?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty_2(self.__handle, nameC, returnTypeC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty_3(self.__handle, nameC, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ returnType: System_Type? /* System.Type */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let returnTypeC = returnType?.__handle
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty_4(self.__handle, nameC, returnTypeC, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ returnType: System_Type? /* System.Type */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let returnTypeC = returnType?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty_5(self.__handle, nameC, returnTypeC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ returnType: System_Type? /* System.Type */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let returnTypeC = returnType?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperty_6(self.__handle, nameC, bindingAttrC, binderC, returnTypeC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperties() throws -> System_Reflection_PropertyInfo_Array /* System.Reflection.PropertyInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperties(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperties(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_PropertyInfo_Array /* System.Reflection.PropertyInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetProperties_1(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDefaultMembers() throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetDefaultMembers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeHandle(_ o: System_Object /* System.Object */) throws -> System_RuntimeTypeHandle /* System.RuntimeTypeHandle */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeHandle(oC, &__exceptionC)
		
		let __returnValue = System_RuntimeTypeHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeArray(_ args: System_Object_Array /* System.Object[] */) throws -> System_Type_Array /* System.Type[] */ {
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeArray(argsC, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeCode(_ type: System_Type? /* System.Type */) throws -> System_TypeCode /* System.TypeCode */ {
		let typeC = type?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeCode(typeC, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromCLSID(_ clsid: System_Guid /* System.Guid */) throws -> System_Type? /* System.Type */ {
		let clsidC = clsid.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromCLSID(clsidC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromCLSID(_ clsid: System_Guid /* System.Guid */, _ throwOnError: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let clsidC = clsid.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromCLSID_1(clsidC, throwOnError, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromCLSID(_ clsid: System_Guid /* System.Guid */, _ server: System_String? /* System.String */) throws -> System_Type? /* System.Type */ {
		let clsidC = clsid.__handle
		let serverC = server?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromCLSID_2(clsidC, serverC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromCLSID(_ clsid: System_Guid /* System.Guid */, _ server: System_String? /* System.String */, _ throwOnError: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let clsidC = clsid.__handle
		let serverC = server?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromCLSID_3(clsidC, serverC, throwOnError, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromProgID(_ progID: System_String /* System.String */) throws -> System_Type? /* System.Type */ {
		let progIDC = progID.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromProgID(progIDC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromProgID(_ progID: System_String /* System.String */, _ throwOnError: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let progIDC = progID.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromProgID_1(progIDC, throwOnError, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromProgID(_ progID: System_String /* System.String */, _ server: System_String? /* System.String */) throws -> System_Type? /* System.Type */ {
		let progIDC = progID.__handle
		let serverC = server?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromProgID_2(progIDC, serverC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromProgID(_ progID: System_String /* System.String */, _ server: System_String? /* System.String */, _ throwOnError: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let progIDC = progID.__handle
		let serverC = server?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetTypeFromProgID_3(progIDC, serverC, throwOnError, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invokeMember(_ name: System_String /* System.String */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ target: System_Object? /* System.Object */, _ args: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let targetC = target?.__handle
		let argsC = args?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_InvokeMember(self.__handle, nameC, invokeAttrC, binderC, targetC, argsC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invokeMember(_ name: System_String /* System.String */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ target: System_Object? /* System.Object */, _ args: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let targetC = target?.__handle
		let argsC = args?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_InvokeMember_1(self.__handle, nameC, invokeAttrC, binderC, targetC, argsC, cultureC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invokeMember(_ name: System_String /* System.String */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ target: System_Object? /* System.Object */, _ args: System_Object_Array? /* System.Object[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ namedParameters: System_String_Array? /* System.String[] */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let targetC = target?.__handle
		let argsC = args?.__handle
		let modifiersC = modifiers?.__handle
		let cultureC = culture?.__handle
		let namedParametersC = namedParameters?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_InvokeMember_2(self.__handle, nameC, invokeAttrC, binderC, targetC, argsC, modifiersC, cultureC, namedParametersC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getInterface(_ name: System_String /* System.String */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetInterface(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getInterface(_ name: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetInterface_1(self.__handle, nameC, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getInterfaces() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetInterfaces(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getInterfaceMap(_ interfaceType: System_Type /* System.Type */) throws -> System_Reflection_InterfaceMapping /* System.Reflection.InterfaceMapping */ {
		let interfaceTypeC = interfaceType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetInterfaceMap(self.__handle, interfaceTypeC, &__exceptionC)
		
		let __returnValue = System_Reflection_InterfaceMapping(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isInstanceOfType(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsInstanceOfType(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isEquivalentTo(_ other: System_Type? /* System.Type */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsEquivalentTo(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getEnumUnderlyingType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEnumUnderlyingType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEnumValues() throws -> System_Array /* System.Array */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEnumValues(self.__handle, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEnumValuesAsUnderlyingType() throws -> System_Array /* System.Array */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEnumValuesAsUnderlyingType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makeArrayType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakeArrayType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makeArrayType(_ rank: Int32 /* System.Int32 */) throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakeArrayType_1(self.__handle, rank, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makeByRefType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakeByRefType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makeGenericType(_ typeArguments: System_Type_Array /* System.Type[] */) throws -> System_Type /* System.Type */ {
		let typeArgumentsC = typeArguments.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakeGenericType(self.__handle, typeArgumentsC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makePointerType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakePointerType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func makeGenericSignatureType(_ genericTypeDefinition: System_Type /* System.Type */, _ typeArguments: System_Type_Array /* System.Type[] */) throws -> System_Type /* System.Type */ {
		let genericTypeDefinitionC = genericTypeDefinition.__handle
		let typeArgumentsC = typeArguments.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakeGenericSignatureType(genericTypeDefinitionC, typeArgumentsC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func makeGenericMethodParameter(_ position: Int32 /* System.Int32 */) throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MakeGenericMethodParameter(position, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_Equals(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ o: System_Type? /* System.Type */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_Equals_1(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reflectionOnlyGetType(_ typeName: System_String /* System.String */, _ throwIfNotFound: Bool /* System.Boolean */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_ReflectionOnlyGetType(typeNameC, throwIfNotFound, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isEnumDefined(_ value: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsEnumDefined(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getEnumName(_ value: System_Object /* System.Object */) throws -> System_String? /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEnumName(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEnumNames() throws -> System_String_Array /* System.String[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GetEnumNames(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func findInterfaces(_ filter: System_Reflection_TypeFilter /* System.Reflection.TypeFilter */, _ filterCriteria: System_Object? /* System.Object */) throws -> System_Type_Array /* System.Type[] */ {
		let filterC = filter.__handle
		let filterCriteriaC = filterCriteria?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_FindInterfaces(self.__handle, filterC, filterCriteriaC, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func findMembers(_ memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ filter: System_Reflection_MemberFilter? /* System.Reflection.MemberFilter */, _ filterCriteria: System_Object? /* System.Object */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let memberTypeC = memberType.cValue
		let bindingAttrC = bindingAttr.cValue
		let filterC = filter?.__handle
		let filterCriteriaC = filterCriteria?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_FindMembers(self.__handle, memberTypeC, bindingAttrC, filterC, filterCriteriaC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isSubclassOf(_ c: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let cC = c.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSubclassOf(self.__handle, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isAssignableFrom(_ c: System_Type? /* System.Type */) throws -> Bool /* System.Boolean */ {
		let cC = c?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsAssignableFrom(self.__handle, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var isInterface: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsInterface_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var namespace: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_Namespace_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var assemblyQualifiedName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_AssemblyQualifiedName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var fullName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_FullName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var assembly: System_Reflection_Assembly /* System.Reflection.Assembly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_Assembly_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override var module: System_Reflection_Module /* System.Reflection.Module */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_Module_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isNested: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNested_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var declaringType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_DeclaringType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaringMethod: System_Reflection_MethodBase? /* System.Reflection.MethodBase */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_DeclaringMethod_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override var reflectedType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_ReflectedType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var underlyingSystemType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_UnderlyingSystemType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isTypeDefinition: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsTypeDefinition_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isArray: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsArray_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isByRef: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsByRef_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPointer: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsPointer_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isConstructedGenericType: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsConstructedGenericType_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericParameter: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsGenericParameter_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericTypeParameter: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsGenericTypeParameter_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericMethodParameter: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsGenericMethodParameter_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericType: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsGenericType_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericTypeDefinition: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsGenericTypeDefinition_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSZArray: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSZArray_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isVariableBoundArray: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsVariableBoundArray_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isByRefLike: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsByRefLike_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFunctionPointer: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsFunctionPointer_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isUnmanagedFunctionPointer: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsUnmanagedFunctionPointer_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var hasElementType: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_HasElementType_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var genericTypeArguments: System_Type_Array /* System.Type[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GenericTypeArguments_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var genericParameterPosition: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GenericParameterPosition_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var genericParameterAttributes: System_Reflection_GenericParameterAttributes /* System.Reflection.GenericParameterAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GenericParameterAttributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_GenericParameterAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var attributes: System_Reflection_TypeAttributes /* System.Reflection.TypeAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_TypeAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isAbstract: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsAbstract_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isImport: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsImport_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSealed: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSealed_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSpecialName: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSpecialName_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isClass: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsClass_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNestedAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNestedAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNestedFamANDAssem: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNestedFamANDAssem_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNestedFamily: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNestedFamily_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNestedFamORAssem: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNestedFamORAssem_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNestedPrivate: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNestedPrivate_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNestedPublic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNestedPublic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNotPublic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsNotPublic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPublic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsPublic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAutoLayout: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsAutoLayout_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isExplicitLayout: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsExplicitLayout_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isLayoutSequential: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsLayoutSequential_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAnsiClass: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsAnsiClass_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAutoClass: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsAutoClass_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isUnicodeClass: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsUnicodeClass_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isCOMObject: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsCOMObject_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isContextful: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsContextful_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isEnum: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsEnum_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isMarshalByRef: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsMarshalByRef_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPrimitive: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsPrimitive_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isValueType: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsValueType_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSignatureType: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSignatureType_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecurityCritical: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSecurityCritical_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecuritySafeCritical: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSecuritySafeCritical_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecurityTransparent: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSecurityTransparent_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var structLayoutAttribute: System_Runtime_InteropServices_StructLayoutAttribute? /* System.Runtime.InteropServices.StructLayoutAttribute */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_StructLayoutAttribute_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_InteropServices_StructLayoutAttribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var typeInitializer: System_Reflection_ConstructorInfo? /* System.Reflection.ConstructorInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_TypeInitializer_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var typeHandle: System_RuntimeTypeHandle /* System.RuntimeTypeHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_TypeHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_RuntimeTypeHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var gUID: System_Guid /* System.Guid */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_GUID_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var baseType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_BaseType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var defaultBinder: System_Reflection_Binder /* System.Reflection.Binder */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_DefaultBinder_Get(&__exceptionC)
		
		let __returnValue = System_Reflection_Binder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isSerializable: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsSerializable_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var containsGenericParameters: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_ContainsGenericParameters_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isVisible: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Type_IsVisible_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var delimiter: DNChar /* System.Char */ { get {
		
		
		let __returnValueC = System_Type_Delimiter_Get()
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var emptyTypes: System_Type_Array /* System.Type[] */ { get {
		
		
		let __returnValueC = System_Type_EmptyTypes_Get()
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var missing: System_Object /* System.Object */ { get {
		
		
		let __returnValueC = System_Type_Missing_Get()
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var filterAttribute: System_Reflection_MemberFilter /* System.Reflection.MemberFilter */ { get {
		
		
		let __returnValueC = System_Type_FilterAttribute_Get()
		
		let __returnValue = System_Reflection_MemberFilter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var filterName: System_Reflection_MemberFilter /* System.Reflection.MemberFilter */ { get {
		
		
		let __returnValueC = System_Type_FilterName_Get()
		
		let __returnValue = System_Reflection_MemberFilter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var filterNameIgnoreCase: System_Reflection_MemberFilter /* System.Reflection.MemberFilter */ { get {
		
		
		let __returnValueC = System_Type_FilterNameIgnoreCase_Get()
		
		let __returnValue = System_Reflection_MemberFilter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Type_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Type_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_MemberInfo /* System.Reflection.MemberInfo */: System_Object {
	public override class var typeName: String { get {
		"MemberInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MemberInfo"
	}}

	public func hasSameMetadataDefinitionAs(_ other: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_HasSameMetadataDefinitionAs(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isDefined(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_IsDefined(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCustomAttributes(_ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_GetCustomAttributes(self.__handle, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_GetCustomAttributes_1(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributesData() throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_GetCustomAttributesData(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaringType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_DeclaringType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var reflectedType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_ReflectedType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var module: System_Reflection_Module /* System.Reflection.Module */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_Module_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var customAttributes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_CustomAttributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isCollectible: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_IsCollectible_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var metadataToken: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MemberInfo_MetadataToken_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MemberInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_MemberInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_ICustomAttributeProvider /* System.Reflection.ICustomAttributeProvider */: DNObject {
	public override class var typeName: String { get {
		"ICustomAttributeProvider"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ICustomAttributeProvider"
	}}

	public func getCustomAttributes(_ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ICustomAttributeProvider_GetCustomAttributes(self.__handle, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ICustomAttributeProvider_GetCustomAttributes_1(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isDefined(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ICustomAttributeProvider_IsDefined(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ICustomAttributeProvider_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ICustomAttributeProvider_Destroy(self.__handle)
		
	}
	
	
}


public class System_Object_Array /* System.Object[] */: System_Array {
	public override class var typeName: String { get {
		"Object[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Object[]"
	}}

	
}


public class System_Array /* System.Array */: System_Object {
	public override class var typeName: String { get {
		"Array"
	}}

	public override class var fullTypeName: String { get {
		"System.Array"
	}}

	public class func constrainedCopy(_ sourceArray: System_Array /* System.Array */, _ sourceIndex: Int32 /* System.Int32 */, _ destinationArray: System_Array /* System.Array */, _ destinationIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let sourceArrayC = sourceArray.__handle
		let destinationArrayC = destinationArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_ConstrainedCopy(sourceArrayC, sourceIndex, destinationArrayC, destinationIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func clear(_ array: System_Array /* System.Array */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Clear(arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func clear(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Clear_1(arrayC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getLength(_ dimension: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetLength(self.__handle, dimension, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getUpperBound(_ dimension: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetUpperBound(self.__handle, dimension, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getLowerBound(_ dimension: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetLowerBound(self.__handle, dimension, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func initialize() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Initialize(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func createInstance(_ elementType: System_Type /* System.Type */, _ length: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let elementTypeC = elementType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_CreateInstance(elementTypeC, length, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createInstance(_ elementType: System_Type /* System.Type */, _ length1: Int32 /* System.Int32 */, _ length2: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let elementTypeC = elementType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_CreateInstance_1(elementTypeC, length1, length2, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createInstance(_ elementType: System_Type /* System.Type */, _ length1: Int32 /* System.Int32 */, _ length2: Int32 /* System.Int32 */, _ length3: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let elementTypeC = elementType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_CreateInstance_2(elementTypeC, length1, length2, length3, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createInstance(_ elementType: System_Type /* System.Type */, _ lengths: System_Int32_Array /* System.Int32[] */) throws -> System_Array /* System.Array */ {
		let elementTypeC = elementType.__handle
		let lengthsC = lengths.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_CreateInstance_3(elementTypeC, lengthsC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createInstance(_ elementType: System_Type /* System.Type */, _ lengths: System_Int32_Array /* System.Int32[] */, _ lowerBounds: System_Int32_Array /* System.Int32[] */) throws -> System_Array /* System.Array */ {
		let elementTypeC = elementType.__handle
		let lengthsC = lengths.__handle
		let lowerBoundsC = lowerBounds.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_CreateInstance_4(elementTypeC, lengthsC, lowerBoundsC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createInstance(_ elementType: System_Type /* System.Type */, _ lengths: System_Int64_Array /* System.Int64[] */) throws -> System_Array /* System.Array */ {
		let elementTypeC = elementType.__handle
		let lengthsC = lengths.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_CreateInstance_5(elementTypeC, lengthsC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copy(_ sourceArray: System_Array /* System.Array */, _ destinationArray: System_Array /* System.Array */, _ length: Int64 /* System.Int64 */) throws {
		let sourceArrayC = sourceArray.__handle
		let destinationArrayC = destinationArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Copy(sourceArrayC, destinationArrayC, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ sourceArray: System_Array /* System.Array */, _ sourceIndex: Int64 /* System.Int64 */, _ destinationArray: System_Array /* System.Array */, _ destinationIndex: Int64 /* System.Int64 */, _ length: Int64 /* System.Int64 */) throws {
		let sourceArrayC = sourceArray.__handle
		let destinationArrayC = destinationArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Copy_1(sourceArrayC, sourceIndex, destinationArrayC, destinationIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ sourceArray: System_Array /* System.Array */, _ destinationArray: System_Array /* System.Array */, _ length: Int32 /* System.Int32 */) throws {
		let sourceArrayC = sourceArray.__handle
		let destinationArrayC = destinationArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Copy_2(sourceArrayC, destinationArrayC, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ sourceArray: System_Array /* System.Array */, _ sourceIndex: Int32 /* System.Int32 */, _ destinationArray: System_Array /* System.Array */, _ destinationIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let sourceArrayC = sourceArray.__handle
		let destinationArrayC = destinationArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Copy_3(sourceArrayC, sourceIndex, destinationArrayC, destinationIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getValue(_ indices: System_Int32_Array /* System.Int32[] */) throws -> System_Object? /* System.Object */ {
		let indicesC = indices.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue(self.__handle, indicesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_1(self.__handle, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ index1: Int32 /* System.Int32 */, _ index2: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_2(self.__handle, index1, index2, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ index1: Int32 /* System.Int32 */, _ index2: Int32 /* System.Int32 */, _ index3: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_3(self.__handle, index1, index2, index3, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ index: Int32 /* System.Int32 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue(self.__handle, valueC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ index1: Int32 /* System.Int32 */, _ index2: Int32 /* System.Int32 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_1(self.__handle, valueC, index1, index2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ index1: Int32 /* System.Int32 */, _ index2: Int32 /* System.Int32 */, _ index3: Int32 /* System.Int32 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_2(self.__handle, valueC, index1, index2, index3, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ indices: System_Int32_Array /* System.Int32[] */) throws {
		let valueC = value?.__handle
		let indicesC = indices.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_3(self.__handle, valueC, indicesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getValue(_ index: Int64 /* System.Int64 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_4(self.__handle, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ index1: Int64 /* System.Int64 */, _ index2: Int64 /* System.Int64 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_5(self.__handle, index1, index2, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ index1: Int64 /* System.Int64 */, _ index2: Int64 /* System.Int64 */, _ index3: Int64 /* System.Int64 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_6(self.__handle, index1, index2, index3, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ indices: System_Int64_Array /* System.Int64[] */) throws -> System_Object? /* System.Object */ {
		let indicesC = indices.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetValue_7(self.__handle, indicesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ index: Int64 /* System.Int64 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_4(self.__handle, valueC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ index1: Int64 /* System.Int64 */, _ index2: Int64 /* System.Int64 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_5(self.__handle, valueC, index1, index2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ index1: Int64 /* System.Int64 */, _ index2: Int64 /* System.Int64 */, _ index3: Int64 /* System.Int64 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_6(self.__handle, valueC, index1, index2, index3, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ value: System_Object? /* System.Object */, _ indices: System_Int64_Array /* System.Int64[] */) throws {
		let valueC = value?.__handle
		let indicesC = indices.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_SetValue_7(self.__handle, valueC, indicesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getLongLength(_ dimension: Int32 /* System.Int32 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetLongLength(self.__handle, dimension, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func binarySearch(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_BinarySearch(arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func binarySearch(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_BinarySearch_1(arrayC, index, length, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func binarySearch(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_BinarySearch_2(arrayC, valueC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func binarySearch(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_BinarySearch_3(arrayC, index, length, valueC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func binarySearch(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_BinarySearch_A1(TC, arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func binarySearch(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_BinarySearch_A1_1(TC, arrayC, index, length, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copyTo(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_CopyTo(self.__handle, arrayC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyTo(_ array: System_Array /* System.Array */, _ index: Int64 /* System.Int64 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_CopyTo_1(self.__handle, arrayC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func empty(T: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_Empty_A1(TC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fill(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Fill_A1(TC, arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func fill(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Fill_A1_1(TC, arrayC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func indexOf(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IndexOf(arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func indexOf(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IndexOf_1(arrayC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func indexOf(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IndexOf_2(arrayC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func indexOf(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IndexOf_A1(TC, arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func indexOf(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IndexOf_A1_1(TC, arrayC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func indexOf(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IndexOf_A1_2(TC, arrayC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lastIndexOf(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LastIndexOf(arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lastIndexOf(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LastIndexOf_1(arrayC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lastIndexOf(_ array: System_Array /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let arrayC = array.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LastIndexOf_2(arrayC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lastIndexOf(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LastIndexOf_A1(TC, arrayC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lastIndexOf(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LastIndexOf_A1_1(TC, arrayC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lastIndexOf(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let arrayC = array?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LastIndexOf_A1_2(TC, arrayC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverse(_ array: System_Array /* System.Array */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Reverse(arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func reverse(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Reverse_1(arrayC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func reverse(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Reverse_A1(TC, arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func reverse(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Reverse_A1_1(TC, arrayC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ array: System_Array /* System.Array */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort(arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ keys: System_Array /* System.Array */, _ items: System_Array? /* System.Array */) throws {
		let keysC = keys.__handle
		let itemsC = items?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_1(keysC, itemsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_2(arrayC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ keys: System_Array /* System.Array */, _ items: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let keysC = keys.__handle
		let itemsC = items?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_3(keysC, itemsC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ array: System_Array /* System.Array */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let arrayC = array.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_4(arrayC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ keys: System_Array /* System.Array */, _ items: System_Array? /* System.Array */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let keysC = keys.__handle
		let itemsC = items?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_5(keysC, itemsC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let arrayC = array.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_6(arrayC, index, length, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(_ keys: System_Array /* System.Array */, _ items: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let keysC = keys.__handle
		let itemsC = items?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_7(keysC, itemsC, index, length, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_A1(TC, arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ keys: System_Array? /* System.Array */, _ items: System_Array? /* System.Array */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keysC = keys?.__handle
		let itemsC = items?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_A2(TKeyC, TValueC, keysC, itemsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_A1_1(TC, arrayC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sort(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ keys: System_Array? /* System.Array */, _ items: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keysC = keys?.__handle
		let itemsC = items?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Array_Sort_A2_1(TKeyC, TValueC, keysC, itemsC, index, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getEnumerator() throws -> System_Collections_IEnumerator /* System.Collections.IEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var length: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var longLength: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_LongLength_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var rank: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_Rank_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var syncRoot: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_SyncRoot_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFixedSize: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IsFixedSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSynchronized: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_IsSynchronized_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var maxLength: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Array_MaxLength_Get(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Array_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Array_Destroy(self.__handle)
		
	}
	
	
}


public class System_ICloneable /* System.ICloneable */: DNObject {
	public override class var typeName: String { get {
		"ICloneable"
	}}

	public override class var fullTypeName: String { get {
		"System.ICloneable"
	}}

	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ICloneable_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ICloneable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ICloneable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IList /* System.Collections.IList */: DNObject {
	public override class var typeName: String { get {
		"IList"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IList"
	}}

	public func add(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IList_Add(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func contains(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IList_Contains(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func clear() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IList_Clear(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func indexOf(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IList_IndexOf(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IList_Insert(self.__handle, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func remove(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IList_Remove(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeAt(_ index: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IList_RemoveAt(self.__handle, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func item(_ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IList_Item_Get(self.__handle, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(_ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IList_Item_Set(self.__handle, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IList_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFixedSize: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IList_IsFixedSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IList_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IList_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_ICollection /* System.Collections.ICollection */: DNObject {
	public override class var typeName: String { get {
		"ICollection"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.ICollection"
	}}

	public func copyTo(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ICollection_CopyTo(self.__handle, arrayC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var count: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ICollection_Count_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var syncRoot: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ICollection_SyncRoot_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isSynchronized: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ICollection_IsSynchronized_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_ICollection_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_ICollection_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IEnumerable /* System.Collections.IEnumerable */: DNObject {
	public override class var typeName: String { get {
		"IEnumerable"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IEnumerable"
	}}

	public func getEnumerator() throws -> System_Collections_IEnumerator /* System.Collections.IEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IEnumerable_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IEnumerable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IEnumerable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IEnumerator /* System.Collections.IEnumerator */: DNObject {
	public override class var typeName: String { get {
		"IEnumerator"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IEnumerator"
	}}

	public func moveNext() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IEnumerator_MoveNext(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IEnumerator_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var current: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IEnumerator_Current_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IEnumerator_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IEnumerator_Destroy(self.__handle)
		
	}
	
	
}


public class System_Boolean /* System.Boolean */: System_ValueType {
	public override class var typeName: String { get {
		"Boolean"
	}}

	public override class var fullTypeName: String { get {
		"System.Boolean"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Boolean_TypeOf())
		
	}}
	
	
}


public class System_ValueType /* System.ValueType */: System_Object {
	public override class var typeName: String { get {
		"ValueType"
	}}

	public override class var fullTypeName: String { get {
		"System.ValueType"
	}}

	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ValueType_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ValueType_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ValueType_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ValueType_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ValueType_Destroy(self.__handle)
		
	}
	
	
}


public class System_Int32 /* System.Int32 */: System_ValueType {
	public override class var typeName: String { get {
		"Int32"
	}}

	public override class var fullTypeName: String { get {
		"System.Int32"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Int32_TypeOf())
		
	}}
	
	
}


public class System_IComparable /* System.IComparable */: DNObject {
	public override class var typeName: String { get {
		"IComparable"
	}}

	public override class var fullTypeName: String { get {
		"System.IComparable"
	}}

	public func compareTo(_ obj: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IComparable_CompareTo(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IComparable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IComparable_Destroy(self.__handle)
		
	}
	
	
}


public class System_IConvertible /* System.IConvertible */: DNObject {
	public override class var typeName: String { get {
		"IConvertible"
	}}

	public override class var fullTypeName: String { get {
		"System.IConvertible"
	}}

	public func getTypeCode() throws -> System_TypeCode /* System.TypeCode */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_GetTypeCode(self.__handle, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toBoolean(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Bool /* System.Boolean */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToBoolean(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toChar(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> DNChar /* System.Char */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToChar(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toSByte(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int8 /* System.SByte */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToSByte(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toByte(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt8 /* System.Byte */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToByte(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toInt16(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int16 /* System.Int16 */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToInt16(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUInt16(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt16 /* System.UInt16 */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToUInt16(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toInt32(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int32 /* System.Int32 */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToInt32(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUInt32(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt32 /* System.UInt32 */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToUInt32(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toInt64(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int64 /* System.Int64 */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToInt64(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUInt64(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt64 /* System.UInt64 */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToUInt64(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toSingle(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Float /* System.Single */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToSingle(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toDouble(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Double /* System.Double */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToDouble(self.__handle, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toDecimal(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToDecimal(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toDateTime(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTime /* System.DateTime */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToDateTime(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToString(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toType(_ conversionType: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Object /* System.Object */ {
		let conversionTypeC = conversionType.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IConvertible_ToType(self.__handle, conversionTypeC, providerC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IConvertible_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IConvertible_Destroy(self.__handle)
		
	}
	
	
}


public class System_Enum /* System.Enum */: System_ValueType {
	public override class var typeName: String { get {
		"Enum"
	}}

	public override class var fullTypeName: String { get {
		"System.Enum"
	}}

	public class func getName(TEnum: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_String? /* System.String */ {
		let TEnumC = TEnum.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetName_A1(TEnumC, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getName(_ enumType: System_Type /* System.Type */, _ value: System_Object /* System.Object */) throws -> System_String? /* System.String */ {
		let enumTypeC = enumType.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetName_1(enumTypeC, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getNames(TEnum: System_Type /* System.Type */) throws -> System_String_Array /* System.String[] */ {
		let TEnumC = TEnum.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetNames_A1(TEnumC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getNames(_ enumType: System_Type /* System.Type */) throws -> System_String_Array /* System.String[] */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetNames_1(enumTypeC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getUnderlyingType(_ enumType: System_Type /* System.Type */) throws -> System_Type /* System.Type */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetUnderlyingType(enumTypeC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getValues(TEnum: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let TEnumC = TEnum.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetValues_A1(TEnumC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getValues(_ enumType: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetValues_1(enumTypeC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getValuesAsUnderlyingType(TEnum: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let TEnumC = TEnum.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetValuesAsUnderlyingType_A1(TEnumC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getValuesAsUnderlyingType(_ enumType: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetValuesAsUnderlyingType_1(enumTypeC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func hasFlag(_ flag: System_Enum /* System.Enum */) throws -> Bool /* System.Boolean */ {
		let flagC = flag.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_HasFlag(self.__handle, flagC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDefined(TEnum: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TEnumC = TEnum.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_IsDefined_A1(TEnumC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDefined(_ enumType: System_Type /* System.Type */, _ value: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let enumTypeC = enumType.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_IsDefined_1(enumTypeC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ enumType: System_Type /* System.Type */, _ value: System_String /* System.String */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_Parse(enumTypeC, valueC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ enumType: System_Type /* System.Type */, _ value: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_Parse_1(enumTypeC, valueC, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(TEnum: System_Type /* System.Type */, _ value: System_String? /* System.String */) throws -> System_Object /* System.Object */ {
		let TEnumC = TEnum.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_Parse_A1(TEnumC, valueC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(TEnum: System_Type /* System.Type */, _ value: System_String? /* System.String */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Object /* System.Object */ {
		let TEnumC = TEnum.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_Parse_A1_1(TEnumC, valueC, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ enumType: System_Type /* System.Type */, _ value: System_String? /* System.String */, _ result: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let enumTypeC = enumType.__handle
		let valueC = value?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_TryParse(enumTypeC, valueC, &resultC, &__exceptionC)
		
		result = System_Object(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ enumType: System_Type /* System.Type */, _ value: System_String? /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ result: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let enumTypeC = enumType.__handle
		let valueC = value?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_TryParse_1(enumTypeC, valueC, ignoreCase, &resultC, &__exceptionC)
		
		result = System_Object(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(TEnum: System_Type /* System.Type */, _ value: System_String? /* System.String */, _ result: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TEnumC = TEnum.__handle
		let valueC = value?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_TryParse_A1(TEnumC, valueC, &resultC, &__exceptionC)
		
		result = System_Object(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(TEnum: System_Type /* System.Type */, _ value: System_String? /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ result: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TEnumC = TEnum.__handle
		let valueC = value?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_TryParse_A1_1(TEnumC, valueC, ignoreCase, &resultC, &__exceptionC)
		
		result = System_Object(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ target: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_CompareTo(self.__handle, targetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToString_2(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ enumType: System_Type /* System.Type */, _ value: System_Object /* System.Object */, _ format: System_String /* System.String */) throws -> System_String /* System.String */ {
		let enumTypeC = enumType.__handle
		let valueC = value.__handle
		let formatC = format.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_Format(enumTypeC, valueC, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTypeCode() throws -> System_TypeCode /* System.TypeCode */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_GetTypeCode(self.__handle, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: System_Object /* System.Object */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject(enumTypeC, valueC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: Int8 /* System.SByte */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_1(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: Int16 /* System.Int16 */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_2(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: Int32 /* System.Int32 */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_3(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: UInt8 /* System.Byte */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_4(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: UInt16 /* System.UInt16 */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_5(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: UInt32 /* System.UInt32 */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_6(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: Int64 /* System.Int64 */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_7(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toObject(_ enumType: System_Type /* System.Type */, _ value: UInt64 /* System.UInt64 */) throws -> System_Object /* System.Object */ {
		let enumTypeC = enumType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Enum_ToObject_8(enumTypeC, value, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Enum_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Enum_Destroy(self.__handle)
		
	}
	
	
}


public class System_ISpanFormattable /* System.ISpanFormattable */: DNObject {
	public override class var typeName: String { get {
		"ISpanFormattable"
	}}

	public override class var fullTypeName: String { get {
		"System.ISpanFormattable"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ISpanFormattable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ISpanFormattable_Destroy(self.__handle)
		
	}
	
	
}


public class System_IFormattable /* System.IFormattable */: DNObject {
	public override class var typeName: String { get {
		"IFormattable"
	}}

	public override class var fullTypeName: String { get {
		"System.IFormattable"
	}}

	public func toString(_ format: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IFormattable_ToString(self.__handle, formatC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IFormattable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IFormattable_Destroy(self.__handle)
		
	}
	
	
}


public class System_String /* System.String */: System_Object {
	public override class var typeName: String { get {
		"String"
	}}

	public override class var fullTypeName: String { get {
		"System.String"
	}}

	public class func intern(_ str: System_String /* System.String */) throws -> System_String /* System.String */ {
		let strC = str.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Intern(strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isInterned(_ str: System_String /* System.String */) throws -> System_String? /* System.String */ {
		let strC = str.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IsInterned(strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ strB: System_String? /* System.String */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare(strAC, strBC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ strB: System_String? /* System.String */, _ ignoreCase: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_1(strAC, strBC, ignoreCase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ strB: System_String? /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_2(strAC, strBC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ strB: System_String? /* System.String */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		let cultureC = culture?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_3(strAC, strBC, cultureC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ strB: System_String? /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_4(strAC, strBC, ignoreCase, cultureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ indexA: Int32 /* System.Int32 */, _ strB: System_String? /* System.String */, _ indexB: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_5(strAC, indexA, strBC, indexB, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ indexA: Int32 /* System.Int32 */, _ strB: System_String? /* System.String */, _ indexB: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ ignoreCase: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_6(strAC, indexA, strBC, indexB, length, ignoreCase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ indexA: Int32 /* System.Int32 */, _ strB: System_String? /* System.String */, _ indexB: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ ignoreCase: Bool /* System.Boolean */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_7(strAC, indexA, strBC, indexB, length, ignoreCase, cultureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ indexA: Int32 /* System.Int32 */, _ strB: System_String? /* System.String */, _ indexB: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		let cultureC = culture?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_8(strAC, indexA, strBC, indexB, length, cultureC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compare(_ strA: System_String? /* System.String */, _ indexA: Int32 /* System.Int32 */, _ strB: System_String? /* System.String */, _ indexB: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Compare_9(strAC, indexA, strBC, indexB, length, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compareOrdinal(_ strA: System_String? /* System.String */, _ strB: System_String? /* System.String */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_CompareOrdinal(strAC, strBC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func compareOrdinal(_ strA: System_String? /* System.String */, _ indexA: Int32 /* System.Int32 */, _ strB: System_String? /* System.String */, _ indexB: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let strAC = strA?.__handle
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_CompareOrdinal_1(strAC, indexA, strBC, indexB, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ strB: System_String? /* System.String */) throws -> Int32 /* System.Int32 */ {
		let strBC = strB?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_CompareTo_1(self.__handle, strBC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func endsWith(_ value: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_EndsWith(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func endsWith(_ value: System_String /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_EndsWith_1(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func endsWith(_ value: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_EndsWith_2(self.__handle, valueC, ignoreCase, cultureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func endsWith(_ value: DNChar /* System.Char */) throws -> Bool /* System.Boolean */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_EndsWith_3(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ value: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Equals_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ value: System_String? /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Equals_2(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ a: System_String? /* System.String */, _ b: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let aC = a?.__handle
		let bC = b?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Equals_3(aC, bC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ a: System_String? /* System.String */, _ b: System_String? /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Bool /* System.Boolean */ {
		let aC = a?.__handle
		let bC = b?.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Equals_4(aC, bC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(_ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_GetHashCode_1(self.__handle, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func startsWith(_ value: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_StartsWith(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func startsWith(_ value: System_String /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_StartsWith_1(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func startsWith(_ value: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_StartsWith_2(self.__handle, valueC, ignoreCase, cultureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func startsWith(_ value: DNChar /* System.Char */) throws -> Bool /* System.Boolean */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_StartsWith_3(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copy(_ str: System_String /* System.String */) throws -> System_String /* System.String */ {
		let strC = str.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Copy(strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyTo(_ sourceIndex: Int32 /* System.Int32 */, _ destination: System_Char_Array /* System.Char[] */, _ destinationIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_String_CopyTo(self.__handle, sourceIndex, destinationC, destinationIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func toCharArray() throws -> System_Char_Array /* System.Char[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToCharArray(self.__handle, &__exceptionC)
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toCharArray(_ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_Char_Array /* System.Char[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToCharArray_1(self.__handle, startIndex, length, &__exceptionC)
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isNullOrEmpty(_ value: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IsNullOrEmpty(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNullOrWhiteSpace(_ value: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IsNullOrWhiteSpace(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToString_1(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEnumerator() throws -> System_CharEnumerator /* System.CharEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_CharEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateRunes() throws -> System_Text_StringRuneEnumerator /* System.Text.StringRuneEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_EnumerateRunes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_StringRuneEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTypeCode() throws -> System_TypeCode /* System.TypeCode */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_GetTypeCode(self.__handle, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isNormalized() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IsNormalized(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isNormalized(_ normalizationForm: System_Text_NormalizationForm /* System.Text.NormalizationForm */) throws -> Bool /* System.Boolean */ {
		let normalizationFormC = normalizationForm.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IsNormalized_1(self.__handle, normalizationFormC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func normalize() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Normalize(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func normalize(_ normalizationForm: System_Text_NormalizationForm /* System.Text.NormalizationForm */) throws -> System_String /* System.String */ {
		let normalizationFormC = normalizationForm.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Normalize_1(self.__handle, normalizationFormC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ arg0: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat(arg0C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_1(arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_2(arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ args: System_Object_Array /* System.Object[] */) throws -> System_String /* System.String */ {
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_3(argsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ values: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */) throws -> System_String /* System.String */ {
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_4(valuesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ str0: System_String? /* System.String */, _ str1: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let str0C = str0?.__handle
		let str1C = str1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_5(str0C, str1C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ str0: System_String? /* System.String */, _ str1: System_String? /* System.String */, _ str2: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let str0C = str0?.__handle
		let str1C = str1?.__handle
		let str2C = str2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_6(str0C, str1C, str2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ str0: System_String? /* System.String */, _ str1: System_String? /* System.String */, _ str2: System_String? /* System.String */, _ str3: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let str0C = str0?.__handle
		let str1C = str1?.__handle
		let str2C = str2?.__handle
		let str3C = str3?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_7(str0C, str1C, str2C, str3C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func concat(_ values: System_String_Array /* System.String[] */) throws -> System_String /* System.String */ {
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Concat_8(valuesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format(formatC, arg0C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_1(formatC, arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_2(formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ format: System_String /* System.String */, _ args: System_Object_Array /* System.Object[] */) throws -> System_String /* System.String */ {
		let formatC = format.__handle
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_3(formatC, argsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_4(providerC, formatC, arg0C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_5(providerC, formatC, arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_6(providerC, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ args: System_Object_Array /* System.Object[] */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_7(providerC, formatC, argsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(TArg0: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat? /* System.Text.CompositeFormat */, _ arg0: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let TArg0C = TArg0.__handle
		let providerC = provider?.__handle
		let formatC = format?.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_A1(TArg0C, providerC, formatC, arg0C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(TArg0: System_Type /* System.Type */, TArg1: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat? /* System.Text.CompositeFormat */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let TArg0C = TArg0.__handle
		let TArg1C = TArg1.__handle
		let providerC = provider?.__handle
		let formatC = format?.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_A2(TArg0C, TArg1C, providerC, formatC, arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(TArg0: System_Type /* System.Type */, TArg1: System_Type /* System.Type */, TArg2: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat? /* System.Text.CompositeFormat */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_String /* System.String */ {
		let TArg0C = TArg0.__handle
		let TArg1C = TArg1.__handle
		let TArg2C = TArg2.__handle
		let providerC = provider?.__handle
		let formatC = format?.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_A3(TArg0C, TArg1C, TArg2C, providerC, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func format(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat /* System.Text.CompositeFormat */, _ args: System_Object_Array /* System.Object[] */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Format_8(providerC, formatC, argsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ startIndex: Int32 /* System.Int32 */, _ value: System_String /* System.String */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Insert(self.__handle, startIndex, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: DNChar /* System.Char */, _ value: System_String_Array /* System.String[] */) throws -> System_String /* System.String */ {
		let separatorC = separator.cValue
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join(separatorC, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: System_String? /* System.String */, _ value: System_String_Array /* System.String[] */) throws -> System_String /* System.String */ {
		let separatorC = separator?.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join_1(separatorC, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: DNChar /* System.Char */, _ value: System_String_Array /* System.String[] */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		let separatorC = separator.cValue
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join_2(separatorC, valueC, startIndex, count, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: System_String? /* System.String */, _ value: System_String_Array /* System.String[] */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		let separatorC = separator?.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join_3(separatorC, valueC, startIndex, count, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: System_String? /* System.String */, _ values: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */) throws -> System_String /* System.String */ {
		let separatorC = separator?.__handle
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join_4(separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: DNChar /* System.Char */, _ values: System_Object_Array /* System.Object[] */) throws -> System_String /* System.String */ {
		let separatorC = separator.cValue
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join_5(separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ separator: System_String? /* System.String */, _ values: System_Object_Array /* System.Object[] */) throws -> System_String /* System.String */ {
		let separatorC = separator?.__handle
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Join_6(separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func padLeft(_ totalWidth: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_PadLeft(self.__handle, totalWidth, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func padLeft(_ totalWidth: Int32 /* System.Int32 */, _ paddingChar: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let paddingCharC = paddingChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_PadLeft_1(self.__handle, totalWidth, paddingCharC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func padRight(_ totalWidth: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_PadRight(self.__handle, totalWidth, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func padRight(_ totalWidth: Int32 /* System.Int32 */, _ paddingChar: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let paddingCharC = paddingChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_PadRight_1(self.__handle, totalWidth, paddingCharC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func remove(_ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Remove(self.__handle, startIndex, count, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func remove(_ startIndex: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Remove_1(self.__handle, startIndex, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldValue: System_String /* System.String */, _ newValue: System_String? /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_String /* System.String */ {
		let oldValueC = oldValue.__handle
		let newValueC = newValue?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Replace(self.__handle, oldValueC, newValueC, ignoreCase, cultureC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldValue: System_String /* System.String */, _ newValue: System_String? /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> System_String /* System.String */ {
		let oldValueC = oldValue.__handle
		let newValueC = newValue?.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Replace_1(self.__handle, oldValueC, newValueC, comparisonTypeC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldChar: DNChar /* System.Char */, _ newChar: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let oldCharC = oldChar.cValue
		let newCharC = newChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Replace_2(self.__handle, oldCharC, newCharC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldValue: System_String /* System.String */, _ newValue: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let oldValueC = oldValue.__handle
		let newValueC = newValue?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Replace_3(self.__handle, oldValueC, newValueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replaceLineEndings() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ReplaceLineEndings(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replaceLineEndings(_ replacementText: System_String /* System.String */) throws -> System_String /* System.String */ {
		let replacementTextC = replacementText.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ReplaceLineEndings_1(self.__handle, replacementTextC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: DNChar /* System.Char */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split(self.__handle, separatorC, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: DNChar /* System.Char */, _ count: Int32 /* System.Int32 */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_1(self.__handle, separatorC, count, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_Char_Array? /* System.Char[] */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_2(self.__handle, separatorC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_Char_Array? /* System.Char[] */, _ count: Int32 /* System.Int32 */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_3(self.__handle, separatorC, count, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_Char_Array? /* System.Char[] */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_4(self.__handle, separatorC, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_Char_Array? /* System.Char[] */, _ count: Int32 /* System.Int32 */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_5(self.__handle, separatorC, count, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_String? /* System.String */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_6(self.__handle, separatorC, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_String? /* System.String */, _ count: Int32 /* System.Int32 */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_7(self.__handle, separatorC, count, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_String_Array? /* System.String[] */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_8(self.__handle, separatorC, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func split(_ separator: System_String_Array? /* System.String[] */, _ count: Int32 /* System.Int32 */, _ options: System_StringSplitOptions /* System.StringSplitOptions */) throws -> System_String_Array /* System.String[] */ {
		let separatorC = separator?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Split_9(self.__handle, separatorC, count, optionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func substring(_ startIndex: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Substring(self.__handle, startIndex, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func substring(_ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Substring_1(self.__handle, startIndex, length, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLower() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToLower(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLower(_ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_String /* System.String */ {
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToLower_1(self.__handle, cultureC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLowerInvariant() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToLowerInvariant(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUpper() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToUpper(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUpper(_ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_String /* System.String */ {
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToUpper_1(self.__handle, cultureC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUpperInvariant() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_ToUpperInvariant(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trim() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Trim(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trim(_ trimChar: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let trimCharC = trimChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Trim_1(self.__handle, trimCharC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trim(_ trimChars: System_Char_Array? /* System.Char[] */) throws -> System_String /* System.String */ {
		let trimCharsC = trimChars?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Trim_2(self.__handle, trimCharsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimStart() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_TrimStart(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimStart(_ trimChar: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let trimCharC = trimChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_TrimStart_1(self.__handle, trimCharC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimStart(_ trimChars: System_Char_Array? /* System.Char[] */) throws -> System_String /* System.String */ {
		let trimCharsC = trimChars?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_TrimStart_2(self.__handle, trimCharsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimEnd() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_TrimEnd(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimEnd(_ trimChar: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let trimCharC = trimChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_TrimEnd_1(self.__handle, trimCharC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimEnd(_ trimChars: System_Char_Array? /* System.Char[] */) throws -> System_String /* System.String */ {
		let trimCharsC = trimChars?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_TrimEnd_2(self.__handle, trimCharsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func contains(_ value: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Contains(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func contains(_ value: System_String /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Contains_1(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func contains(_ value: DNChar /* System.Char */) throws -> Bool /* System.Boolean */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Contains_2(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func contains(_ value: DNChar /* System.Char */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Bool /* System.Boolean */ {
		let valueC = value.cValue
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Contains_3(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: DNChar /* System.Char */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_1(self.__handle, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: DNChar /* System.Char */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_2(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_3(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOfAny(_ anyOf: System_Char_Array /* System.Char[] */) throws -> Int32 /* System.Int32 */ {
		let anyOfC = anyOf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOfAny(self.__handle, anyOfC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOfAny(_ anyOf: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let anyOfC = anyOf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOfAny_1(self.__handle, anyOfC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOfAny(_ anyOf: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let anyOfC = anyOf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOfAny_2(self.__handle, anyOfC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_4(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_5(self.__handle, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_6(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_String /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_7(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_8(self.__handle, valueC, startIndex, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_IndexOf_9(self.__handle, valueC, startIndex, count, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: DNChar /* System.Char */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_1(self.__handle, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_2(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOfAny(_ anyOf: System_Char_Array /* System.Char[] */) throws -> Int32 /* System.Int32 */ {
		let anyOfC = anyOf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOfAny(self.__handle, anyOfC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOfAny(_ anyOf: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let anyOfC = anyOf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOfAny_1(self.__handle, anyOfC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOfAny(_ anyOf: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let anyOfC = anyOf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOfAny_2(self.__handle, anyOfC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_3(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_4(self.__handle, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_5(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_String /* System.String */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_6(self.__handle, valueC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_7(self.__handle, valueC, startIndex, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_LastIndexOf_8(self.__handle, valueC, startIndex, count, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ value: System_Char_Array? /* System.Char[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Create(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Create_1(valueC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ c: DNChar /* System.Char */, _ count: Int32 /* System.Int32 */) throws {
		let cC = c.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Create_2(cC, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func chars(_ index: Int32 /* System.Int32 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Chars_Get(self.__handle, index, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public var length: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_String_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var empty: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_String_Empty_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_String_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_String_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<> */: DNObject {
	public override class var typeName: String { get {
		"IEnumerable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IEnumerable<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IEnumerable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IEnumerable_A1_Destroy(self.__handle)
		
	}
	
	
}




public class System_Collections_Generic_IEnumerator_A1 /* System.Collections.Generic.IEnumerator<> */: DNObject {
	public override class var typeName: String { get {
		"IEnumerator`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IEnumerator<>"
	}}

	public func current(T: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IEnumerator_A1_Current_Get(self.__handle, TC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IEnumerator_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IEnumerator_A1_Destroy(self.__handle)
		
	}
	
	
}


public class System_IDisposable /* System.IDisposable */: DNObject {
	public override class var typeName: String { get {
		"IDisposable"
	}}

	public override class var fullTypeName: String { get {
		"System.IDisposable"
	}}

	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IDisposable_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IDisposable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IDisposable_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


public class System_Char /* System.Char */: System_ValueType {
	public override class var typeName: String { get {
		"Char"
	}}

	public override class var fullTypeName: String { get {
		"System.Char"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Char_TypeOf())
		
	}}
	
	
}


public class System_IComparable_A1 /* System.IComparable<> */: DNObject {
	public override class var typeName: String { get {
		"IComparable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.IComparable<>"
	}}

	public func compareTo(T: System_Type /* System.Type */, _ other: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IComparable_A1_CompareTo(self.__handle, TC, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IComparable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IComparable_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


public class System_IEquatable_A1 /* System.IEquatable<> */: DNObject {
	public override class var typeName: String { get {
		"IEquatable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.IEquatable<>"
	}}

	public func equals(T: System_Type /* System.Type */, _ other: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IEquatable_A1_Equals(self.__handle, TC, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IEquatable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IEquatable_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


public class System_Numerics_IBinaryNumber_A1 /* System.Numerics.IBinaryNumber<> */: DNObject {
	public override class var typeName: String { get {
		"IBinaryNumber`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IBinaryNumber<>"
	}}

	public class func isPow2(TSelf: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TSelfC = TSelf.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IBinaryNumber_A1_IsPow2(TSelfC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log2(TSelf: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IBinaryNumber_A1_Log2(TSelfC, valueC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func allBitsSet(TSelf: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IBinaryNumber_A1_AllBitsSet_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IBinaryNumber_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IBinaryNumber_A1_Destroy(self.__handle)
		
	}
	
	
}


public class System_IUtf8SpanFormattable /* System.IUtf8SpanFormattable */: DNObject {
	public override class var typeName: String { get {
		"IUtf8SpanFormattable"
	}}

	public override class var fullTypeName: String { get {
		"System.IUtf8SpanFormattable"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IUtf8SpanFormattable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IUtf8SpanFormattable_Destroy(self.__handle)
		
	}
	
	
}



public class System_IFormatProvider /* System.IFormatProvider */: DNObject {
	public override class var typeName: String { get {
		"IFormatProvider"
	}}

	public override class var fullTypeName: String { get {
		"System.IFormatProvider"
	}}

	public func getFormat(_ formatType: System_Type? /* System.Type */) throws -> System_Object? /* System.Object */ {
		let formatTypeC = formatType?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IFormatProvider_GetFormat(self.__handle, formatTypeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IFormatProvider_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IFormatProvider_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IBitwiseOperators_A3 /* System.Numerics.IBitwiseOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IBitwiseOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IBitwiseOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IBitwiseOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IBitwiseOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_INumber_A1 /* System.Numerics.INumber<> */: DNObject {
	public override class var typeName: String { get {
		"INumber`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.INumber<>"
	}}

	public class func clamp(TSelf: System_Type /* System.Type */, _ value: System_Object? /* System.Object */, _ min: System_Object? /* System.Object */, _ max: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let valueC = value?.__handle
		let minC = min?.__handle
		let maxC = max?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_Clamp(TSelfC, valueC, minC, maxC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copySign(TSelf: System_Type /* System.Type */, _ value: System_Object? /* System.Object */, _ sign: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let valueC = value?.__handle
		let signC = sign?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_CopySign(TSelfC, valueC, signC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func max(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_Max(TSelfC, xC, yC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func maxNumber(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_MaxNumber(TSelfC, xC, yC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func min(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_Min(TSelfC, xC, yC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func minNumber(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_MinNumber(TSelfC, xC, yC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sign(TSelf: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_INumber_A1_Sign(TSelfC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_INumber_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_INumber_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IComparisonOperators_A3 /* System.Numerics.IComparisonOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IComparisonOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IComparisonOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IComparisonOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IComparisonOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IEqualityOperators_A3 /* System.Numerics.IEqualityOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IEqualityOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IEqualityOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IEqualityOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IEqualityOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IModulusOperators_A3 /* System.Numerics.IModulusOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IModulusOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IModulusOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IModulusOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IModulusOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IAdditionOperators_A3 /* System.Numerics.IAdditionOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IAdditionOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IAdditionOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IAdditionOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IAdditionOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IAdditiveIdentity_A2 /* System.Numerics.IAdditiveIdentity<,> */: DNObject {
	public override class var typeName: String { get {
		"IAdditiveIdentity`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IAdditiveIdentity<,>"
	}}

	public class func additiveIdentity(TSelf: System_Type /* System.Type */, TResult: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IAdditiveIdentity_A2_AdditiveIdentity_Get(TSelfC, TResultC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IAdditiveIdentity_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IAdditiveIdentity_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.


public class System_Numerics_IDecrementOperators_A1 /* System.Numerics.IDecrementOperators<> */: DNObject {
	public override class var typeName: String { get {
		"IDecrementOperators`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IDecrementOperators<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IDecrementOperators_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IDecrementOperators_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IDivisionOperators_A3 /* System.Numerics.IDivisionOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IDivisionOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IDivisionOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IDivisionOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IDivisionOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IIncrementOperators_A1 /* System.Numerics.IIncrementOperators<> */: DNObject {
	public override class var typeName: String { get {
		"IIncrementOperators`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IIncrementOperators<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IIncrementOperators_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IIncrementOperators_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IMultiplicativeIdentity_A2 /* System.Numerics.IMultiplicativeIdentity<,> */: DNObject {
	public override class var typeName: String { get {
		"IMultiplicativeIdentity`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IMultiplicativeIdentity<,>"
	}}

	public class func multiplicativeIdentity(TSelf: System_Type /* System.Type */, TResult: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IMultiplicativeIdentity_A2_MultiplicativeIdentity_Get(TSelfC, TResultC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IMultiplicativeIdentity_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IMultiplicativeIdentity_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.


public class System_Numerics_IMultiplyOperators_A3 /* System.Numerics.IMultiplyOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IMultiplyOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IMultiplyOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IMultiplyOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IMultiplyOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_ISpanParsable_A1 /* System.ISpanParsable<> */: DNObject {
	public override class var typeName: String { get {
		"ISpanParsable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.ISpanParsable<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ISpanParsable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ISpanParsable_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.



public class System_IParsable_A1 /* System.IParsable<> */: DNObject {
	public override class var typeName: String { get {
		"IParsable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.IParsable<>"
	}}

	public class func parse(TSelf: System_Type /* System.Type */, _ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let sC = s?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IParsable_A1_Parse(TSelfC, sC, providerC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(TSelf: System_Type /* System.Type */, _ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TSelfC = TSelf.__handle
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IParsable_A1_TryParse(TSelfC, sC, providerC, &resultC, &__exceptionC)
		
		result = System_Object(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IParsable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IParsable_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.



public class System_Numerics_ISubtractionOperators_A3 /* System.Numerics.ISubtractionOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"ISubtractionOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.ISubtractionOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_ISubtractionOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_ISubtractionOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IUnaryPlusOperators_A2 /* System.Numerics.IUnaryPlusOperators<,> */: DNObject {
	public override class var typeName: String { get {
		"IUnaryPlusOperators`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IUnaryPlusOperators<,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IUnaryPlusOperators_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IUnaryPlusOperators_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IUnaryNegationOperators_A2 /* System.Numerics.IUnaryNegationOperators<,> */: DNObject {
	public override class var typeName: String { get {
		"IUnaryNegationOperators`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IUnaryNegationOperators<,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IUnaryNegationOperators_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IUnaryNegationOperators_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IShiftOperators_A3 /* System.Numerics.IShiftOperators<,,> */: DNObject {
	public override class var typeName: String { get {
		"IShiftOperators`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IShiftOperators<,,>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IShiftOperators_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IShiftOperators_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TSelf" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.


public class System_Numerics_IMinMaxValue_A1 /* System.Numerics.IMinMaxValue<> */: DNObject {
	public override class var typeName: String { get {
		"IMinMaxValue`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IMinMaxValue<>"
	}}

	public class func minValue(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IMinMaxValue_A1_MinValue_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func maxValue(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IMinMaxValue_A1_MaxValue_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IMinMaxValue_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IMinMaxValue_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IUnsignedNumber_A1 /* System.Numerics.IUnsignedNumber<> */: DNObject {
	public override class var typeName: String { get {
		"IUnsignedNumber`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IUnsignedNumber<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IUnsignedNumber_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IUnsignedNumber_A1_Destroy(self.__handle)
		
	}
	
	
}




public class System_Globalization_CultureInfo /* System.Globalization.CultureInfo */: System_Object {
	public override class var typeName: String { get {
		"CultureInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.CultureInfo"
	}}

	public class func createSpecificCulture(_ name: System_String /* System.String */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_CreateSpecificCulture(nameC, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCultures(_ types: System_Globalization_CultureTypes /* System.Globalization.CultureTypes */) throws -> System_Globalization_CultureInfo_Array /* System.Globalization.CultureInfo[] */ {
		let typesC = types.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetCultures(typesC, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFormat(_ formatType: System_Type? /* System.Type */) throws -> System_Object? /* System.Object */ {
		let formatTypeC = formatType?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetFormat(self.__handle, formatTypeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func clearCachedData() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_ClearCachedData(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getConsoleFallbackUICulture() throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetConsoleFallbackUICulture(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readOnly(_ ci: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		let ciC = ci.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_ReadOnly(ciC, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCultureInfo(_ culture: Int32 /* System.Int32 */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetCultureInfo(culture, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCultureInfo(_ name: System_String /* System.String */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetCultureInfo_1(nameC, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCultureInfo(_ name: System_String /* System.String */, _ altName: System_String /* System.String */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		let nameC = name.__handle
		let altNameC = altName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetCultureInfo_2(nameC, altNameC, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCultureInfo(_ name: System_String /* System.String */, _ predefinedOnly: Bool /* System.Boolean */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetCultureInfo_3(nameC, predefinedOnly, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCultureInfoByIetfLanguageTag(_ name: System_String /* System.String */) throws -> System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_GetCultureInfoByIetfLanguageTag(nameC, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ name: System_String /* System.String */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Create_1(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ name: System_String /* System.String */, _ useUserOverride: Bool /* System.Boolean */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Create_2(nameC, useUserOverride, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ culture: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Create_3(culture, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ culture: Int32 /* System.Int32 */, _ useUserOverride: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Create_4(culture, useUserOverride, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var currentCulture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_CurrentCulture_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public class func currentCulture_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_CurrentCulture_Set(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var currentUICulture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_CurrentUICulture_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public class func currentUICulture_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_CurrentUICulture_Set(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var installedUICulture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_InstalledUICulture_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var defaultThreadCurrentCulture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_DefaultThreadCurrentCulture_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public class func defaultThreadCurrentCulture_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_DefaultThreadCurrentCulture_Set(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var defaultThreadCurrentUICulture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_DefaultThreadCurrentUICulture_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public class func defaultThreadCurrentUICulture_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_DefaultThreadCurrentUICulture_Set(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var invariantCulture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_InvariantCulture_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var parent: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Parent_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var lCID: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_LCID_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var keyboardLayoutId: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_KeyboardLayoutId_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var ietfLanguageTag: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_IetfLanguageTag_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var displayName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_DisplayName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var nativeName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_NativeName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var englishName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_EnglishName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var twoLetterISOLanguageName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_TwoLetterISOLanguageName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var threeLetterISOLanguageName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_ThreeLetterISOLanguageName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var threeLetterWindowsLanguageName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_ThreeLetterWindowsLanguageName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var compareInfo: System_Globalization_CompareInfo /* System.Globalization.CompareInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_CompareInfo_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CompareInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var textInfo: System_Globalization_TextInfo /* System.Globalization.TextInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_TextInfo_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_TextInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isNeutralCulture: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_IsNeutralCulture_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var cultureTypes: System_Globalization_CultureTypes /* System.Globalization.CultureTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_CultureTypes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var numberFormat: System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_NumberFormat_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_NumberFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func numberFormat_set(_ value: System_Globalization_NumberFormatInfo? /* System.Globalization.NumberFormatInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_NumberFormat_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var dateTimeFormat: System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_DateTimeFormat_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_DateTimeFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func dateTimeFormat_set(_ value: System_Globalization_DateTimeFormatInfo? /* System.Globalization.DateTimeFormatInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_CultureInfo_DateTimeFormat_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var calendar: System_Globalization_Calendar /* System.Globalization.Calendar */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_Calendar_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_Calendar(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var optionalCalendars: System_Globalization_Calendar_Array /* System.Globalization.Calendar[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_OptionalCalendars_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_Calendar_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var useUserOverride: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_UseUserOverride_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CultureInfo_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_CultureInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_CultureInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Globalization_CultureInfo_Array /* System.Globalization.CultureInfo[] */: System_Array {
	public override class var typeName: String { get {
		"CultureInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.CultureInfo[]"
	}}

	
}


public class System_Collections_IStructuralComparable /* System.Collections.IStructuralComparable */: DNObject {
	public override class var typeName: String { get {
		"IStructuralComparable"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IStructuralComparable"
	}}

	public func compareTo(_ other: System_Object? /* System.Object */, _ comparer: System_Collections_IComparer /* System.Collections.IComparer */) throws -> Int32 /* System.Int32 */ {
		let otherC = other?.__handle
		let comparerC = comparer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IStructuralComparable_CompareTo(self.__handle, otherC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IStructuralComparable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IStructuralComparable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IComparer /* System.Collections.IComparer */: DNObject {
	public override class var typeName: String { get {
		"IComparer"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IComparer"
	}}

	public func compare(_ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IComparer_Compare(self.__handle, xC, yC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IComparer_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IComparer_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IStructuralEquatable /* System.Collections.IStructuralEquatable */: DNObject {
	public override class var typeName: String { get {
		"IStructuralEquatable"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IStructuralEquatable"
	}}

	public func equals(_ other: System_Object? /* System.Object */, _ comparer: System_Collections_IEqualityComparer /* System.Collections.IEqualityComparer */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		let comparerC = comparer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IStructuralEquatable_Equals(self.__handle, otherC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(_ comparer: System_Collections_IEqualityComparer /* System.Collections.IEqualityComparer */) throws -> Int32 /* System.Int32 */ {
		let comparerC = comparer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IStructuralEquatable_GetHashCode(self.__handle, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IStructuralEquatable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IStructuralEquatable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IEqualityComparer /* System.Collections.IEqualityComparer */: DNObject {
	public override class var typeName: String { get {
		"IEqualityComparer"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IEqualityComparer"
	}}

	public func equals(_ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IEqualityComparer_Equals(self.__handle, xC, yC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(_ obj: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IEqualityComparer_GetHashCode(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IEqualityComparer_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IEqualityComparer_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<> */: DNObject {
	public override class var typeName: String { get {
		"IList`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IList<>"
	}}

	public func indexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IList_A1_IndexOf(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func insert(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ item: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_IList_A1_Insert(self.__handle, TC, index, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeAt(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_IList_A1_RemoveAt(self.__handle, TC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func item(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IList_A1_Item_Get(self.__handle, TC, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_IList_A1_Item_Set(self.__handle, TC, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IList_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IList_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


public class System_Collections_Generic_ICollection_A1 /* System.Collections.Generic.ICollection<> */: DNObject {
	public override class var typeName: String { get {
		"ICollection`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.ICollection<>"
	}}

	public func add(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_ICollection_A1_Add(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clear(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_ICollection_A1_Clear(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func contains(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_ICollection_A1_Contains(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copyTo(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ arrayIndex: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_ICollection_A1_CopyTo(self.__handle, TC, arrayC, arrayIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func remove(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_ICollection_A1_Remove(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func count(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_ICollection_A1_Count_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public func isReadOnly(T: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_ICollection_A1_IsReadOnly_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_ICollection_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_ICollection_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.







public class System_Collections_Generic_IReadOnlyList_A1 /* System.Collections.Generic.IReadOnlyList<> */: DNObject {
	public override class var typeName: String { get {
		"IReadOnlyList`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IReadOnlyList<>"
	}}

	public func item(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IReadOnlyList_A1_Item_Get(self.__handle, TC, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IReadOnlyList_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IReadOnlyList_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


public class System_Collections_Generic_IReadOnlyCollection_A1 /* System.Collections.Generic.IReadOnlyCollection<> */: DNObject {
	public override class var typeName: String { get {
		"IReadOnlyCollection`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IReadOnlyCollection<>"
	}}

	public func count(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IReadOnlyCollection_A1_Count_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IReadOnlyCollection_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IReadOnlyCollection_A1_Destroy(self.__handle)
		
	}
	
	
}





public class System_Globalization_CompareInfo /* System.Globalization.CompareInfo */: System_Object {
	public override class var typeName: String { get {
		"CompareInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.CompareInfo"
	}}

	public class func getCompareInfo(_ culture: Int32 /* System.Int32 */, _ assembly: System_Reflection_Assembly /* System.Reflection.Assembly */) throws -> System_Globalization_CompareInfo /* System.Globalization.CompareInfo */ {
		let assemblyC = assembly.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetCompareInfo(culture, assemblyC, &__exceptionC)
		
		let __returnValue = System_Globalization_CompareInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCompareInfo(_ name: System_String /* System.String */, _ assembly: System_Reflection_Assembly /* System.Reflection.Assembly */) throws -> System_Globalization_CompareInfo /* System.Globalization.CompareInfo */ {
		let nameC = name.__handle
		let assemblyC = assembly.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetCompareInfo_1(nameC, assemblyC, &__exceptionC)
		
		let __returnValue = System_Globalization_CompareInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCompareInfo(_ culture: Int32 /* System.Int32 */) throws -> System_Globalization_CompareInfo /* System.Globalization.CompareInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetCompareInfo_2(culture, &__exceptionC)
		
		let __returnValue = System_Globalization_CompareInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCompareInfo(_ name: System_String /* System.String */) throws -> System_Globalization_CompareInfo /* System.Globalization.CompareInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetCompareInfo_3(nameC, &__exceptionC)
		
		let __returnValue = System_Globalization_CompareInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isSortable(_ ch: DNChar /* System.Char */) throws -> Bool /* System.Boolean */ {
		let chC = ch.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsSortable(chC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isSortable(_ text: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let textC = text.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsSortable_1(textC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isSortable(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsSortable_2(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compare(_ string1: System_String? /* System.String */, _ string2: System_String? /* System.String */) throws -> Int32 /* System.Int32 */ {
		let string1C = string1?.__handle
		let string2C = string2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Compare(self.__handle, string1C, string2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compare(_ string1: System_String? /* System.String */, _ string2: System_String? /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let string1C = string1?.__handle
		let string2C = string2?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Compare_1(self.__handle, string1C, string2C, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compare(_ string1: System_String? /* System.String */, _ offset1: Int32 /* System.Int32 */, _ length1: Int32 /* System.Int32 */, _ string2: System_String? /* System.String */, _ offset2: Int32 /* System.Int32 */, _ length2: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let string1C = string1?.__handle
		let string2C = string2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Compare_2(self.__handle, string1C, offset1, length1, string2C, offset2, length2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compare(_ string1: System_String? /* System.String */, _ offset1: Int32 /* System.Int32 */, _ string2: System_String? /* System.String */, _ offset2: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let string1C = string1?.__handle
		let string2C = string2?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Compare_3(self.__handle, string1C, offset1, string2C, offset2, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compare(_ string1: System_String? /* System.String */, _ offset1: Int32 /* System.Int32 */, _ string2: System_String? /* System.String */, _ offset2: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let string1C = string1?.__handle
		let string2C = string2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Compare_4(self.__handle, string1C, offset1, string2C, offset2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compare(_ string1: System_String? /* System.String */, _ offset1: Int32 /* System.Int32 */, _ length1: Int32 /* System.Int32 */, _ string2: System_String? /* System.String */, _ offset2: Int32 /* System.Int32 */, _ length2: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let string1C = string1?.__handle
		let string2C = string2?.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Compare_5(self.__handle, string1C, offset1, length1, string2C, offset2, length2, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isPrefix(_ source: System_String /* System.String */, _ prefix: System_String /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.__handle
		let prefixC = prefix.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsPrefix(self.__handle, sourceC, prefixC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isPrefix(_ source: System_String /* System.String */, _ prefix: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.__handle
		let prefixC = prefix.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsPrefix_1(self.__handle, sourceC, prefixC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isSuffix(_ source: System_String /* System.String */, _ suffix: System_String /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.__handle
		let suffixC = suffix.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsSuffix(self.__handle, sourceC, suffixC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isSuffix(_ source: System_String /* System.String */, _ suffix: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.__handle
		let suffixC = suffix.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IsSuffix_1(self.__handle, sourceC, suffixC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf(self.__handle, sourceC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_1(self.__handle, sourceC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_2(self.__handle, sourceC, valueC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_3(self.__handle, sourceC, valueC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_4(self.__handle, sourceC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_5(self.__handle, sourceC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_6(self.__handle, sourceC, valueC, startIndex, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_7(self.__handle, sourceC, valueC, startIndex, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_8(self.__handle, sourceC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_9(self.__handle, sourceC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_10(self.__handle, sourceC, valueC, startIndex, count, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_IndexOf_11(self.__handle, sourceC, valueC, startIndex, count, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf(self.__handle, sourceC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_1(self.__handle, sourceC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_2(self.__handle, sourceC, valueC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_3(self.__handle, sourceC, valueC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_4(self.__handle, sourceC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_5(self.__handle, sourceC, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_6(self.__handle, sourceC, valueC, startIndex, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_7(self.__handle, sourceC, valueC, startIndex, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_8(self.__handle, sourceC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_9(self.__handle, sourceC, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_10(self.__handle, sourceC, valueC, startIndex, count, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ source: System_String /* System.String */, _ value: System_String /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let valueC = value.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LastIndexOf_11(self.__handle, sourceC, valueC, startIndex, count, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getSortKey(_ source: System_String /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> System_Globalization_SortKey /* System.Globalization.SortKey */ {
		let sourceC = source.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetSortKey(self.__handle, sourceC, optionsC, &__exceptionC)
		
		let __returnValue = System_Globalization_SortKey(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getSortKey(_ source: System_String /* System.String */) throws -> System_Globalization_SortKey /* System.Globalization.SortKey */ {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetSortKey_1(self.__handle, sourceC, &__exceptionC)
		
		let __returnValue = System_Globalization_SortKey(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(_ source: System_String /* System.String */, _ options: System_Globalization_CompareOptions /* System.Globalization.CompareOptions */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_GetHashCode_1(self.__handle, sourceC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var version: System_Globalization_SortVersion /* System.Globalization.SortVersion */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_Version_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_SortVersion(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var lCID: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_CompareInfo_LCID_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_CompareInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_CompareInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_IDeserializationCallback /* System.Runtime.Serialization.IDeserializationCallback */: DNObject {
	public override class var typeName: String { get {
		"IDeserializationCallback"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.IDeserializationCallback"
	}}

	public func onDeserialization(_ sender: System_Object? /* System.Object */) throws {
		let senderC = sender?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_IDeserializationCallback_OnDeserialization(self.__handle, senderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_IDeserializationCallback_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_IDeserializationCallback_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_Assembly /* System.Reflection.Assembly */: System_Object {
	public override class var typeName: String { get {
		"Assembly"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.Assembly"
	}}

	public class func load(_ assemblyString: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyStringC = assemblyString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Load(assemblyStringC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func loadWithPartialName(_ partialName: System_String /* System.String */) throws -> System_Reflection_Assembly? /* System.Reflection.Assembly */ {
		let partialNameC = partialName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_LoadWithPartialName(partialNameC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func load(_ assemblyRef: System_Reflection_AssemblyName /* System.Reflection.AssemblyName */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyRefC = assemblyRef.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Load_1(assemblyRefC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getExecutingAssembly() throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetExecutingAssembly(&__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCallingAssembly() throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetCallingAssembly(&__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTypes() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetTypes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getExportedTypes() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetExportedTypes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getForwardedTypes() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetForwardedTypes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getManifestResourceInfo(_ resourceName: System_String /* System.String */) throws -> System_Reflection_ManifestResourceInfo? /* System.Reflection.ManifestResourceInfo */ {
		let resourceNameC = resourceName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetManifestResourceInfo(self.__handle, resourceNameC, &__exceptionC)
		
		let __returnValue = System_Reflection_ManifestResourceInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getManifestResourceNames() throws -> System_String_Array /* System.String[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetManifestResourceNames(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getManifestResourceStream(_ name: System_String /* System.String */) throws -> System_IO_Stream? /* System.IO.Stream */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetManifestResourceStream(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getManifestResourceStream(_ type: System_Type /* System.Type */, _ name: System_String /* System.String */) throws -> System_IO_Stream? /* System.IO.Stream */ {
		let typeC = type.__handle
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetManifestResourceStream_1(self.__handle, typeC, nameC, &__exceptionC)
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getName() throws -> System_Reflection_AssemblyName /* System.Reflection.AssemblyName */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetName(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_AssemblyName(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getName(_ copiedName: Bool /* System.Boolean */) throws -> System_Reflection_AssemblyName /* System.Reflection.AssemblyName */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetName_1(self.__handle, copiedName, &__exceptionC)
		
		let __returnValue = System_Reflection_AssemblyName(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getType(_ name: System_String /* System.String */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetType_1(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getType(_ name: System_String /* System.String */, _ throwOnError: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetType_2(self.__handle, nameC, throwOnError, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getType(_ name: System_String /* System.String */, _ throwOnError: Bool /* System.Boolean */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetType_3(self.__handle, nameC, throwOnError, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isDefined(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_IsDefined(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCustomAttributesData() throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetCustomAttributesData(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetCustomAttributes_1(self.__handle, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetCustomAttributes_2(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstance(_ typeName: System_String /* System.String */) throws -> System_Object? /* System.Object */ {
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_CreateInstance(self.__handle, typeNameC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstance(_ typeName: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Object? /* System.Object */ {
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_CreateInstance_1(self.__handle, typeNameC, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstance(_ typeName: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ args: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let typeNameC = typeName.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let argsC = args?.__handle
		let cultureC = culture?.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_CreateInstance_2(self.__handle, typeNameC, ignoreCase, bindingAttrC, binderC, argsC, cultureC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getModule(_ name: System_String /* System.String */) throws -> System_Reflection_Module? /* System.Reflection.Module */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetModule(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getModules() throws -> System_Reflection_Module_Array /* System.Reflection.Module[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetModules(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Module_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getModules(_ getResourceModules: Bool /* System.Boolean */) throws -> System_Reflection_Module_Array /* System.Reflection.Module[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetModules_1(self.__handle, getResourceModules, &__exceptionC)
		
		let __returnValue = System_Reflection_Module_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getLoadedModules() throws -> System_Reflection_Module_Array /* System.Reflection.Module[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetLoadedModules(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Module_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getLoadedModules(_ getResourceModules: Bool /* System.Boolean */) throws -> System_Reflection_Module_Array /* System.Reflection.Module[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetLoadedModules_1(self.__handle, getResourceModules, &__exceptionC)
		
		let __returnValue = System_Reflection_Module_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getReferencedAssemblies() throws -> System_Reflection_AssemblyName_Array /* System.Reflection.AssemblyName[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetReferencedAssemblies(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_AssemblyName_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getSatelliteAssembly(_ culture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let cultureC = culture.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetSatelliteAssembly(self.__handle, cultureC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getSatelliteAssembly(_ culture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */, _ version: System_Version? /* System.Version */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let cultureC = culture.__handle
		let versionC = version?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetSatelliteAssembly_1(self.__handle, cultureC, versionC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFile(_ name: System_String /* System.String */) throws -> System_IO_FileStream? /* System.IO.FileStream */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetFile(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFiles() throws -> System_IO_FileStream_Array /* System.IO.FileStream[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetFiles(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileStream_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFiles(_ getResourceModules: Bool /* System.Boolean */) throws -> System_IO_FileStream_Array /* System.IO.FileStream[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetFiles_1(self.__handle, getResourceModules, &__exceptionC)
		
		let __returnValue = System_IO_FileStream_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_Assembly_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Equals(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createQualifiedName(_ assemblyName: System_String? /* System.String */, _ typeName: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let assemblyNameC = assemblyName?.__handle
		let typeNameC = typeName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_CreateQualifiedName(assemblyNameC, typeNameC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getAssembly(_ type: System_Type /* System.Type */) throws -> System_Reflection_Assembly? /* System.Reflection.Assembly */ {
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetAssembly(typeC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getEntryAssembly() throws -> System_Reflection_Assembly? /* System.Reflection.Assembly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GetEntryAssembly(&__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func load(_ rawAssembly: System_Byte_Array /* System.Byte[] */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let rawAssemblyC = rawAssembly.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Load_2(rawAssemblyC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func load(_ rawAssembly: System_Byte_Array /* System.Byte[] */, _ rawSymbolStore: System_Byte_Array? /* System.Byte[] */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let rawAssemblyC = rawAssembly.__handle
		let rawSymbolStoreC = rawSymbolStore?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Load_3(rawAssemblyC, rawSymbolStoreC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func loadFile(_ path: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_LoadFile(pathC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func loadFrom(_ assemblyFile: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyFileC = assemblyFile.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_LoadFrom(assemblyFileC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func loadFrom(_ assemblyFile: System_String /* System.String */, _ hashValue: System_Byte_Array? /* System.Byte[] */, _ hashAlgorithm: System_Configuration_Assemblies_AssemblyHashAlgorithm /* System.Configuration.Assemblies.AssemblyHashAlgorithm */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyFileC = assemblyFile.__handle
		let hashValueC = hashValue?.__handle
		let hashAlgorithmC = hashAlgorithm.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_LoadFrom_1(assemblyFileC, hashValueC, hashAlgorithmC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func unsafeLoadFrom(_ assemblyFile: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyFileC = assemblyFile.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_UnsafeLoadFrom(assemblyFileC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func loadModule(_ moduleName: System_String /* System.String */, _ rawModule: System_Byte_Array? /* System.Byte[] */) throws -> System_Reflection_Module /* System.Reflection.Module */ {
		let moduleNameC = moduleName.__handle
		let rawModuleC = rawModule?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_LoadModule(self.__handle, moduleNameC, rawModuleC, &__exceptionC)
		
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func loadModule(_ moduleName: System_String /* System.String */, _ rawModule: System_Byte_Array? /* System.Byte[] */, _ rawSymbolStore: System_Byte_Array? /* System.Byte[] */) throws -> System_Reflection_Module /* System.Reflection.Module */ {
		let moduleNameC = moduleName.__handle
		let rawModuleC = rawModule?.__handle
		let rawSymbolStoreC = rawSymbolStore?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_LoadModule_1(self.__handle, moduleNameC, rawModuleC, rawSymbolStoreC, &__exceptionC)
		
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reflectionOnlyLoad(_ rawAssembly: System_Byte_Array /* System.Byte[] */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let rawAssemblyC = rawAssembly.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ReflectionOnlyLoad(rawAssemblyC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reflectionOnlyLoad(_ assemblyString: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyStringC = assemblyString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ReflectionOnlyLoad_1(assemblyStringC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reflectionOnlyLoadFrom(_ assemblyFile: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyFileC = assemblyFile.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ReflectionOnlyLoadFrom(assemblyFileC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var definedTypes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_DefinedTypes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var exportedTypes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Type> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ExportedTypes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var codeBase: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_CodeBase_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var entryPoint: System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_EntryPoint_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var fullName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_FullName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var imageRuntimeVersion: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ImageRuntimeVersion_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isDynamic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_IsDynamic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var location: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Location_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var reflectionOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ReflectionOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isCollectible: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_IsCollectible_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFullyTrusted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_IsFullyTrusted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var customAttributes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_CustomAttributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var escapedCodeBase: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_EscapedCodeBase_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var manifestModule: System_Reflection_Module /* System.Reflection.Module */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_ManifestModule_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var modules: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.Module> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_Modules_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var globalAssemblyCache: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_GlobalAssemblyCache_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var hostContext: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_HostContext_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var securityRuleSet: System_Security_SecurityRuleSet /* System.Security.SecurityRuleSet */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Assembly_SecurityRuleSet_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_SecurityRuleSet(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public func moduleResolve_add(_ value: System_Reflection_ModuleResolveEventHandler? /* System.Reflection.ModuleResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_Reflection_Assembly_ModuleResolve_Add(self.__handle, valueC)
		
		
	}
	public func moduleResolve_remove(_ value: System_Reflection_ModuleResolveEventHandler? /* System.Reflection.ModuleResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_Reflection_Assembly_ModuleResolve_Remove(self.__handle, valueC)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_Assembly_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_Assembly_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_ISerializable /* System.Runtime.Serialization.ISerializable */: DNObject {
	public override class var typeName: String { get {
		"ISerializable"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.ISerializable"
	}}

	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_ISerializable_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_ISerializable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_ISerializable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */: System_Object {
	public override class var typeName: String { get {
		"SerializationInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.SerializationInfo"
	}}

	public func setType(_ type: System_Type /* System.Type */) throws {
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_SetType(self.__handle, typeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getEnumerator() throws -> System_Runtime_Serialization_SerializationInfoEnumerator /* System.Runtime.Serialization.SerializationInfoEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_Serialization_SerializationInfoEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: System_Object? /* System.Object */, _ type: System_Type /* System.Type */) throws {
		let nameC = name.__handle
		let valueC = value?.__handle
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue(self.__handle, nameC, valueC, typeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: System_Object? /* System.Object */) throws {
		let nameC = name.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_1(self.__handle, nameC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Bool /* System.Boolean */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_2(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: DNChar /* System.Char */) throws {
		let nameC = name.__handle
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_3(self.__handle, nameC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Int8 /* System.SByte */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_4(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: UInt8 /* System.Byte */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_5(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Int16 /* System.Int16 */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_6(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: UInt16 /* System.UInt16 */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_7(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Int32 /* System.Int32 */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_8(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: UInt32 /* System.UInt32 */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_9(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Int64 /* System.Int64 */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_10(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: UInt64 /* System.UInt64 */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_11(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Float /* System.Single */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_12(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: Double /* System.Double */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_13(self.__handle, nameC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: System_Decimal /* System.Decimal */) throws {
		let nameC = name.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_14(self.__handle, nameC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addValue(_ name: System_String /* System.String */, _ value: System_DateTime /* System.DateTime */) throws {
		let nameC = name.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AddValue_15(self.__handle, nameC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getValue(_ name: System_String /* System.String */, _ type: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetValue(self.__handle, nameC, typeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getBoolean(_ name: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetBoolean(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getChar(_ name: System_String /* System.String */) throws -> DNChar /* System.Char */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetChar(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getSByte(_ name: System_String /* System.String */) throws -> Int8 /* System.SByte */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetSByte(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getByte(_ name: System_String /* System.String */) throws -> UInt8 /* System.Byte */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetByte(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getInt16(_ name: System_String /* System.String */) throws -> Int16 /* System.Int16 */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetInt16(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getUInt16(_ name: System_String /* System.String */) throws -> UInt16 /* System.UInt16 */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetUInt16(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getInt32(_ name: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetInt32(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getUInt32(_ name: System_String /* System.String */) throws -> UInt32 /* System.UInt32 */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetUInt32(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getInt64(_ name: System_String /* System.String */) throws -> Int64 /* System.Int64 */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetInt64(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getUInt64(_ name: System_String /* System.String */) throws -> UInt64 /* System.UInt64 */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetUInt64(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getSingle(_ name: System_String /* System.String */) throws -> Float /* System.Single */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetSingle(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDouble(_ name: System_String /* System.String */) throws -> Double /* System.Double */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetDouble(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDecimal(_ name: System_String /* System.String */) throws -> System_Decimal /* System.Decimal */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetDecimal(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDateTime(_ name: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetDateTime(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getString(_ name: System_String /* System.String */) throws -> System_String? /* System.String */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_GetString(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ type: System_Type /* System.Type */, _ converter: System_Runtime_Serialization_IFormatterConverter /* System.Runtime.Serialization.IFormatterConverter */) throws {
		let typeC = type.__handle
		let converterC = converter.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_Create(typeC, converterC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ type: System_Type /* System.Type */, _ converter: System_Runtime_Serialization_IFormatterConverter /* System.Runtime.Serialization.IFormatterConverter */, _ requireSameTokenInPartialTrust: Bool /* System.Boolean */) throws {
		let typeC = type.__handle
		let converterC = converter.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_Create_1(typeC, converterC, requireSameTokenInPartialTrust, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var fullTypeName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_FullTypeName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func fullTypeName_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_FullTypeName_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var assemblyName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_AssemblyName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func assemblyName_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfo_AssemblyName_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isFullTypeNameSetExplicit: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_IsFullTypeNameSetExplicit_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAssemblyNameSetExplicit: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_IsAssemblyNameSetExplicit_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var memberCount: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_MemberCount_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var objectType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfo_ObjectType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_SerializationInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_SerializationInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_SerializationInfoEnumerator /* System.Runtime.Serialization.SerializationInfoEnumerator */: System_Object {
	public override class var typeName: String { get {
		"SerializationInfoEnumerator"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.SerializationInfoEnumerator"
	}}

	public func moveNext() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfoEnumerator_MoveNext(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_Serialization_SerializationInfoEnumerator_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var current: System_Runtime_Serialization_SerializationEntry /* System.Runtime.Serialization.SerializationEntry */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfoEnumerator_Current_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_Serialization_SerializationEntry(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfoEnumerator_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var value: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfoEnumerator_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var objectType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationInfoEnumerator_ObjectType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_SerializationInfoEnumerator_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_SerializationInfoEnumerator_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_SerializationEntry /* System.Runtime.Serialization.SerializationEntry */: System_ValueType {
	public override class var typeName: String { get {
		"SerializationEntry"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.SerializationEntry"
	}}

	public var value: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationEntry_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationEntry_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var objectType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationEntry_ObjectType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_SerializationEntry_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_SerializationEntry_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_SerializationEntry_Destroy(self.__handle)
		
	}
	
	
}


public class System_SByte /* System.SByte */: System_ValueType {
	public override class var typeName: String { get {
		"SByte"
	}}

	public override class var fullTypeName: String { get {
		"System.SByte"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_SByte_TypeOf())
		
	}}
	
	
}















































public class System_Numerics_ISignedNumber_A1 /* System.Numerics.ISignedNumber<> */: DNObject {
	public override class var typeName: String { get {
		"ISignedNumber`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.ISignedNumber<>"
	}}

	public class func negativeOne(TSelf: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ISignedNumber_A1_NegativeOne_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_ISignedNumber_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_ISignedNumber_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.




public class System_Byte /* System.Byte */: System_ValueType {
	public override class var typeName: String { get {
		"Byte"
	}}

	public override class var fullTypeName: String { get {
		"System.Byte"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Byte_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_Byte_Array /* System.Byte[] */: System_Array {
	public override class var typeName: String { get {
		"Byte[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Byte[]"
	}}

	
}














// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_Int16 /* System.Int16 */: System_ValueType {
	public override class var typeName: String { get {
		"Int16"
	}}

	public override class var fullTypeName: String { get {
		"System.Int16"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Int16_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_UInt16 /* System.UInt16 */: System_ValueType {
	public override class var typeName: String { get {
		"UInt16"
	}}

	public override class var fullTypeName: String { get {
		"System.UInt16"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UInt16_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_UInt32 /* System.UInt32 */: System_ValueType {
	public override class var typeName: String { get {
		"UInt32"
	}}

	public override class var fullTypeName: String { get {
		"System.UInt32"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UInt32_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_Int64 /* System.Int64 */: System_ValueType {
	public override class var typeName: String { get {
		"Int64"
	}}

	public override class var fullTypeName: String { get {
		"System.Int64"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Int64_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_UInt64 /* System.UInt64 */: System_ValueType {
	public override class var typeName: String { get {
		"UInt64"
	}}

	public override class var fullTypeName: String { get {
		"System.UInt64"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UInt64_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_Single /* System.Single */: System_ValueType {
	public override class var typeName: String { get {
		"Single"
	}}

	public override class var fullTypeName: String { get {
		"System.Single"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Single_TypeOf())
		
	}}
	
	
}






public class System_Numerics_IBinaryFloatingPointIeee754_A1 /* System.Numerics.IBinaryFloatingPointIeee754<> */: DNObject {
	public override class var typeName: String { get {
		"IBinaryFloatingPointIeee754`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IBinaryFloatingPointIeee754<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IBinaryFloatingPointIeee754_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IBinaryFloatingPointIeee754_A1_Destroy(self.__handle)
		
	}
	
	
}









































public class System_Numerics_IFloatingPointIeee754_A1 /* System.Numerics.IFloatingPointIeee754<> */: DNObject {
	public override class var typeName: String { get {
		"IFloatingPointIeee754`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IFloatingPointIeee754<>"
	}}

	public class func atan2(TSelf: System_Type /* System.Type */, _ y: System_Object? /* System.Object */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let yC = y?.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_Atan2(TSelfC, yC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atan2Pi(TSelf: System_Type /* System.Type */, _ y: System_Object? /* System.Object */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let yC = y?.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_Atan2Pi(TSelfC, yC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func bitDecrement(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_BitDecrement(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func bitIncrement(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_BitIncrement(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fusedMultiplyAdd(TSelf: System_Type /* System.Type */, _ left: System_Object? /* System.Object */, _ right: System_Object? /* System.Object */, _ addend: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let leftC = left?.__handle
		let rightC = right?.__handle
		let addendC = addend?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_FusedMultiplyAdd(TSelfC, leftC, rightC, addendC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ieee754Remainder(TSelf: System_Type /* System.Type */, _ left: System_Object? /* System.Object */, _ right: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let leftC = left?.__handle
		let rightC = right?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_Ieee754Remainder(TSelfC, leftC, rightC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func iLogB(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_ILogB(TSelfC, xC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lerp(TSelf: System_Type /* System.Type */, _ value1: System_Object? /* System.Object */, _ value2: System_Object? /* System.Object */, _ amount: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let value1C = value1?.__handle
		let value2C = value2?.__handle
		let amountC = amount?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_Lerp(TSelfC, value1C, value2C, amountC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reciprocalEstimate(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_ReciprocalEstimate(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reciprocalSqrtEstimate(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_ReciprocalSqrtEstimate(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func scaleB(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ n: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_ScaleB(TSelfC, xC, n, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func epsilon(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_Epsilon_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func naN(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_NaN_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func negativeInfinity(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_NegativeInfinity_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func negativeZero(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_NegativeZero_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func positiveInfinity(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointIeee754_A1_PositiveInfinity_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IFloatingPointIeee754_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IFloatingPointIeee754_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IExponentialFunctions_A1 /* System.Numerics.IExponentialFunctions<> */: DNObject {
	public override class var typeName: String { get {
		"IExponentialFunctions`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IExponentialFunctions<>"
	}}

	public class func exp(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IExponentialFunctions_A1_Exp(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func expM1(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IExponentialFunctions_A1_ExpM1(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp2(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IExponentialFunctions_A1_Exp2(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp2M1(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IExponentialFunctions_A1_Exp2M1(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp10(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IExponentialFunctions_A1_Exp10(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp10M1(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IExponentialFunctions_A1_Exp10M1(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IExponentialFunctions_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IExponentialFunctions_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IFloatingPointConstants_A1 /* System.Numerics.IFloatingPointConstants<> */: DNObject {
	public override class var typeName: String { get {
		"IFloatingPointConstants`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IFloatingPointConstants<>"
	}}

	public class func e(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointConstants_A1_E_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func pi(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointConstants_A1_Pi_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public class func tau(TSelf: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPointConstants_A1_Tau_Get(TSelfC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IFloatingPointConstants_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IFloatingPointConstants_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IFloatingPoint_A1 /* System.Numerics.IFloatingPoint<> */: DNObject {
	public override class var typeName: String { get {
		"IFloatingPoint`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IFloatingPoint<>"
	}}

	public class func ceiling(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Ceiling(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func floor(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Floor(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Round(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ digits: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Round_1(TSelfC, xC, digits, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Round_2(TSelfC, xC, modeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ digits: Int32 /* System.Int32 */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Round_3(TSelfC, xC, digits, modeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func truncate(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_Truncate(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getExponentByteCount(TSelf: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_GetExponentByteCount(self.__handle, TSelfC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getExponentShortestBitLength(TSelf: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_GetExponentShortestBitLength(self.__handle, TSelfC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getSignificandBitLength(TSelf: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_GetSignificandBitLength(self.__handle, TSelfC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getSignificandByteCount(TSelf: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_GetSignificandByteCount(self.__handle, TSelfC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeExponentBigEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteExponentBigEndian(self.__handle, TSelfC, destinationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeExponentBigEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteExponentBigEndian_1(self.__handle, TSelfC, destinationC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeExponentLittleEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteExponentLittleEndian(self.__handle, TSelfC, destinationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeExponentLittleEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteExponentLittleEndian_1(self.__handle, TSelfC, destinationC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeSignificandBigEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteSignificandBigEndian(self.__handle, TSelfC, destinationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeSignificandBigEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteSignificandBigEndian_1(self.__handle, TSelfC, destinationC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeSignificandLittleEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteSignificandLittleEndian(self.__handle, TSelfC, destinationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func writeSignificandLittleEndian(TSelf: System_Type /* System.Type */, _ destination: System_Byte_Array? /* System.Byte[] */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TSelfC = TSelf.__handle
		let destinationC = destination?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IFloatingPoint_A1_WriteSignificandLittleEndian_1(self.__handle, TSelfC, destinationC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IFloatingPoint_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IFloatingPoint_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.




public class System_Numerics_IHyperbolicFunctions_A1 /* System.Numerics.IHyperbolicFunctions<> */: DNObject {
	public override class var typeName: String { get {
		"IHyperbolicFunctions`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IHyperbolicFunctions<>"
	}}

	public class func acosh(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IHyperbolicFunctions_A1_Acosh(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func asinh(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IHyperbolicFunctions_A1_Asinh(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atanh(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IHyperbolicFunctions_A1_Atanh(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cosh(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IHyperbolicFunctions_A1_Cosh(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sinh(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IHyperbolicFunctions_A1_Sinh(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tanh(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IHyperbolicFunctions_A1_Tanh(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IHyperbolicFunctions_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IHyperbolicFunctions_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_ILogarithmicFunctions_A1 /* System.Numerics.ILogarithmicFunctions<> */: DNObject {
	public override class var typeName: String { get {
		"ILogarithmicFunctions`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.ILogarithmicFunctions<>"
	}}

	public class func log(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_Log(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ newBase: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let newBaseC = newBase?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_Log_1(TSelfC, xC, newBaseC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func logP1(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_LogP1(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log2(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_Log2(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log2P1(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_Log2P1(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log10(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_Log10(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log10P1(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ILogarithmicFunctions_A1_Log10P1(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_ILogarithmicFunctions_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_ILogarithmicFunctions_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IPowerFunctions_A1 /* System.Numerics.IPowerFunctions<> */: DNObject {
	public override class var typeName: String { get {
		"IPowerFunctions`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IPowerFunctions<>"
	}}

	public class func pow(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IPowerFunctions_A1_Pow(TSelfC, xC, yC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IPowerFunctions_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IPowerFunctions_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_IRootFunctions_A1 /* System.Numerics.IRootFunctions<> */: DNObject {
	public override class var typeName: String { get {
		"IRootFunctions`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.IRootFunctions<>"
	}}

	public class func cbrt(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IRootFunctions_A1_Cbrt(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func hypot(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IRootFunctions_A1_Hypot(TSelfC, xC, yC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func rootN(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ n: Int32 /* System.Int32 */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IRootFunctions_A1_RootN(TSelfC, xC, n, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sqrt(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_IRootFunctions_A1_Sqrt(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_IRootFunctions_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_IRootFunctions_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.


public class System_Numerics_ITrigonometricFunctions_A1 /* System.Numerics.ITrigonometricFunctions<> */: DNObject {
	public override class var typeName: String { get {
		"ITrigonometricFunctions`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Numerics.ITrigonometricFunctions<>"
	}}

	public class func acos(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_Acos(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func acosPi(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_AcosPi(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func asin(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_Asin(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func asinPi(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_AsinPi(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atan(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_Atan(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atanPi(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_AtanPi(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cos(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_Cos(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cosPi(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_CosPi(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func degreesToRadians(TSelf: System_Type /* System.Type */, _ degrees: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let degreesC = degrees?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_DegreesToRadians(TSelfC, degreesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func radiansToDegrees(TSelf: System_Type /* System.Type */, _ radians: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let radiansC = radians?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_RadiansToDegrees(TSelfC, radiansC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sin(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_Sin(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sinPi(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_SinPi(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tan(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_Tan(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tanPi(TSelf: System_Type /* System.Type */, _ x: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TSelfC = TSelf.__handle
		let xC = x?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Numerics_ITrigonometricFunctions_A1_TanPi(TSelfC, xC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Numerics_ITrigonometricFunctions_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Numerics_ITrigonometricFunctions_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TSelf" was skipped. Reason: It has no full name.




// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_Double /* System.Double */: System_ValueType {
	public override class var typeName: String { get {
		"Double"
	}}

	public override class var fullTypeName: String { get {
		"System.Double"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Double_TypeOf())
		
	}}
	
	
}



































































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_Decimal /* System.Decimal */: System_ValueType {
	public override class var typeName: String { get {
		"Decimal"
	}}

	public override class var fullTypeName: String { get {
		"System.Decimal"
	}}

	public class func fromOACurrency(_ cy: Int64 /* System.Int64 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_FromOACurrency(cy, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toOACurrency(_ value: System_Decimal /* System.Decimal */) throws -> Int64 /* System.Int64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToOACurrency(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func add(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Add(d1C, d2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ceiling(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Ceiling(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func compare(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> Int32 /* System.Int32 */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Compare(d1C, d2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Decimal /* System.Decimal */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func divide(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Divide(d1C, d2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Equals_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Equals_2(d1C, d2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func floor(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Floor(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToString_2(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_Decimal /* System.Decimal */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Parse(sC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */) throws -> System_Decimal /* System.Decimal */ {
		let sC = s.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Parse_1(sC, styleC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Parse_2(sC, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let sC = s.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Parse_3(sC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_Decimal(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ result: inout System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_TryParse_1(utf8TextC, &resultC, &__exceptionC)
		
		result = System_Decimal(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_TryParse_2(sC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_Decimal(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getBits(_ d: System_Decimal /* System.Decimal */) throws -> System_Int32_Array /* System.Int32[] */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_GetBits(dC, &__exceptionC)
		
		let __returnValue = System_Int32_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func remainder(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Remainder(d1C, d2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func multiply(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Multiply(d1C, d2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func negate(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Negate(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Round(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */, _ decimals: Int32 /* System.Int32 */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Round_1(dC, decimals, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Round_2(dC, modeC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */, _ decimals: Int32 /* System.Int32 */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Round_3(dC, decimals, modeC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func subtract(_ d1: System_Decimal /* System.Decimal */, _ d2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let d1C = d1.__handle
		let d2C = d2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Subtract(d1C, d2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toByte(_ value: System_Decimal /* System.Decimal */) throws -> UInt8 /* System.Byte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToByte(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_Decimal /* System.Decimal */) throws -> Int8 /* System.SByte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToSByte(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_Decimal /* System.Decimal */) throws -> Int16 /* System.Int16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToInt16(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ d: System_Decimal /* System.Decimal */) throws -> Double /* System.Double */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToDouble(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ d: System_Decimal /* System.Decimal */) throws -> Int32 /* System.Int32 */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToInt32(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ d: System_Decimal /* System.Decimal */) throws -> Int64 /* System.Int64 */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToInt64(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_Decimal /* System.Decimal */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToUInt16(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ d: System_Decimal /* System.Decimal */) throws -> UInt32 /* System.UInt32 */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToUInt32(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ d: System_Decimal /* System.Decimal */) throws -> UInt64 /* System.UInt64 */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToUInt64(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ d: System_Decimal /* System.Decimal */) throws -> Float /* System.Single */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_ToSingle(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func truncate(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Truncate(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTypeCode() throws -> System_TypeCode /* System.TypeCode */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_GetTypeCode(self.__handle, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func clamp(_ value: System_Decimal /* System.Decimal */, _ min: System_Decimal /* System.Decimal */, _ max: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		let minC = min.__handle
		let maxC = max.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Clamp(valueC, minC, maxC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copySign(_ value: System_Decimal /* System.Decimal */, _ sign: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		let signC = sign.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_CopySign(valueC, signC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func max(_ x: System_Decimal /* System.Decimal */, _ y: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Max(xC, yC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func min(_ x: System_Decimal /* System.Decimal */, _ y: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Min(xC, yC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sign(_ d: System_Decimal /* System.Decimal */) throws -> Int32 /* System.Int32 */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Sign(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Abs(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createChecked(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Decimal /* System.Decimal */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_CreateChecked_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createSaturating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Decimal /* System.Decimal */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_CreateSaturating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createTruncating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Decimal /* System.Decimal */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_CreateTruncating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isCanonical(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_IsCanonical(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isEvenInteger(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_IsEvenInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isInteger(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_IsInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNegative(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_IsNegative(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isOddInteger(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_IsOddInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isPositive(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_IsPositive(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func maxMagnitude(_ x: System_Decimal /* System.Decimal */, _ y: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_MaxMagnitude(xC, yC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func minMagnitude(_ x: System_Decimal /* System.Decimal */, _ y: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_MinMagnitude(xC, yC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_TryParse_3(sC, providerC, &resultC, &__exceptionC)
		
		result = System_Decimal(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Parse_4(utf8TextC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_TryParse_4(utf8TextC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_Decimal(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Parse_5(utf8TextC, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_TryParse_5(utf8TextC, providerC, &resultC, &__exceptionC)
		
		result = System_Decimal(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_1(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: UInt32 /* System.UInt32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: UInt64 /* System.UInt64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: Float /* System.Single */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: Double /* System.Double */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ bits: System_Int32_Array /* System.Int32[] */) throws {
		let bitsC = bits.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_7(bitsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ lo: Int32 /* System.Int32 */, _ mid: Int32 /* System.Int32 */, _ hi: Int32 /* System.Int32 */, _ isNegative: Bool /* System.Boolean */, _ scale: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_8(lo, mid, hi, isNegative, scale, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var scale: UInt8 /* System.Byte */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Scale_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var zero: System_Decimal /* System.Decimal */ { get {
		
		
		let __returnValueC = System_Decimal_Zero_Get()
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var one: System_Decimal /* System.Decimal */ { get {
		
		
		let __returnValueC = System_Decimal_One_Get()
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var minusOne: System_Decimal /* System.Decimal */ { get {
		
		
		let __returnValueC = System_Decimal_MinusOne_Get()
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_Decimal /* System.Decimal */ { get {
		
		
		let __returnValueC = System_Decimal_MaxValue_Get()
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var minValue: System_Decimal /* System.Decimal */ { get {
		
		
		let __returnValueC = System_Decimal_MinValue_Get()
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Decimal_Create_9(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Decimal_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Decimal_Destroy(self.__handle)
		
	}
	
	
}















































public class System_Int32_Array /* System.Int32[] */: System_Array {
	public override class var typeName: String { get {
		"Int32[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Int32[]"
	}}

	
}














// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_DateTime /* System.DateTime */: System_ValueType {
	public override class var typeName: String { get {
		"DateTime"
	}}

	public override class var fullTypeName: String { get {
		"System.DateTime"
	}}

	public func add(_ value: System_TimeSpan /* System.TimeSpan */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Add(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addDays(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddDays(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addHours(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddHours(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMilliseconds(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddMilliseconds(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMicroseconds(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddMicroseconds(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMinutes(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddMinutes(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMonths(_ months: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddMonths(self.__handle, months, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addSeconds(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddSeconds(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addTicks(_ value: Int64 /* System.Int64 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddTicks(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addYears(_ value: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_AddYears(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func compare(_ t1: System_DateTime /* System.DateTime */, _ t2: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let t1C = t1.__handle
		let t2C = t2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Compare(t1C, t2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func daysInMonth(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_DaysInMonth(year, month, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ value: System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Equals_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ t1: System_DateTime /* System.DateTime */, _ t2: System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let t1C = t1.__handle
		let t2C = t2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Equals_2(t1C, t2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromBinary(_ dateData: Int64 /* System.Int64 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_FromBinary(dateData, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromFileTime(_ fileTime: Int64 /* System.Int64 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_FromFileTime(fileTime, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromFileTimeUtc(_ fileTime: Int64 /* System.Int64 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_FromFileTimeUtc(fileTime, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromOADate(_ d: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_FromOADate(d, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isDaylightSavingTime() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_IsDaylightSavingTime(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func specifyKind(_ value: System_DateTime /* System.DateTime */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.__handle
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_SpecifyKind(valueC, kindC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toBinary() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToBinary(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isLeapYear(_ year: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_IsLeapYear(year, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Parse(sC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTime /* System.DateTime */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Parse_1(sC, providerC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateTime /* System.DateTime */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		let stylesC = styles.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Parse_2(sC, providerC, stylesC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ format: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTime /* System.DateTime */ {
		let sC = s.__handle
		let formatC = format.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ParseExact(sC, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ format: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateTime /* System.DateTime */ {
		let sC = s.__handle
		let formatC = format.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ParseExact_1(sC, formatC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateTime /* System.DateTime */ {
		let sC = s.__handle
		let formatsC = formats.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ParseExact_2(sC, formatsC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func subtract(_ value: System_DateTime /* System.DateTime */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Subtract(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func subtract(_ value: System_TimeSpan /* System.TimeSpan */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Subtract_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toOADate() throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToOADate(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toFileTime() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToFileTime(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toFileTimeUtc() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToFileTimeUtc(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toLocalTime() throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToLocalTime(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLongDateString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToLongDateString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLongTimeString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToLongTimeString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toShortDateString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToShortDateString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toShortTimeString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToShortTimeString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToString_2(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUniversalTime() throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_ToUniversalTime(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_DateTime(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		let stylesC = styles.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_TryParse_1(sC, providerC, stylesC, &resultC, &__exceptionC)
		
		result = System_DateTime(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatC = format?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_TryParseExact(sC, formatC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_DateTime(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatsC = formats?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_TryParseExact_1(sC, formatsC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_DateTime(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func deconstruct(_ date: inout System_DateOnly /* System.DateOnly */, _ time: inout System_TimeOnly /* System.TimeOnly */) throws {
		var dateC = date.__handle
		var timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_DateTime_Deconstruct(self.__handle, &dateC, &timeC, &__exceptionC)
		
		date = System_DateOnly(handle: dateC)
		
		time = System_TimeOnly(handle: timeC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func deconstruct(_ year: inout Int32 /* System.Int32 */, _ month: inout Int32 /* System.Int32 */, _ day: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_DateTime_Deconstruct_1(self.__handle, &year, &month, &day, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getDateTimeFormats() throws -> System_String_Array /* System.String[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_GetDateTimeFormats(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDateTimeFormats(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String_Array /* System.String[] */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_GetDateTimeFormats_1(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDateTimeFormats(_ format: DNChar /* System.Char */) throws -> System_String_Array /* System.String[] */ {
		let formatC = format.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_GetDateTimeFormats_2(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDateTimeFormats(_ format: DNChar /* System.Char */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String_Array /* System.String[] */ {
		let formatC = format.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_GetDateTimeFormats_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTypeCode() throws -> System_TypeCode /* System.TypeCode */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_GetTypeCode(self.__handle, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_TryParse_2(sC, providerC, &resultC, &__exceptionC)
		
		result = System_DateTime(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ ticks: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create(ticks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ ticks: Int64 /* System.Int64 */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_1(ticks, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ date: System_DateOnly /* System.DateOnly */, _ time: System_TimeOnly /* System.TimeOnly */) throws {
		let dateC = date.__handle
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_2(dateC, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ date: System_DateOnly /* System.DateOnly */, _ time: System_TimeOnly /* System.TimeOnly */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let dateC = date.__handle
		let timeC = time.__handle
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_3(dateC, timeC, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_4(year, month, day, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */) throws {
		let calendarC = calendar.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_5(year, month, day, calendarC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let calendarC = calendar.__handle
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_6(year, month, day, hour, minute, second, millisecond, calendarC, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_7(year, month, day, hour, minute, second, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_8(year, month, day, hour, minute, second, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */) throws {
		let calendarC = calendar.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_9(year, month, day, hour, minute, second, calendarC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_10(year, month, day, hour, minute, second, millisecond, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_11(year, month, day, hour, minute, second, millisecond, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */) throws {
		let calendarC = calendar.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_12(year, month, day, hour, minute, second, millisecond, calendarC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_13(year, month, day, hour, minute, second, millisecond, microsecond, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_14(year, month, day, hour, minute, second, millisecond, microsecond, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */) throws {
		let calendarC = calendar.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_15(year, month, day, hour, minute, second, millisecond, microsecond, calendarC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws {
		let calendarC = calendar.__handle
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_16(year, month, day, hour, minute, second, millisecond, microsecond, calendarC, kindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var date: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Date_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var day: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Day_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var dayOfWeek: System_DayOfWeek /* System.DayOfWeek */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_DayOfWeek_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DayOfWeek(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dayOfYear: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_DayOfYear_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var hour: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Hour_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var kind: System_DateTimeKind /* System.DateTimeKind */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Kind_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTimeKind(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var millisecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Millisecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var microsecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Microsecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var nanosecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Nanosecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var minute: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Minute_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var month: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Month_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var now: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Now_Get(&__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var second: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Second_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var ticks: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Ticks_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var timeOfDay: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_TimeOfDay_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var today: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Today_Get(&__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var year: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Year_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var utcNow: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_UtcNow_Get(&__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var minValue: System_DateTime /* System.DateTime */ { get {
		
		
		let __returnValueC = System_DateTime_MinValue_Get()
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_DateTime /* System.DateTime */ { get {
		
		
		let __returnValueC = System_DateTime_MaxValue_Get()
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var unixEpoch: System_DateTime /* System.DateTime */ { get {
		
		
		let __returnValueC = System_DateTime_UnixEpoch_Get()
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTime_Create_17(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_DateTime_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_DateTime_Destroy(self.__handle)
		
	}
	
	
}











public class System_TimeSpan /* System.TimeSpan */: System_ValueType {
	public override class var typeName: String { get {
		"TimeSpan"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeSpan"
	}}

	public func add(_ ts: System_TimeSpan /* System.TimeSpan */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let tsC = ts.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Add(self.__handle, tsC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func compare(_ t1: System_TimeSpan /* System.TimeSpan */, _ t2: System_TimeSpan /* System.TimeSpan */) throws -> Int32 /* System.Int32 */ {
		let t1C = t1.__handle
		let t2C = t2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Compare(t1C, t2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_TimeSpan /* System.TimeSpan */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromDays(_ value: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromDays(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func duration() throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Duration(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ obj: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Equals_1(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ t1: System_TimeSpan /* System.TimeSpan */, _ t2: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let t1C = t1.__handle
		let t2C = t2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Equals_2(t1C, t2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromHours(_ value: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromHours(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromMilliseconds(_ value: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromMilliseconds(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromMicroseconds(_ value: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromMicroseconds(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromMinutes(_ value: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromMinutes(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func negate() throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Negate(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromSeconds(_ value: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromSeconds(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func subtract(_ ts: System_TimeSpan /* System.TimeSpan */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let tsC = ts.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Subtract(self.__handle, tsC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func multiply(_ factor: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Multiply(self.__handle, factor, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func divide(_ divisor: Double /* System.Double */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Divide(self.__handle, divisor, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func divide(_ ts: System_TimeSpan /* System.TimeSpan */) throws -> Double /* System.Double */ {
		let tsC = ts.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Divide_1(self.__handle, tsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromTicks(_ value: Int64 /* System.Int64 */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_FromTicks(value, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Parse(sC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ input: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let inputC = input.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Parse_1(inputC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ format: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let inputC = input.__handle
		let formatC = format.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ParseExact(inputC, formatC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let inputC = input.__handle
		let formatsC = formats.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ParseExact_1(inputC, formatsC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ format: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_TimeSpanStyles /* System.Globalization.TimeSpanStyles */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let inputC = input.__handle
		let formatC = format.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ParseExact_2(inputC, formatC, formatProviderC, stylesC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_TimeSpanStyles /* System.Globalization.TimeSpanStyles */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let inputC = input.__handle
		let formatsC = formats.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ParseExact_3(inputC, formatsC, formatProviderC, stylesC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_TimeSpan(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ input: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatProviderC = formatProvider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TryParse_1(inputC, formatProviderC, &resultC, &__exceptionC)
		
		result = System_TimeSpan(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ format: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatC = format?.__handle
		let formatProviderC = formatProvider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TryParseExact(inputC, formatC, formatProviderC, &resultC, &__exceptionC)
		
		result = System_TimeSpan(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatsC = formats?.__handle
		let formatProviderC = formatProvider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TryParseExact_1(inputC, formatsC, formatProviderC, &resultC, &__exceptionC)
		
		result = System_TimeSpan(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ format: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_TimeSpanStyles /* System.Globalization.TimeSpanStyles */, _ result: inout System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatC = format?.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TryParseExact_2(inputC, formatC, formatProviderC, stylesC, &resultC, &__exceptionC)
		
		result = System_TimeSpan(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_TimeSpanStyles /* System.Globalization.TimeSpanStyles */, _ result: inout System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatsC = formats?.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TryParseExact_3(inputC, formatsC, formatProviderC, stylesC, &resultC, &__exceptionC)
		
		result = System_TimeSpan(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_ToString_2(self.__handle, formatC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ ticks: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Create(ticks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ hours: Int32 /* System.Int32 */, _ minutes: Int32 /* System.Int32 */, _ seconds: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Create_1(hours, minutes, seconds, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ days: Int32 /* System.Int32 */, _ hours: Int32 /* System.Int32 */, _ minutes: Int32 /* System.Int32 */, _ seconds: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Create_2(days, hours, minutes, seconds, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ days: Int32 /* System.Int32 */, _ hours: Int32 /* System.Int32 */, _ minutes: Int32 /* System.Int32 */, _ seconds: Int32 /* System.Int32 */, _ milliseconds: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Create_3(days, hours, minutes, seconds, milliseconds, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ days: Int32 /* System.Int32 */, _ hours: Int32 /* System.Int32 */, _ minutes: Int32 /* System.Int32 */, _ seconds: Int32 /* System.Int32 */, _ milliseconds: Int32 /* System.Int32 */, _ microseconds: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Create_4(days, hours, minutes, seconds, milliseconds, microseconds, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var ticks: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Ticks_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var days: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Days_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var hours: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Hours_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var milliseconds: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Milliseconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var microseconds: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Microseconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var nanoseconds: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Nanoseconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var minutes: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Minutes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var seconds: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Seconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalDays: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalDays_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalHours: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalHours_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalMilliseconds: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalMilliseconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalMicroseconds: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalMicroseconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalNanoseconds: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalNanoseconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalMinutes: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalMinutes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalSeconds: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_TotalSeconds_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var zero: System_TimeSpan /* System.TimeSpan */ { get {
		
		
		let __returnValueC = System_TimeSpan_Zero_Get()
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_TimeSpan /* System.TimeSpan */ { get {
		
		
		let __returnValueC = System_TimeSpan_MaxValue_Get()
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var minValue: System_TimeSpan /* System.TimeSpan */ { get {
		
		
		let __returnValueC = System_TimeSpan_MinValue_Get()
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var nanosecondsPerTick: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_NanosecondsPerTick_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var ticksPerMicrosecond: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_TicksPerMicrosecond_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var ticksPerMillisecond: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_TicksPerMillisecond_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var ticksPerSecond: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_TicksPerSecond_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var ticksPerMinute: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_TicksPerMinute_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var ticksPerHour: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_TicksPerHour_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var ticksPerDay: Int64 /* System.Int64 */ { get {
		
		
		let __returnValueC = System_TimeSpan_TicksPerDay_Get()
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeSpan_Create_5(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TimeSpan_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_TimeSpan_Destroy(self.__handle)
		
	}
	
	
}











public class System_String_Array /* System.String[] */: System_Array {
	public override class var typeName: String { get {
		"String[]"
	}}

	public override class var fullTypeName: String { get {
		"System.String[]"
	}}

	
}















public class System_DateOnly /* System.DateOnly */: System_ValueType {
	public override class var typeName: String { get {
		"DateOnly"
	}}

	public override class var fullTypeName: String { get {
		"System.DateOnly"
	}}

	public class func fromDayNumber(_ dayNumber: Int32 /* System.Int32 */) throws -> System_DateOnly /* System.DateOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_FromDayNumber(dayNumber, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addDays(_ value: Int32 /* System.Int32 */) throws -> System_DateOnly /* System.DateOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_AddDays(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMonths(_ value: Int32 /* System.Int32 */) throws -> System_DateOnly /* System.DateOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_AddMonths(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addYears(_ value: Int32 /* System.Int32 */) throws -> System_DateOnly /* System.DateOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_AddYears(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func deconstruct(_ year: inout Int32 /* System.Int32 */, _ month: inout Int32 /* System.Int32 */, _ day: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_DateOnly_Deconstruct(self.__handle, &year, &month, &day, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func toDateTime(_ time: System_TimeOnly /* System.TimeOnly */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToDateTime(self.__handle, timeC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toDateTime(_ time: System_TimeOnly /* System.TimeOnly */, _ kind: System_DateTimeKind /* System.DateTimeKind */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToDateTime_1(self.__handle, timeC, kindC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromDateTime(_ dateTime: System_DateTime /* System.DateTime */) throws -> System_DateOnly /* System.DateOnly */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_FromDateTime(dateTimeC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func compareTo(_ value: System_DateOnly /* System.DateOnly */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ value: System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Equals_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Parse(sC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Parse_1(sC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ format: System_String /* System.String */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		let formatC = format.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ParseExact(sC, formatC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ format: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		let formatC = format.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ParseExact_1(sC, formatC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		let formatsC = formats.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ParseExact_2(sC, formatsC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		let formatsC = formats.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ParseExact_3(sC, formatsC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParse_1(sC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ format: System_String? /* System.String */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatC = format?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParseExact(sC, formatC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatC = format?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParseExact_1(sC, formatC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatsC = formats?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParseExact_2(sC, formatsC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatsC = formats?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParseExact_3(sC, formatsC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toLongDateString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToLongDateString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toShortDateString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToShortDateString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToString_2(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateOnly /* System.DateOnly */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Parse_2(sC, providerC, &__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_DateOnly /* System.DateOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_TryParse_2(sC, providerC, &resultC, &__exceptionC)
		
		result = System_DateOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Create(year, month, day, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */) throws {
		let calendarC = calendar.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Create_1(year, month, day, calendarC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var minValue: System_DateOnly /* System.DateOnly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_MinValue_Get(&__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_DateOnly /* System.DateOnly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_MaxValue_Get(&__exceptionC)
		
		let __returnValue = System_DateOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var year: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Year_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var month: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Month_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var day: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Day_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var dayOfWeek: System_DayOfWeek /* System.DayOfWeek */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_DayOfWeek_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DayOfWeek(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dayOfYear: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_DayOfYear_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var dayNumber: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_DayNumber_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateOnly_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_DateOnly_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_DateOnly_Destroy(self.__handle)
		
	}
	
	
}











public class System_TimeOnly /* System.TimeOnly */: System_ValueType {
	public override class var typeName: String { get {
		"TimeOnly"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeOnly"
	}}

	public func add(_ value: System_TimeSpan /* System.TimeSpan */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Add(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func add(_ value: System_TimeSpan /* System.TimeSpan */, _ wrappedDays: inout Int32 /* System.Int32 */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Add_1(self.__handle, valueC, &wrappedDays, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addHours(_ value: Double /* System.Double */) throws -> System_TimeOnly /* System.TimeOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_AddHours(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addHours(_ value: Double /* System.Double */, _ wrappedDays: inout Int32 /* System.Int32 */) throws -> System_TimeOnly /* System.TimeOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_AddHours_1(self.__handle, value, &wrappedDays, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMinutes(_ value: Double /* System.Double */) throws -> System_TimeOnly /* System.TimeOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_AddMinutes(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMinutes(_ value: Double /* System.Double */, _ wrappedDays: inout Int32 /* System.Int32 */) throws -> System_TimeOnly /* System.TimeOnly */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_AddMinutes_1(self.__handle, value, &wrappedDays, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isBetween(_ start: System_TimeOnly /* System.TimeOnly */, _ end: System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let startC = start.__handle
		let endC = end.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_IsBetween(self.__handle, startC, endC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func deconstruct(_ hour: inout Int32 /* System.Int32 */, _ minute: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_TimeOnly_Deconstruct(self.__handle, &hour, &minute, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func deconstruct(_ hour: inout Int32 /* System.Int32 */, _ minute: inout Int32 /* System.Int32 */, _ second: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_TimeOnly_Deconstruct_1(self.__handle, &hour, &minute, &second, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func deconstruct(_ hour: inout Int32 /* System.Int32 */, _ minute: inout Int32 /* System.Int32 */, _ second: inout Int32 /* System.Int32 */, _ millisecond: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_TimeOnly_Deconstruct_2(self.__handle, &hour, &minute, &second, &millisecond, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func deconstruct(_ hour: inout Int32 /* System.Int32 */, _ minute: inout Int32 /* System.Int32 */, _ second: inout Int32 /* System.Int32 */, _ millisecond: inout Int32 /* System.Int32 */, _ microsecond: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_TimeOnly_Deconstruct_3(self.__handle, &hour, &minute, &second, &millisecond, &microsecond, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func fromTimeSpan(_ timeSpan: System_TimeSpan /* System.TimeSpan */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let timeSpanC = timeSpan.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_FromTimeSpan(timeSpanC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromDateTime(_ dateTime: System_DateTime /* System.DateTime */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_FromDateTime(dateTimeC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toTimeSpan() throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToTimeSpan(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func compareTo(_ value: System_TimeOnly /* System.TimeOnly */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ value: System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Equals_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Parse(sC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Parse_1(sC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ format: System_String /* System.String */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		let formatC = format.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ParseExact(sC, formatC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ format: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		let formatC = format.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ParseExact_1(sC, formatC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		let formatsC = formats.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ParseExact_2(sC, formatsC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ s: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		let formatsC = formats.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ParseExact_3(sC, formatsC, providerC, styleC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParse_1(sC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ format: System_String? /* System.String */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatC = format?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParseExact(sC, formatC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatC = format?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParseExact_1(sC, formatC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatsC = formats?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParseExact_2(sC, formatsC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ s: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ style: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let formatsC = formats?.__handle
		let providerC = provider?.__handle
		let styleC = style.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParseExact_3(sC, formatsC, providerC, styleC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toLongTimeString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToLongTimeString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toShortTimeString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToShortTimeString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToString_2(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_TimeOnly /* System.TimeOnly */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Parse_2(sC, providerC, &__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_TimeOnly /* System.TimeOnly */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_TryParse_2(sC, providerC, &resultC, &__exceptionC)
		
		result = System_TimeOnly(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Create(hour, minute, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Create_1(hour, minute, second, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Create_2(hour, minute, second, millisecond, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Create_3(hour, minute, second, millisecond, microsecond, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ ticks: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Create_4(ticks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var minValue: System_TimeOnly /* System.TimeOnly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_MinValue_Get(&__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_TimeOnly /* System.TimeOnly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_MaxValue_Get(&__exceptionC)
		
		let __returnValue = System_TimeOnly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var hour: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Hour_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var minute: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Minute_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var second: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Second_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var millisecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Millisecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var microsecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Microsecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var nanosecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Nanosecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var ticks: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Ticks_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeOnly_Create_5(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TimeOnly_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_TimeOnly_Destroy(self.__handle)
		
	}
	
	
}











public class System_Globalization_Calendar /* System.Globalization.Calendar */: System_Object {
	public override class var typeName: String { get {
		"Calendar"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.Calendar"
	}}

	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readOnly(_ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */) throws -> System_Globalization_Calendar /* System.Globalization.Calendar */ {
		let calendarC = calendar.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_ReadOnly(calendarC, &__exceptionC)
		
		let __returnValue = System_Globalization_Calendar(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMilliseconds(_ time: System_DateTime /* System.DateTime */, _ milliseconds: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddMilliseconds(self.__handle, timeC, milliseconds, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addDays(_ time: System_DateTime /* System.DateTime */, _ days: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddDays(self.__handle, timeC, days, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addHours(_ time: System_DateTime /* System.DateTime */, _ hours: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddHours(self.__handle, timeC, hours, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMinutes(_ time: System_DateTime /* System.DateTime */, _ minutes: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddMinutes(self.__handle, timeC, minutes, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMonths(_ time: System_DateTime /* System.DateTime */, _ months: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddMonths(self.__handle, timeC, months, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addSeconds(_ time: System_DateTime /* System.DateTime */, _ seconds: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddSeconds(self.__handle, timeC, seconds, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addWeeks(_ time: System_DateTime /* System.DateTime */, _ weeks: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddWeeks(self.__handle, timeC, weeks, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addYears(_ time: System_DateTime /* System.DateTime */, _ years: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AddYears(self.__handle, timeC, years, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDayOfMonth(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDayOfMonth(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDayOfWeek(_ time: System_DateTime /* System.DateTime */) throws -> System_DayOfWeek /* System.DayOfWeek */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDayOfWeek(self.__handle, timeC, &__exceptionC)
		
		let __returnValue = System_DayOfWeek(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDayOfYear(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDayOfYear(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDaysInMonth(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDaysInMonth(self.__handle, year, month, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDaysInMonth(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDaysInMonth_1(self.__handle, year, month, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDaysInYear(_ year: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDaysInYear(self.__handle, year, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDaysInYear(_ year: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetDaysInYear_1(self.__handle, year, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getEra(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetEra(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHour(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetHour(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getMilliseconds(_ time: System_DateTime /* System.DateTime */) throws -> Double /* System.Double */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetMilliseconds(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getMinute(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetMinute(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getMonth(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetMonth(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getMonthsInYear(_ year: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetMonthsInYear(self.__handle, year, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getMonthsInYear(_ year: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetMonthsInYear_1(self.__handle, year, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getSecond(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetSecond(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getWeekOfYear(_ time: System_DateTime /* System.DateTime */, _ rule: System_Globalization_CalendarWeekRule /* System.Globalization.CalendarWeekRule */, _ firstDayOfWeek: System_DayOfWeek /* System.DayOfWeek */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		let ruleC = rule.cValue
		let firstDayOfWeekC = firstDayOfWeek.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetWeekOfYear(self.__handle, timeC, ruleC, firstDayOfWeekC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getYear(_ time: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let timeC = time.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetYear(self.__handle, timeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isLeapDay(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsLeapDay(self.__handle, year, month, day, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isLeapDay(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsLeapDay_1(self.__handle, year, month, day, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isLeapMonth(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsLeapMonth(self.__handle, year, month, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isLeapMonth(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsLeapMonth_1(self.__handle, year, month, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getLeapMonth(_ year: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetLeapMonth(self.__handle, year, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getLeapMonth(_ year: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_GetLeapMonth_1(self.__handle, year, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isLeapYear(_ year: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsLeapYear(self.__handle, year, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isLeapYear(_ year: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsLeapYear_1(self.__handle, year, era, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toDateTime(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_ToDateTime(self.__handle, year, month, day, hour, minute, second, millisecond, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toDateTime(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ era: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_ToDateTime_1(self.__handle, year, month, day, hour, minute, second, millisecond, era, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toFourDigitYear(_ year: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_ToFourDigitYear(self.__handle, year, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var minSupportedDateTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_MinSupportedDateTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var maxSupportedDateTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_MaxSupportedDateTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var algorithmType: System_Globalization_CalendarAlgorithmType /* System.Globalization.CalendarAlgorithmType */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_AlgorithmType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CalendarAlgorithmType(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var eras: System_Int32_Array /* System.Int32[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_Eras_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Int32_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var twoDigitYearMax: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_Calendar_TwoDigitYearMax_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func twoDigitYearMax_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_Calendar_TwoDigitYearMax_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var currentEra: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = System_Globalization_Calendar_CurrentEra_Get()
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_Calendar_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_Calendar_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_IFormatterConverter /* System.Runtime.Serialization.IFormatterConverter */: DNObject {
	public override class var typeName: String { get {
		"IFormatterConverter"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.IFormatterConverter"
	}}

	public func convert(_ value: System_Object /* System.Object */, _ type: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let valueC = value.__handle
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_Convert(self.__handle, valueC, typeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func convert(_ value: System_Object /* System.Object */, _ typeCode: System_TypeCode /* System.TypeCode */) throws -> System_Object /* System.Object */ {
		let valueC = value.__handle
		let typeCodeC = typeCode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_Convert_1(self.__handle, valueC, typeCodeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toBoolean(_ value: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToBoolean(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toChar(_ value: System_Object /* System.Object */) throws -> DNChar /* System.Char */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToChar(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toSByte(_ value: System_Object /* System.Object */) throws -> Int8 /* System.SByte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToSByte(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toByte(_ value: System_Object /* System.Object */) throws -> UInt8 /* System.Byte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToByte(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toInt16(_ value: System_Object /* System.Object */) throws -> Int16 /* System.Int16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToInt16(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUInt16(_ value: System_Object /* System.Object */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToUInt16(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toInt32(_ value: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToInt32(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUInt32(_ value: System_Object /* System.Object */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToUInt32(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toInt64(_ value: System_Object /* System.Object */) throws -> Int64 /* System.Int64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToInt64(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUInt64(_ value: System_Object /* System.Object */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToUInt64(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toSingle(_ value: System_Object /* System.Object */) throws -> Float /* System.Single */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToSingle(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toDouble(_ value: System_Object /* System.Object */) throws -> Double /* System.Double */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToDouble(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toDecimal(_ value: System_Object /* System.Object */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToDecimal(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toDateTime(_ value: System_Object /* System.Object */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToDateTime(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ value: System_Object /* System.Object */) throws -> System_String? /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IFormatterConverter_ToString(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_IFormatterConverter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_IFormatterConverter_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */: System_ValueType {
	public override class var typeName: String { get {
		"StreamingContext"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.StreamingContext"
	}}

	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ state: System_Runtime_Serialization_StreamingContextStates /* System.Runtime.Serialization.StreamingContextStates */) throws {
		let stateC = state.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_Create(stateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ state: System_Runtime_Serialization_StreamingContextStates /* System.Runtime.Serialization.StreamingContextStates */, _ additional: System_Object? /* System.Object */) throws {
		let stateC = state.cValue
		let additionalC = additional?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_Create_1(stateC, additionalC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var state: System_Runtime_Serialization_StreamingContextStates /* System.Runtime.Serialization.StreamingContextStates */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_State_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_Serialization_StreamingContextStates(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var context: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_Context_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_StreamingContext_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_StreamingContext_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_StreamingContext_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_AssemblyName /* System.Reflection.AssemblyName */: System_Object {
	public override class var typeName: String { get {
		"AssemblyName"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.AssemblyName"
	}}

	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getAssemblyName(_ assemblyFile: System_String /* System.String */) throws -> System_Reflection_AssemblyName /* System.Reflection.AssemblyName */ {
		let assemblyFileC = assemblyFile.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_GetAssemblyName(assemblyFileC, &__exceptionC)
		
		let __returnValue = System_Reflection_AssemblyName(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getPublicKey() throws -> System_Byte_Array? /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_GetPublicKey(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setPublicKey(_ publicKey: System_Byte_Array? /* System.Byte[] */) throws {
		let publicKeyC = publicKey?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_SetPublicKey(self.__handle, publicKeyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getPublicKeyToken() throws -> System_Byte_Array? /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_GetPublicKeyToken(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setPublicKeyToken(_ publicKeyToken: System_Byte_Array? /* System.Byte[] */) throws {
		let publicKeyTokenC = publicKeyToken?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_SetPublicKeyToken(self.__handle, publicKeyTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func onDeserialization(_ sender: System_Object? /* System.Object */) throws {
		let senderC = sender?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_OnDeserialization(self.__handle, senderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func referenceMatchesDefinition(_ reference: System_Reflection_AssemblyName? /* System.Reflection.AssemblyName */, _ definition: System_Reflection_AssemblyName? /* System.Reflection.AssemblyName */) throws -> Bool /* System.Boolean */ {
		let referenceC = reference?.__handle
		let definitionC = definition?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_ReferenceMatchesDefinition(referenceC, definitionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ assemblyName: System_String /* System.String */) throws {
		let assemblyNameC = assemblyName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_Create(assemblyNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var name: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func name_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_Name_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var version: System_Version? /* System.Version */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_Version_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Version(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func version_set(_ value: System_Version? /* System.Version */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_Version_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var cultureInfo: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_CultureInfo_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func cultureInfo_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_CultureInfo_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var cultureName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_CultureName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func cultureName_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_CultureName_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var codeBase: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_CodeBase_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func codeBase_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_CodeBase_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var escapedCodeBase: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_EscapedCodeBase_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var processorArchitecture: System_Reflection_ProcessorArchitecture /* System.Reflection.ProcessorArchitecture */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_ProcessorArchitecture_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ProcessorArchitecture(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func processorArchitecture_set(_ value: System_Reflection_ProcessorArchitecture /* System.Reflection.ProcessorArchitecture */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_ProcessorArchitecture_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var contentType: System_Reflection_AssemblyContentType /* System.Reflection.AssemblyContentType */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_ContentType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_AssemblyContentType(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func contentType_set(_ value: System_Reflection_AssemblyContentType /* System.Reflection.AssemblyContentType */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_ContentType_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var flags: System_Reflection_AssemblyNameFlags /* System.Reflection.AssemblyNameFlags */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_Flags_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_AssemblyNameFlags(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func flags_set(_ value: System_Reflection_AssemblyNameFlags /* System.Reflection.AssemblyNameFlags */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_Flags_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var hashAlgorithm: System_Configuration_Assemblies_AssemblyHashAlgorithm /* System.Configuration.Assemblies.AssemblyHashAlgorithm */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_HashAlgorithm_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Configuration_Assemblies_AssemblyHashAlgorithm(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func hashAlgorithm_set(_ value: System_Configuration_Assemblies_AssemblyHashAlgorithm /* System.Configuration.Assemblies.AssemblyHashAlgorithm */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_HashAlgorithm_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var versionCompatibility: System_Configuration_Assemblies_AssemblyVersionCompatibility /* System.Configuration.Assemblies.AssemblyVersionCompatibility */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_VersionCompatibility_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Configuration_Assemblies_AssemblyVersionCompatibility(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func versionCompatibility_set(_ value: System_Configuration_Assemblies_AssemblyVersionCompatibility /* System.Configuration.Assemblies.AssemblyVersionCompatibility */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_VersionCompatibility_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var keyPair: System_Reflection_StrongNameKeyPair? /* System.Reflection.StrongNameKeyPair */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_KeyPair_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_StrongNameKeyPair(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func keyPair_set(_ value: System_Reflection_StrongNameKeyPair? /* System.Reflection.StrongNameKeyPair */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_AssemblyName_KeyPair_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var fullName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_AssemblyName_FullName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_AssemblyName_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_AssemblyName_Destroy(self.__handle)
		
	}
	
	
}


public class System_Version /* System.Version */: System_Object {
	public override class var typeName: String { get {
		"Version"
	}}

	public override class var fullTypeName: String { get {
		"System.Version"
	}}

	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func compareTo(_ version: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let versionC = version?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_CompareTo(self.__handle, versionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Version? /* System.Version */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ obj: System_Version? /* System.Version */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Equals_1(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ fieldCount: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_ToString_1(self.__handle, fieldCount, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ input: System_String /* System.String */) throws -> System_Version /* System.Version */ {
		let inputC = input.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Parse(inputC, &__exceptionC)
		
		let __returnValue = System_Version(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ input: System_String? /* System.String */, _ result: inout System_Version? /* System.Version */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_TryParse(inputC, &resultC, &__exceptionC)
		
		result = System_Version(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ major: Int32 /* System.Int32 */, _ minor: Int32 /* System.Int32 */, _ build: Int32 /* System.Int32 */, _ revision: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Create(major, minor, build, revision, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ major: Int32 /* System.Int32 */, _ minor: Int32 /* System.Int32 */, _ build: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Create_1(major, minor, build, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ major: Int32 /* System.Int32 */, _ minor: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Create_2(major, minor, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ version: System_String /* System.String */) throws {
		let versionC = version.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Create_3(versionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Create_4(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var major: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Major_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var minor: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Minor_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var build: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Build_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var revision: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_Revision_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var majorRevision: Int16 /* System.Int16 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_MajorRevision_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var minorRevision: Int16 /* System.Int16 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Version_MinorRevision_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Version_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Version_Destroy(self.__handle)
		
	}
	
	
}







public class System_Reflection_StrongNameKeyPair /* System.Reflection.StrongNameKeyPair */: System_Object {
	public override class var typeName: String { get {
		"StrongNameKeyPair"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.StrongNameKeyPair"
	}}

	public convenience init(_ keyPairFile: System_IO_FileStream /* System.IO.FileStream */) throws {
		let keyPairFileC = keyPairFile.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_StrongNameKeyPair_Create(keyPairFileC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ keyPairArray: System_Byte_Array /* System.Byte[] */) throws {
		let keyPairArrayC = keyPairArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_StrongNameKeyPair_Create_1(keyPairArrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ keyPairContainer: System_String /* System.String */) throws {
		let keyPairContainerC = keyPairContainer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_StrongNameKeyPair_Create_2(keyPairContainerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var publicKey: System_Byte_Array /* System.Byte[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_StrongNameKeyPair_PublicKey_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_StrongNameKeyPair_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_StrongNameKeyPair_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_FileStream /* System.IO.FileStream */: System_IO_Stream {
	public override class var typeName: String { get {
		"FileStream"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileStream"
	}}

	public func lock(_ position: Int64 /* System.Int64 */, _ length: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Lock(self.__handle, position, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unlock(_ position: Int64 /* System.Int64 */, _ length: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Unlock(self.__handle, position, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func flushAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_FlushAsync(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func read(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Read(self.__handle, bufferC, offset, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func readAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_ReadAsync(self.__handle, bufferC, offset, count, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func write(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Write(self.__handle, bufferC, offset, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ buffer: Data? /* System.ReadOnlySpan<System.Byte> */) throws {
		let bufferC = buffer.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Write_1(self.__handle, bufferC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_WriteAsync(self.__handle, bufferC, offset, count, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func flush() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Flush_1(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func flush(_ flushToDisk: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Flush_2(self.__handle, flushToDisk, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func setLength(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_SetLength(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func readByte() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_ReadByte(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func writeByte(_ value: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_WriteByte(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func copyTo(_ destination: System_IO_Stream /* System.IO.Stream */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_CopyTo(self.__handle, destinationC, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func copyToAsync(_ destination: System_IO_Stream /* System.IO.Stream */, _ bufferSize: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let destinationC = destination.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_CopyToAsync(self.__handle, destinationC, bufferSize, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func beginRead(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ callback: System_AsyncCallback? /* System.AsyncCallback */, _ state: System_Object? /* System.Object */) throws -> System_IAsyncResult /* System.IAsyncResult */ {
		let bufferC = buffer.__handle
		let callbackC = callback?.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_BeginRead(self.__handle, bufferC, offset, count, callbackC, stateC, &__exceptionC)
		
		let __returnValue = System_IAsyncResult(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func endRead(_ asyncResult: System_IAsyncResult /* System.IAsyncResult */) throws -> Int32 /* System.Int32 */ {
		let asyncResultC = asyncResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_EndRead(self.__handle, asyncResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func beginWrite(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ callback: System_AsyncCallback? /* System.AsyncCallback */, _ state: System_Object? /* System.Object */) throws -> System_IAsyncResult /* System.IAsyncResult */ {
		let bufferC = buffer.__handle
		let callbackC = callback?.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_BeginWrite(self.__handle, bufferC, offset, count, callbackC, stateC, &__exceptionC)
		
		let __returnValue = System_IAsyncResult(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func endWrite(_ asyncResult: System_IAsyncResult /* System.IAsyncResult */) throws {
		let asyncResultC = asyncResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_EndWrite(self.__handle, asyncResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func seek(_ offset: Int64 /* System.Int64 */, _ origin: System_IO_SeekOrigin /* System.IO.SeekOrigin */) throws -> Int64 /* System.Int64 */ {
		let originC = origin.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Seek(self.__handle, offset, originC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ handle: UnsafeMutableRawPointer? /* System.IntPtr */, _ access: System_IO_FileAccess /* System.IO.FileAccess */) throws {
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create(handle, accessC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ handle: UnsafeMutableRawPointer? /* System.IntPtr */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ ownsHandle: Bool /* System.Boolean */) throws {
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_1(handle, accessC, ownsHandle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ handle: UnsafeMutableRawPointer? /* System.IntPtr */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ ownsHandle: Bool /* System.Boolean */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_2(handle, accessC, ownsHandle, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ handle: UnsafeMutableRawPointer? /* System.IntPtr */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ ownsHandle: Bool /* System.Boolean */, _ bufferSize: Int32 /* System.Int32 */, _ isAsync: Bool /* System.Boolean */) throws {
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_3(handle, accessC, ownsHandle, bufferSize, isAsync, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ handle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ access: System_IO_FileAccess /* System.IO.FileAccess */) throws {
		let handleC = handle.__handle
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_4(handleC, accessC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ handle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let handleC = handle.__handle
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_5(handleC, accessC, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ handle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ bufferSize: Int32 /* System.Int32 */, _ isAsync: Bool /* System.Boolean */) throws {
		let handleC = handle.__handle
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_6(handleC, accessC, bufferSize, isAsync, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_7(pathC, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_8(pathC, modeC, accessC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_9(pathC, modeC, accessC, shareC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_10(pathC, modeC, accessC, shareC, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */, _ bufferSize: Int32 /* System.Int32 */, _ useAsync: Bool /* System.Boolean */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_11(pathC, modeC, accessC, shareC, bufferSize, useAsync, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */, _ bufferSize: Int32 /* System.Int32 */, _ options: System_IO_FileOptions /* System.IO.FileOptions */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_12(pathC, modeC, accessC, shareC, bufferSize, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws {
		let pathC = path.__handle
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Create_13(pathC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var handle: UnsafeMutableRawPointer? /* System.IntPtr */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Handle_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var canRead: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_CanRead_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var canWrite: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_CanWrite_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var safeFileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_SafeFileHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = Microsoft_Win32_SafeHandles_SafeFileHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isAsync: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_IsAsync_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var length: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var position: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_Position_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public override func position_set(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStream_Position_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override var canSeek: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStream_CanSeek_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileStream_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_FileStream_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_Stream /* System.IO.Stream */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"Stream"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.Stream"
	}}

	public func copyTo(_ destination: System_IO_Stream /* System.IO.Stream */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_CopyTo(self.__handle, destinationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyTo(_ destination: System_IO_Stream /* System.IO.Stream */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_CopyTo_1(self.__handle, destinationC, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyToAsync(_ destination: System_IO_Stream /* System.IO.Stream */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CopyToAsync(self.__handle, destinationC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyToAsync(_ destination: System_IO_Stream /* System.IO.Stream */, _ bufferSize: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CopyToAsync_1(self.__handle, destinationC, bufferSize, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyToAsync(_ destination: System_IO_Stream /* System.IO.Stream */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let destinationC = destination.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CopyToAsync_2(self.__handle, destinationC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyToAsync(_ destination: System_IO_Stream /* System.IO.Stream */, _ bufferSize: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let destinationC = destination.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CopyToAsync_3(self.__handle, destinationC, bufferSize, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func flush() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_Flush(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func flushAsync() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_FlushAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func flushAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_FlushAsync_1(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func beginRead(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ callback: System_AsyncCallback? /* System.AsyncCallback */, _ state: System_Object? /* System.Object */) throws -> System_IAsyncResult /* System.IAsyncResult */ {
		let bufferC = buffer.__handle
		let callbackC = callback?.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_BeginRead(self.__handle, bufferC, offset, count, callbackC, stateC, &__exceptionC)
		
		let __returnValue = System_IAsyncResult(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func endRead(_ asyncResult: System_IAsyncResult /* System.IAsyncResult */) throws -> Int32 /* System.Int32 */ {
		let asyncResultC = asyncResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_EndRead(self.__handle, asyncResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func readAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_ReadAsync(self.__handle, bufferC, offset, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_ReadAsync_1(self.__handle, bufferC, offset, count, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readExactlyAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		let bufferC = buffer.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_ReadExactlyAsync(self.__handle, bufferC, offset, count, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func beginWrite(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ callback: System_AsyncCallback? /* System.AsyncCallback */, _ state: System_Object? /* System.Object */) throws -> System_IAsyncResult /* System.IAsyncResult */ {
		let bufferC = buffer.__handle
		let callbackC = callback?.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_BeginWrite(self.__handle, bufferC, offset, count, callbackC, stateC, &__exceptionC)
		
		let __returnValue = System_IAsyncResult(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func endWrite(_ asyncResult: System_IAsyncResult /* System.IAsyncResult */) throws {
		let asyncResultC = asyncResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_EndWrite(self.__handle, asyncResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_WriteAsync(self.__handle, bufferC, offset, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeAsync(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_WriteAsync_1(self.__handle, bufferC, offset, count, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func seek(_ offset: Int64 /* System.Int64 */, _ origin: System_IO_SeekOrigin /* System.IO.SeekOrigin */) throws -> Int64 /* System.Int64 */ {
		let originC = origin.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_Seek(self.__handle, offset, originC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func setLength(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_SetLength(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func read(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_Read_1(self.__handle, bufferC, offset, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func readByte() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_ReadByte(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func readExactly(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_ReadExactly_1(self.__handle, bufferC, offset, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ buffer: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_Write_1(self.__handle, bufferC, offset, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ buffer: Data? /* System.ReadOnlySpan<System.Byte> */) throws {
		let bufferC = buffer.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_Write_2(self.__handle, bufferC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeByte(_ value: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_WriteByte(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func synchronized(_ stream: System_IO_Stream /* System.IO.Stream */) throws -> System_IO_Stream /* System.IO.Stream */ {
		let streamC = stream.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_Synchronized(streamC, &__exceptionC)
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var canRead: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CanRead_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var canWrite: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CanWrite_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var canSeek: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CanSeek_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var canTimeout: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_CanTimeout_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var length: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var position: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_Position_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func position_set(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_Position_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var readTimeout: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_ReadTimeout_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func readTimeout_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_ReadTimeout_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var writeTimeout: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Stream_WriteTimeout_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func writeTimeout_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Stream_WriteTimeout_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var null: System_IO_Stream /* System.IO.Stream */ { get {
		
		
		let __returnValueC = System_IO_Stream_Null_Get()
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_Stream_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_Stream_Destroy(self.__handle)
		
	}
	
	
}


public class System_MarshalByRefObject /* System.MarshalByRefObject */: System_Object {
	public override class var typeName: String { get {
		"MarshalByRefObject"
	}}

	public override class var fullTypeName: String { get {
		"System.MarshalByRefObject"
	}}

	public func getLifetimeService() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_MarshalByRefObject_GetLifetimeService(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func initializeLifetimeService() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_MarshalByRefObject_InitializeLifetimeService(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_MarshalByRefObject_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_MarshalByRefObject_Destroy(self.__handle)
		
	}
	
	
}


public class System_IAsyncDisposable /* System.IAsyncDisposable */: DNObject {
	public override class var typeName: String { get {
		"IAsyncDisposable"
	}}

	public override class var fullTypeName: String { get {
		"System.IAsyncDisposable"
	}}

	public func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IAsyncDisposable_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IAsyncDisposable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IAsyncDisposable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */: System_ValueType {
	public override class var typeName: String { get {
		"ValueTask"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.ValueTask"
	}}

	public class func fromCanceled(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_FromCanceled(cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromException(_ exception: System_Exception /* System.Exception */) throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		let exceptionC = exception.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_FromException(exceptionC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func asTask() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_AsTask(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func preserve() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_Preserve(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAwaiter() throws -> System_Runtime_CompilerServices_ValueTaskAwaiter /* System.Runtime.CompilerServices.ValueTaskAwaiter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_GetAwaiter(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_ValueTaskAwaiter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func configureAwait(_ continueOnCapturedContext: Bool /* System.Boolean */) throws -> System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable /* System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_ConfigureAwait(self.__handle, continueOnCapturedContext, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ task: System_Threading_Tasks_Task /* System.Threading.Tasks.Task */) throws {
		let taskC = task.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_Create(taskC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ source: System_Threading_Tasks_Sources_IValueTaskSource /* System.Threading.Tasks.Sources.IValueTaskSource */, _ token: Int16 /* System.Int16 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_Create_1(sourceC, token, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var completedTask: System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_CompletedTask_Get(&__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isCompletedSuccessfully: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_IsCompletedSuccessfully_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFaulted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_IsFaulted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isCanceled: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_IsCanceled_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_ValueTask_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_ValueTask_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_ValueTask_Destroy(self.__handle)
		
	}
	
	
}




// Type "TResult" was skipped. Reason: It has no full name.
public class System_Threading_CancellationToken /* System.Threading.CancellationToken */: System_ValueType {
	public override class var typeName: String { get {
		"CancellationToken"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.CancellationToken"
	}}

	public func register(_ callback: System_Action /* System.Action */) throws -> System_Threading_CancellationTokenRegistration /* System.Threading.CancellationTokenRegistration */ {
		let callbackC = callback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_Register(self.__handle, callbackC, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationTokenRegistration(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func register(_ callback: System_Action /* System.Action */, _ useSynchronizationContext: Bool /* System.Boolean */) throws -> System_Threading_CancellationTokenRegistration /* System.Threading.CancellationTokenRegistration */ {
		let callbackC = callback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_Register_1(self.__handle, callbackC, useSynchronizationContext, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationTokenRegistration(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func equals(_ other: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_Equals(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ other: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func throwIfCancellationRequested() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationToken_ThrowIfCancellationRequested(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ canceled: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_Create(canceled, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var none: System_Threading_CancellationToken /* System.Threading.CancellationToken */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_None_Get(&__exceptionC)
		
		let __returnValue = System_Threading_CancellationToken(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isCancellationRequested: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_IsCancellationRequested_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var canBeCanceled: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_CanBeCanceled_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var waitHandle: System_Threading_WaitHandle /* System.Threading.WaitHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_WaitHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_WaitHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationToken_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_CancellationToken_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_CancellationToken_Destroy(self.__handle)
		
	}
	
	
}




public class System_Threading_WaitHandle /* System.Threading.WaitHandle */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"WaitHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.WaitHandle"
	}}

	public func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_WaitHandle_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_WaitHandle_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func waitOne(_ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitOne(self.__handle, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func waitOne(_ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitOne_1(self.__handle, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func waitOne() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitOne_2(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func waitOne(_ millisecondsTimeout: Int32 /* System.Int32 */, _ exitContext: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitOne_3(self.__handle, millisecondsTimeout, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func waitOne(_ timeout: System_TimeSpan /* System.TimeSpan */, _ exitContext: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitOne_4(self.__handle, timeoutC, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let waitHandlesC = waitHandles.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAll(waitHandlesC, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let waitHandlesC = waitHandles.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAll_1(waitHandlesC, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */) throws -> Bool /* System.Boolean */ {
		let waitHandlesC = waitHandles.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAll_2(waitHandlesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ millisecondsTimeout: Int32 /* System.Int32 */, _ exitContext: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let waitHandlesC = waitHandles.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAll_3(waitHandlesC, millisecondsTimeout, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ timeout: System_TimeSpan /* System.TimeSpan */, _ exitContext: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let waitHandlesC = waitHandles.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAll_4(waitHandlesC, timeoutC, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let waitHandlesC = waitHandles.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAny(waitHandlesC, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Int32 /* System.Int32 */ {
		let waitHandlesC = waitHandles.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAny_1(waitHandlesC, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */) throws -> Int32 /* System.Int32 */ {
		let waitHandlesC = waitHandles.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAny_2(waitHandlesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ millisecondsTimeout: Int32 /* System.Int32 */, _ exitContext: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let waitHandlesC = waitHandles.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAny_3(waitHandlesC, millisecondsTimeout, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ waitHandles: System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */, _ timeout: System_TimeSpan /* System.TimeSpan */, _ exitContext: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let waitHandlesC = waitHandles.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_WaitAny_4(waitHandlesC, timeoutC, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func signalAndWait(_ toSignal: System_Threading_WaitHandle /* System.Threading.WaitHandle */, _ toWaitOn: System_Threading_WaitHandle /* System.Threading.WaitHandle */) throws -> Bool /* System.Boolean */ {
		let toSignalC = toSignal.__handle
		let toWaitOnC = toWaitOn.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_SignalAndWait(toSignalC, toWaitOnC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func signalAndWait(_ toSignal: System_Threading_WaitHandle /* System.Threading.WaitHandle */, _ toWaitOn: System_Threading_WaitHandle /* System.Threading.WaitHandle */, _ timeout: System_TimeSpan /* System.TimeSpan */, _ exitContext: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let toSignalC = toSignal.__handle
		let toWaitOnC = toWaitOn.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_SignalAndWait_1(toSignalC, toWaitOnC, timeoutC, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func signalAndWait(_ toSignal: System_Threading_WaitHandle /* System.Threading.WaitHandle */, _ toWaitOn: System_Threading_WaitHandle /* System.Threading.WaitHandle */, _ millisecondsTimeout: Int32 /* System.Int32 */, _ exitContext: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let toSignalC = toSignal.__handle
		let toWaitOnC = toWaitOn.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_SignalAndWait_2(toSignalC, toWaitOnC, millisecondsTimeout, exitContext, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var handle: UnsafeMutableRawPointer? /* System.IntPtr */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_Handle_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func handle_set(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_WaitHandle_Handle_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var safeWaitHandle: Microsoft_Win32_SafeHandles_SafeWaitHandle /* Microsoft.Win32.SafeHandles.SafeWaitHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_WaitHandle_SafeWaitHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = Microsoft_Win32_SafeHandles_SafeWaitHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func safeWaitHandle_set(_ value: Microsoft_Win32_SafeHandles_SafeWaitHandle? /* Microsoft.Win32.SafeHandles.SafeWaitHandle */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_WaitHandle_SafeWaitHandle_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var waitTimeout: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = System_Threading_WaitHandle_WaitTimeout_Get()
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_WaitHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_WaitHandle_Destroy(self.__handle)
		
	}
	
	
}


public class System_IntPtr /* System.IntPtr */: System_ValueType {
	public override class var typeName: String { get {
		"IntPtr"
	}}

	public override class var fullTypeName: String { get {
		"System.IntPtr"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IntPtr_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class Microsoft_Win32_SafeHandles_SafeWaitHandle /* Microsoft.Win32.SafeHandles.SafeWaitHandle */: Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid {
	public override class var typeName: String { get {
		"SafeWaitHandle"
	}}

	public override class var fullTypeName: String { get {
		"Microsoft.Win32.SafeHandles.SafeWaitHandle"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeWaitHandle_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ existingHandle: UnsafeMutableRawPointer? /* System.IntPtr */, _ ownsHandle: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeWaitHandle_Create_1(existingHandle, ownsHandle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Microsoft_Win32_SafeHandles_SafeWaitHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		Microsoft_Win32_SafeHandles_SafeWaitHandle_Destroy(self.__handle)
		
	}
	
	
}


public class Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid /* Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid */: System_Runtime_InteropServices_SafeHandle {
	public override class var typeName: String { get {
		"SafeHandleZeroOrMinusOneIsInvalid"
	}}

	public override class var fullTypeName: String { get {
		"Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"
	}}

	public override var isInvalid: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid_IsInvalid_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid_TypeOf())
		
	}}
	
	internal override func destroy() {
		Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_InteropServices_SafeHandle /* System.Runtime.InteropServices.SafeHandle */: System_Runtime_ConstrainedExecution_CriticalFinalizerObject {
	public override class var typeName: String { get {
		"SafeHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.InteropServices.SafeHandle"
	}}

	public func dangerousGetHandle() throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_SafeHandle_DangerousGetHandle(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_SafeHandle_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_SafeHandle_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setHandleAsInvalid() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dangerousAddRef(_ success: inout Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_SafeHandle_DangerousAddRef(self.__handle, &success, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dangerousRelease() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_SafeHandle_DangerousRelease(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var isClosed: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_SafeHandle_IsClosed_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isInvalid: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_SafeHandle_IsInvalid_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_SafeHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_InteropServices_SafeHandle_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_ConstrainedExecution_CriticalFinalizerObject /* System.Runtime.ConstrainedExecution.CriticalFinalizerObject */: System_Object {
	public override class var typeName: String { get {
		"CriticalFinalizerObject"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.ConstrainedExecution.CriticalFinalizerObject"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_ConstrainedExecution_CriticalFinalizerObject_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_ConstrainedExecution_CriticalFinalizerObject_Destroy(self.__handle)
		
	}
	
	
}



public class System_Threading_WaitHandle_Array /* System.Threading.WaitHandle[] */: System_Array {
	public override class var typeName: String { get {
		"WaitHandle[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.WaitHandle[]"
	}}

	
}















public class System_Threading_CancellationTokenRegistration /* System.Threading.CancellationTokenRegistration */: System_ValueType {
	public override class var typeName: String { get {
		"CancellationTokenRegistration"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.CancellationTokenRegistration"
	}}

	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationTokenRegistration_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func unregister() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_Unregister(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Threading_CancellationTokenRegistration /* System.Threading.CancellationTokenRegistration */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var token: System_Threading_CancellationToken /* System.Threading.CancellationToken */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_Token_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationToken(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenRegistration_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_CancellationTokenRegistration_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_CancellationTokenRegistration_Destroy(self.__handle)
		
	}
	
	
}




public class System_Exception /* System.Exception */: System_Object {
	public override class var typeName: String { get {
		"Exception"
	}}

	public override class var fullTypeName: String { get {
		"System.Exception"
	}}

	public func getBaseException() throws -> System_Exception /* System.Exception */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_GetBaseException(self.__handle, &__exceptionC)
		
		let __returnValue = System_Exception(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Exception_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_GetType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */) throws {
		let messageC = message?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_Create_1(messageC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerException: System_Exception? /* System.Exception */) throws {
		let messageC = message?.__handle
		let innerExceptionC = innerException?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_Create_2(messageC, innerExceptionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var targetSite: System_Reflection_MethodBase? /* System.Reflection.MethodBase */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_TargetSite_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var message: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_Message_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var data: System_Collections_IDictionary /* System.Collections.IDictionary */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_Data_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IDictionary(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var innerException: System_Exception? /* System.Exception */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_InnerException_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Exception(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var helpLink: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_HelpLink_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func helpLink_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Exception_HelpLink_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var source: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_Source_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func source_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Exception_Source_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var hResult: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_HResult_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func hResult_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Exception_HResult_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var stackTrace: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Exception_StackTrace_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Exception_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Exception_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_MethodBase /* System.Reflection.MethodBase */: System_Reflection_MemberInfo {
	public override class var typeName: String { get {
		"MethodBase"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MethodBase"
	}}

	public class func getMethodFromHandle(_ handle: System_RuntimeMethodHandle /* System.RuntimeMethodHandle */) throws -> System_Reflection_MethodBase? /* System.Reflection.MethodBase */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetMethodFromHandle(handleC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getMethodFromHandle(_ handle: System_RuntimeMethodHandle /* System.RuntimeMethodHandle */, _ declaringType: System_RuntimeTypeHandle /* System.RuntimeTypeHandle */) throws -> System_Reflection_MethodBase? /* System.Reflection.MethodBase */ {
		let handleC = handle.__handle
		let declaringTypeC = declaringType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetMethodFromHandle_1(handleC, declaringTypeC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCurrentMethod() throws -> System_Reflection_MethodBase? /* System.Reflection.MethodBase */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetCurrentMethod(&__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getParameters() throws -> System_Reflection_ParameterInfo_Array /* System.Reflection.ParameterInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetParameters(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ParameterInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethodImplementationFlags() throws -> System_Reflection_MethodImplAttributes /* System.Reflection.MethodImplAttributes */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetMethodImplementationFlags(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodImplAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethodBody() throws -> System_Reflection_MethodBody? /* System.Reflection.MethodBody */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetMethodBody(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBody(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getGenericArguments() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetGenericArguments(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invoke(_ obj: System_Object? /* System.Object */, _ parameters: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let objC = obj?.__handle
		let parametersC = parameters?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_Invoke(self.__handle, objC, parametersC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invoke(_ obj: System_Object? /* System.Object */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ parameters: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_Object? /* System.Object */ {
		let objC = obj?.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let parametersC = parameters?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_Invoke_1(self.__handle, objC, invokeAttrC, binderC, parametersC, cultureC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var attributes: System_Reflection_MethodAttributes /* System.Reflection.MethodAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var methodImplementationFlags: System_Reflection_MethodImplAttributes /* System.Reflection.MethodImplAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_MethodImplementationFlags_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodImplAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var callingConvention: System_Reflection_CallingConventions /* System.Reflection.CallingConventions */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_CallingConvention_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_CallingConventions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isAbstract: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsAbstract_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isConstructor: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsConstructor_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFinal: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsFinal_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isHideBySig: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsHideBySig_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSpecialName: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsSpecialName_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isStatic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsStatic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isVirtual: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsVirtual_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFamily: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsFamily_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFamilyAndAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsFamilyAndAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFamilyOrAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsFamilyOrAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPrivate: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsPrivate_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPublic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsPublic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isConstructedGenericMethod: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsConstructedGenericMethod_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericMethod: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsGenericMethod_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isGenericMethodDefinition: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsGenericMethodDefinition_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var containsGenericParameters: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_ContainsGenericParameters_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var methodHandle: System_RuntimeMethodHandle /* System.RuntimeMethodHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_MethodHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_RuntimeMethodHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isSecurityCritical: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsSecurityCritical_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecuritySafeCritical: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsSecuritySafeCritical_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecurityTransparent: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBase_IsSecurityTransparent_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MethodBase_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_MethodBase_Destroy(self.__handle)
		
	}
	
	
}


public class System_RuntimeMethodHandle /* System.RuntimeMethodHandle */: System_ValueType {
	public override class var typeName: String { get {
		"RuntimeMethodHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.RuntimeMethodHandle"
	}}

	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_RuntimeMethodHandle_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromIntPtr(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_RuntimeMethodHandle /* System.RuntimeMethodHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_FromIntPtr(value, &__exceptionC)
		
		let __returnValue = System_RuntimeMethodHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toIntPtr(_ value: System_RuntimeMethodHandle /* System.RuntimeMethodHandle */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_ToIntPtr(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ handle: System_RuntimeMethodHandle /* System.RuntimeMethodHandle */) throws -> Bool /* System.Boolean */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_Equals_1(self.__handle, handleC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getFunctionPointer() throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_GetFunctionPointer(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var value: UnsafeMutableRawPointer? /* System.IntPtr */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_Value_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeMethodHandle_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_RuntimeMethodHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_RuntimeMethodHandle_Destroy(self.__handle)
		
	}
	
	
}




public class System_RuntimeTypeHandle /* System.RuntimeTypeHandle */: System_ValueType {
	public override class var typeName: String { get {
		"RuntimeTypeHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.RuntimeTypeHandle"
	}}

	public class func fromIntPtr(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_RuntimeTypeHandle /* System.RuntimeTypeHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_FromIntPtr(value, &__exceptionC)
		
		let __returnValue = System_RuntimeTypeHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toIntPtr(_ value: System_RuntimeTypeHandle /* System.RuntimeTypeHandle */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_ToIntPtr(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ handle: System_RuntimeTypeHandle /* System.RuntimeTypeHandle */) throws -> Bool /* System.Boolean */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_Equals_1(self.__handle, handleC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getModuleHandle() throws -> System_ModuleHandle /* System.ModuleHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_GetModuleHandle(self.__handle, &__exceptionC)
		
		let __returnValue = System_ModuleHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_RuntimeTypeHandle_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var value: UnsafeMutableRawPointer? /* System.IntPtr */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_Value_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeTypeHandle_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_RuntimeTypeHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_RuntimeTypeHandle_Destroy(self.__handle)
		
	}
	
	
}




public class System_ModuleHandle /* System.ModuleHandle */: System_ValueType {
	public override class var typeName: String { get {
		"ModuleHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.ModuleHandle"
	}}

	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ handle: System_ModuleHandle /* System.ModuleHandle */) throws -> Bool /* System.Boolean */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_Equals_1(self.__handle, handleC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getRuntimeTypeHandleFromMetadataToken(_ typeToken: Int32 /* System.Int32 */) throws -> System_RuntimeTypeHandle /* System.RuntimeTypeHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_GetRuntimeTypeHandleFromMetadataToken(self.__handle, typeToken, &__exceptionC)
		
		let __returnValue = System_RuntimeTypeHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveTypeHandle(_ typeToken: Int32 /* System.Int32 */) throws -> System_RuntimeTypeHandle /* System.RuntimeTypeHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_ResolveTypeHandle(self.__handle, typeToken, &__exceptionC)
		
		let __returnValue = System_RuntimeTypeHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveTypeHandle(_ typeToken: Int32 /* System.Int32 */, _ typeInstantiationContext: System_RuntimeTypeHandle_Array? /* System.RuntimeTypeHandle[] */, _ methodInstantiationContext: System_RuntimeTypeHandle_Array? /* System.RuntimeTypeHandle[] */) throws -> System_RuntimeTypeHandle /* System.RuntimeTypeHandle */ {
		let typeInstantiationContextC = typeInstantiationContext?.__handle
		let methodInstantiationContextC = methodInstantiationContext?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_ResolveTypeHandle_1(self.__handle, typeToken, typeInstantiationContextC, methodInstantiationContextC, &__exceptionC)
		
		let __returnValue = System_RuntimeTypeHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRuntimeMethodHandleFromMetadataToken(_ methodToken: Int32 /* System.Int32 */) throws -> System_RuntimeMethodHandle /* System.RuntimeMethodHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_GetRuntimeMethodHandleFromMetadataToken(self.__handle, methodToken, &__exceptionC)
		
		let __returnValue = System_RuntimeMethodHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveMethodHandle(_ methodToken: Int32 /* System.Int32 */) throws -> System_RuntimeMethodHandle /* System.RuntimeMethodHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_ResolveMethodHandle(self.__handle, methodToken, &__exceptionC)
		
		let __returnValue = System_RuntimeMethodHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveMethodHandle(_ methodToken: Int32 /* System.Int32 */, _ typeInstantiationContext: System_RuntimeTypeHandle_Array? /* System.RuntimeTypeHandle[] */, _ methodInstantiationContext: System_RuntimeTypeHandle_Array? /* System.RuntimeTypeHandle[] */) throws -> System_RuntimeMethodHandle /* System.RuntimeMethodHandle */ {
		let typeInstantiationContextC = typeInstantiationContext?.__handle
		let methodInstantiationContextC = methodInstantiationContext?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_ResolveMethodHandle_1(self.__handle, methodToken, typeInstantiationContextC, methodInstantiationContextC, &__exceptionC)
		
		let __returnValue = System_RuntimeMethodHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRuntimeFieldHandleFromMetadataToken(_ fieldToken: Int32 /* System.Int32 */) throws -> System_RuntimeFieldHandle /* System.RuntimeFieldHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_GetRuntimeFieldHandleFromMetadataToken(self.__handle, fieldToken, &__exceptionC)
		
		let __returnValue = System_RuntimeFieldHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveFieldHandle(_ fieldToken: Int32 /* System.Int32 */) throws -> System_RuntimeFieldHandle /* System.RuntimeFieldHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_ResolveFieldHandle(self.__handle, fieldToken, &__exceptionC)
		
		let __returnValue = System_RuntimeFieldHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveFieldHandle(_ fieldToken: Int32 /* System.Int32 */, _ typeInstantiationContext: System_RuntimeTypeHandle_Array? /* System.RuntimeTypeHandle[] */, _ methodInstantiationContext: System_RuntimeTypeHandle_Array? /* System.RuntimeTypeHandle[] */) throws -> System_RuntimeFieldHandle /* System.RuntimeFieldHandle */ {
		let typeInstantiationContextC = typeInstantiationContext?.__handle
		let methodInstantiationContextC = methodInstantiationContext?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_ResolveFieldHandle_1(self.__handle, fieldToken, typeInstantiationContextC, methodInstantiationContextC, &__exceptionC)
		
		let __returnValue = System_RuntimeFieldHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var mDStreamVersion: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_MDStreamVersion_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var emptyHandle: System_ModuleHandle /* System.ModuleHandle */ { get {
		
		
		let __returnValueC = System_ModuleHandle_EmptyHandle_Get()
		
		let __returnValue = System_ModuleHandle(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ModuleHandle_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ModuleHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ModuleHandle_Destroy(self.__handle)
		
	}
	
	
}




public class System_RuntimeTypeHandle_Array /* System.RuntimeTypeHandle[] */: System_Array {
	public override class var typeName: String { get {
		"RuntimeTypeHandle[]"
	}}

	public override class var fullTypeName: String { get {
		"System.RuntimeTypeHandle[]"
	}}

	
}















public class System_RuntimeFieldHandle /* System.RuntimeFieldHandle */: System_ValueType {
	public override class var typeName: String { get {
		"RuntimeFieldHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.RuntimeFieldHandle"
	}}

	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ handle: System_RuntimeFieldHandle /* System.RuntimeFieldHandle */) throws -> Bool /* System.Boolean */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_Equals_1(self.__handle, handleC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromIntPtr(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_RuntimeFieldHandle /* System.RuntimeFieldHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_FromIntPtr(value, &__exceptionC)
		
		let __returnValue = System_RuntimeFieldHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toIntPtr(_ value: System_RuntimeFieldHandle /* System.RuntimeFieldHandle */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_ToIntPtr(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_RuntimeFieldHandle_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var value: UnsafeMutableRawPointer? /* System.IntPtr */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_Value_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_RuntimeFieldHandle_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_RuntimeFieldHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_RuntimeFieldHandle_Destroy(self.__handle)
		
	}
	
	
}




public class System_Reflection_ParameterInfo_Array /* System.Reflection.ParameterInfo[] */: System_Array {
	public override class var typeName: String { get {
		"ParameterInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ParameterInfo[]"
	}}

	
}










public class System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */: System_Object {
	public override class var typeName: String { get {
		"ParameterInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ParameterInfo"
	}}

	public func isDefined(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_IsDefined(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCustomAttributesData() throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetCustomAttributesData(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetCustomAttributes_1(self.__handle, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetCustomAttributes_2(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getModifiedParameterType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetModifiedParameterType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getOptionalCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetOptionalCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRequiredCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetRequiredCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRealObject(_ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws -> System_Object /* System.Object */ {
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_GetRealObject(self.__handle, contextC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var attributes: System_Reflection_ParameterAttributes /* System.Reflection.ParameterAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ParameterAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var member: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_Member_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var parameterType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_ParameterType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var position: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_Position_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isIn: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_IsIn_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isLcid: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_IsLcid_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isOptional: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_IsOptional_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isOut: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_IsOut_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isRetval: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_IsRetval_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var defaultValue: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_DefaultValue_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var rawDefaultValue: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_RawDefaultValue_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var hasDefaultValue: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_HasDefaultValue_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var customAttributes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_CustomAttributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var metadataToken: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterInfo_MetadataToken_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ParameterInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ParameterInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Serialization_IObjectReference /* System.Runtime.Serialization.IObjectReference */: DNObject {
	public override class var typeName: String { get {
		"IObjectReference"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Serialization.IObjectReference"
	}}

	public func getRealObject(_ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws -> System_Object /* System.Object */ {
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Serialization_IObjectReference_GetRealObject(self.__handle, contextC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Serialization_IObjectReference_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Serialization_IObjectReference_Destroy(self.__handle)
		
	}
	
	
}






public class System_Reflection_CustomAttributeData /* System.Reflection.CustomAttributeData */: System_Object {
	public override class var typeName: String { get {
		"CustomAttributeData"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.CustomAttributeData"
	}}

	public class func getCustomAttributes(_ target: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */) throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		let targetC = target.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_GetCustomAttributes(targetC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ target: System_Reflection_Module /* System.Reflection.Module */) throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		let targetC = target.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_GetCustomAttributes_1(targetC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ target: System_Reflection_Assembly /* System.Reflection.Assembly */) throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		let targetC = target.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_GetCustomAttributes_2(targetC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ target: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */) throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		let targetC = target.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_GetCustomAttributes_3(targetC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var attributeType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_AttributeType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var constructor: System_Reflection_ConstructorInfo /* System.Reflection.ConstructorInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_Constructor_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ConstructorInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var constructorArguments: System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_ConstructorArguments_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var namedArguments: System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeData_NamedArguments_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_CustomAttributeData_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_CustomAttributeData_Destroy(self.__handle)
		
	}
	
	
}






public class System_Reflection_CustomAttributeData_Array /* System.Reflection.CustomAttributeData[] */: System_Array {
	public override class var typeName: String { get {
		"CustomAttributeData[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.CustomAttributeData[]"
	}}

	
}







public class System_Reflection_Module /* System.Reflection.Module */: System_Object {
	public override class var typeName: String { get {
		"Module"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.Module"
	}}

	public func getPEKind(_ peKind: inout System_Reflection_PortableExecutableKinds /* System.Reflection.PortableExecutableKinds */, _ machine: inout System_Reflection_ImageFileMachine /* System.Reflection.ImageFileMachine */) throws {
		var peKindC = peKind.cValue
		var machineC = machine.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_Module_GetPEKind(self.__handle, &peKindC, &machineC, &__exceptionC)
		
		peKind = System_Reflection_PortableExecutableKinds(cValue: peKindC)
		
		machine = System_Reflection_ImageFileMachine(cValue: machineC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func isResource() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_IsResource(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isDefined(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_IsDefined(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCustomAttributesData() throws -> System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.CustomAttributeData> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetCustomAttributesData(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetCustomAttributes_1(self.__handle, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getCustomAttributes(_ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Object_Array /* System.Object[] */ {
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetCustomAttributes_2(self.__handle, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetMethod(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ types: System_Type_Array /* System.Type[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let typesC = types.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetMethod_1(self.__handle, nameC, typesC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ callConvention: System_Reflection_CallingConventions /* System.Reflection.CallingConventions */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let callConventionC = callConvention.cValue
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetMethod_2(self.__handle, nameC, bindingAttrC, binderC, callConventionC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethods() throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetMethods(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethods(_ bindingFlags: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		let bindingFlagsC = bindingFlags.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetMethods_1(self.__handle, bindingFlagsC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getField(_ name: System_String /* System.String */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetField(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getField(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetField_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFields() throws -> System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetFields(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFields(_ bindingFlags: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */ {
		let bindingFlagsC = bindingFlags.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetFields_1(self.__handle, bindingFlagsC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTypes() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetTypes(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getType(_ className: System_String /* System.String */) throws -> System_Type? /* System.Type */ {
		let classNameC = className.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetType_1(self.__handle, classNameC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getType(_ className: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let classNameC = className.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetType_2(self.__handle, classNameC, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getType(_ className: System_String /* System.String */, _ throwOnError: Bool /* System.Boolean */, _ ignoreCase: Bool /* System.Boolean */) throws -> System_Type? /* System.Type */ {
		let classNameC = className.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetType_3(self.__handle, classNameC, throwOnError, ignoreCase, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func findTypes(_ filter: System_Reflection_TypeFilter? /* System.Reflection.TypeFilter */, _ filterCriteria: System_Object? /* System.Object */) throws -> System_Type_Array /* System.Type[] */ {
		let filterC = filter?.__handle
		let filterCriteriaC = filterCriteria?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_FindTypes(self.__handle, filterC, filterCriteriaC, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveField(_ metadataToken: Int32 /* System.Int32 */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveField(self.__handle, metadataToken, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveField(_ metadataToken: Int32 /* System.Int32 */, _ genericTypeArguments: System_Type_Array? /* System.Type[] */, _ genericMethodArguments: System_Type_Array? /* System.Type[] */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let genericTypeArgumentsC = genericTypeArguments?.__handle
		let genericMethodArgumentsC = genericMethodArguments?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveField_1(self.__handle, metadataToken, genericTypeArgumentsC, genericMethodArgumentsC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveMember(_ metadataToken: Int32 /* System.Int32 */) throws -> System_Reflection_MemberInfo? /* System.Reflection.MemberInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveMember(self.__handle, metadataToken, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveMember(_ metadataToken: Int32 /* System.Int32 */, _ genericTypeArguments: System_Type_Array? /* System.Type[] */, _ genericMethodArguments: System_Type_Array? /* System.Type[] */) throws -> System_Reflection_MemberInfo? /* System.Reflection.MemberInfo */ {
		let genericTypeArgumentsC = genericTypeArguments?.__handle
		let genericMethodArgumentsC = genericMethodArguments?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveMember_1(self.__handle, metadataToken, genericTypeArgumentsC, genericMethodArgumentsC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveMethod(_ metadataToken: Int32 /* System.Int32 */) throws -> System_Reflection_MethodBase? /* System.Reflection.MethodBase */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveMethod(self.__handle, metadataToken, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveMethod(_ metadataToken: Int32 /* System.Int32 */, _ genericTypeArguments: System_Type_Array? /* System.Type[] */, _ genericMethodArguments: System_Type_Array? /* System.Type[] */) throws -> System_Reflection_MethodBase? /* System.Reflection.MethodBase */ {
		let genericTypeArgumentsC = genericTypeArguments?.__handle
		let genericMethodArgumentsC = genericMethodArguments?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveMethod_1(self.__handle, metadataToken, genericTypeArgumentsC, genericMethodArgumentsC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveSignature(_ metadataToken: Int32 /* System.Int32 */) throws -> System_Byte_Array /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveSignature(self.__handle, metadataToken, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveString(_ metadataToken: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveString(self.__handle, metadataToken, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveType(_ metadataToken: Int32 /* System.Int32 */) throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveType(self.__handle, metadataToken, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func resolveType(_ metadataToken: Int32 /* System.Int32 */, _ genericTypeArguments: System_Type_Array? /* System.Type[] */, _ genericMethodArguments: System_Type_Array? /* System.Type[] */) throws -> System_Type /* System.Type */ {
		let genericTypeArgumentsC = genericTypeArguments?.__handle
		let genericMethodArgumentsC = genericMethodArguments?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ResolveType_1(self.__handle, metadataToken, genericTypeArgumentsC, genericMethodArgumentsC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_Module_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func equals(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_Equals(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var assembly: System_Reflection_Assembly /* System.Reflection.Assembly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_Assembly_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var fullyQualifiedName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_FullyQualifiedName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var mDStreamVersion: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_MDStreamVersion_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var moduleVersionId: System_Guid /* System.Guid */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ModuleVersionId_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var scopeName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ScopeName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var moduleHandle: System_ModuleHandle /* System.ModuleHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_ModuleHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_ModuleHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var customAttributes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_CustomAttributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var metadataToken: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Module_MetadataToken_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var filterTypeName: System_Reflection_TypeFilter /* System.Reflection.TypeFilter */ { get {
		
		
		let __returnValueC = System_Reflection_Module_FilterTypeName_Get()
		
		let __returnValue = System_Reflection_TypeFilter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var filterTypeNameIgnoreCase: System_Reflection_TypeFilter /* System.Reflection.TypeFilter */ { get {
		
		
		let __returnValueC = System_Reflection_Module_FilterTypeNameIgnoreCase_Get()
		
		let __returnValue = System_Reflection_TypeFilter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_Module_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_Module_Destroy(self.__handle)
		
	}
	
	
}


public class System_Guid /* System.Guid */: System_ValueType {
	public override class var typeName: String { get {
		"Guid"
	}}

	public override class var fullTypeName: String { get {
		"System.Guid"
	}}

	public class func parse(_ input: System_String /* System.String */) throws -> System_Guid /* System.Guid */ {
		let inputC = input.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Parse(inputC, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ input: System_String? /* System.String */, _ result: inout System_Guid /* System.Guid */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_TryParse(inputC, &resultC, &__exceptionC)
		
		result = System_Guid(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ format: System_String /* System.String */) throws -> System_Guid /* System.Guid */ {
		let inputC = input.__handle
		let formatC = format.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_ParseExact(inputC, formatC, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ format: System_String? /* System.String */, _ result: inout System_Guid /* System.Guid */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatC = format?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_TryParseExact(inputC, formatC, &resultC, &__exceptionC)
		
		result = System_Guid(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toByteArray() throws -> System_Byte_Array /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_ToByteArray(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toByteArray(_ bigEndian: Bool /* System.Boolean */) throws -> System_Byte_Array /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_ToByteArray_1(self.__handle, bigEndian, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Equals(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ g: System_Guid /* System.Guid */) throws -> Bool /* System.Boolean */ {
		let gC = g.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Equals_1(self.__handle, gC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Guid /* System.Guid */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_ToString_2(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Guid /* System.Guid */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Parse_1(sC, providerC, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Guid /* System.Guid */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_TryParse_1(sC, providerC, &resultC, &__exceptionC)
		
		result = System_Guid(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func newGuid() throws -> System_Guid /* System.Guid */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_NewGuid(&__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ b: System_Byte_Array /* System.Byte[] */) throws {
		let bC = b.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create(bC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ b: Data? /* System.ReadOnlySpan<System.Byte> */) throws {
		let bC = b.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_1(bC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ b: Data? /* System.ReadOnlySpan<System.Byte> */, _ bigEndian: Bool /* System.Boolean */) throws {
		let bC = b.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_2(bC, bigEndian, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ a: UInt32 /* System.UInt32 */, _ b: UInt16 /* System.UInt16 */, _ c: UInt16 /* System.UInt16 */, _ d: UInt8 /* System.Byte */, _ e: UInt8 /* System.Byte */, _ f: UInt8 /* System.Byte */, _ g: UInt8 /* System.Byte */, _ h: UInt8 /* System.Byte */, _ i: UInt8 /* System.Byte */, _ j: UInt8 /* System.Byte */, _ k: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_3(a, b, c, d, e, f, g, h, i, j, k, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ a: Int32 /* System.Int32 */, _ b: Int16 /* System.Int16 */, _ c: Int16 /* System.Int16 */, _ d: System_Byte_Array /* System.Byte[] */) throws {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_4(a, b, c, dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ a: Int32 /* System.Int32 */, _ b: Int16 /* System.Int16 */, _ c: Int16 /* System.Int16 */, _ d: UInt8 /* System.Byte */, _ e: UInt8 /* System.Byte */, _ f: UInt8 /* System.Byte */, _ g: UInt8 /* System.Byte */, _ h: UInt8 /* System.Byte */, _ i: UInt8 /* System.Byte */, _ j: UInt8 /* System.Byte */, _ k: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_5(a, b, c, d, e, f, g, h, i, j, k, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ g: System_String /* System.String */) throws {
		let gC = g.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_6(gC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var empty: System_Guid /* System.Guid */ { get {
		
		
		let __returnValueC = System_Guid_Empty_Get()
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Guid_Create_7(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Guid_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Guid_Destroy(self.__handle)
		
	}
	
	
}













public class System_Reflection_MethodInfo /* System.Reflection.MethodInfo */: System_Reflection_MethodBase {
	public override class var typeName: String { get {
		"MethodInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MethodInfo"
	}}

	public override func getGenericArguments() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_GetGenericArguments(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getGenericMethodDefinition() throws -> System_Reflection_MethodInfo /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_GetGenericMethodDefinition(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makeGenericMethod(_ typeArguments: System_Type_Array /* System.Type[] */) throws -> System_Reflection_MethodInfo /* System.Reflection.MethodInfo */ {
		let typeArgumentsC = typeArguments.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_MakeGenericMethod(self.__handle, typeArgumentsC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getBaseDefinition() throws -> System_Reflection_MethodInfo /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_GetBaseDefinition(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createDelegate(_ delegateType: System_Type /* System.Type */) throws -> System_Delegate /* System.Delegate */ {
		let delegateTypeC = delegateType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_CreateDelegate(self.__handle, delegateTypeC, &__exceptionC)
		
		let __returnValue = System_Delegate(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createDelegate(_ delegateType: System_Type /* System.Type */, _ target: System_Object? /* System.Object */) throws -> System_Delegate /* System.Delegate */ {
		let delegateTypeC = delegateType.__handle
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_CreateDelegate_1(self.__handle, delegateTypeC, targetC, &__exceptionC)
		
		let __returnValue = System_Delegate(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createDelegate(T: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_CreateDelegate_A1(self.__handle, TC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createDelegate(T: System_Type /* System.Type */, _ target: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_CreateDelegate_A1_1(self.__handle, TC, targetC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var returnParameter: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_ReturnParameter_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ParameterInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var returnType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_ReturnType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var returnTypeCustomAttributes: System_Reflection_ICustomAttributeProvider /* System.Reflection.ICustomAttributeProvider */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodInfo_ReturnTypeCustomAttributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ICustomAttributeProvider(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MethodInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_MethodInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Type_Array /* System.Type[] */: System_Array {
	public override class var typeName: String { get {
		"Type[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Type[]"
	}}

	
}















public class System_Reflection_Binder /* System.Reflection.Binder */: System_Object {
	public override class var typeName: String { get {
		"Binder"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.Binder"
	}}

	public func bindToField(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ match: System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */, _ value: System_Object /* System.Object */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_Reflection_FieldInfo /* System.Reflection.FieldInfo */ {
		let bindingAttrC = bindingAttr.cValue
		let matchC = match.__handle
		let valueC = value.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Binder_BindToField(self.__handle, bindingAttrC, matchC, valueC, cultureC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func bindToMethod(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ match: System_Reflection_MethodBase_Array /* System.Reflection.MethodBase[] */, _ args: inout System_Object_Array /* System.Object[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ names: System_String_Array? /* System.String[] */, _ state: inout System_Object? /* System.Object */) throws -> System_Reflection_MethodBase /* System.Reflection.MethodBase */ {
		let bindingAttrC = bindingAttr.cValue
		let matchC = match.__handle
		var argsC = args.__handle
		let modifiersC = modifiers?.__handle
		let cultureC = culture?.__handle
		let namesC = names?.__handle
		var stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Binder_BindToMethod(self.__handle, bindingAttrC, matchC, &argsC, modifiersC, cultureC, namesC, &stateC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		args = System_Object_Array(handle: argsC)
		
		state = System_Object(handle: stateC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func changeType(_ value: System_Object /* System.Object */, _ type: System_Type /* System.Type */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_Object /* System.Object */ {
		let valueC = value.__handle
		let typeC = type.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Binder_ChangeType(self.__handle, valueC, typeC, cultureC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func reorderArgumentArray(_ args: inout System_Object_Array /* System.Object[] */, _ state: System_Object /* System.Object */) throws {
		var argsC = args.__handle
		let stateC = state.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_Binder_ReorderArgumentArray(self.__handle, &argsC, stateC, &__exceptionC)
		
		args = System_Object_Array(handle: argsC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func selectMethod(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ match: System_Reflection_MethodBase_Array /* System.Reflection.MethodBase[] */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodBase? /* System.Reflection.MethodBase */ {
		let bindingAttrC = bindingAttr.cValue
		let matchC = match.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Binder_SelectMethod(self.__handle, bindingAttrC, matchC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodBase(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func selectProperty(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ match: System_Reflection_PropertyInfo_Array /* System.Reflection.PropertyInfo[] */, _ returnType: System_Type? /* System.Type */, _ indexes: System_Type_Array? /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let bindingAttrC = bindingAttr.cValue
		let matchC = match.__handle
		let returnTypeC = returnType?.__handle
		let indexesC = indexes?.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_Binder_SelectProperty(self.__handle, bindingAttrC, matchC, returnTypeC, indexesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_Binder_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_Binder_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_FieldInfo /* System.Reflection.FieldInfo */: System_Reflection_MemberInfo {
	public override class var typeName: String { get {
		"FieldInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.FieldInfo"
	}}

	public class func getFieldFromHandle(_ handle: System_RuntimeFieldHandle /* System.RuntimeFieldHandle */) throws -> System_Reflection_FieldInfo /* System.Reflection.FieldInfo */ {
		let handleC = handle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetFieldFromHandle(handleC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFieldFromHandle(_ handle: System_RuntimeFieldHandle /* System.RuntimeFieldHandle */, _ declaringType: System_RuntimeTypeHandle /* System.RuntimeTypeHandle */) throws -> System_Reflection_FieldInfo /* System.Reflection.FieldInfo */ {
		let handleC = handle.__handle
		let declaringTypeC = declaringType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetFieldFromHandle_1(handleC, declaringTypeC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getValue(_ obj: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetValue(self.__handle, objC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setValue(_ obj: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let objC = obj?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_FieldInfo_SetValue(self.__handle, objC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ obj: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let objC = obj?.__handle
		let valueC = value?.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_FieldInfo_SetValue_1(self.__handle, objC, valueC, invokeAttrC, binderC, cultureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getRawConstantValue() throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetRawConstantValue(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getModifiedFieldType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetModifiedFieldType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getOptionalCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetOptionalCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRequiredCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_GetRequiredCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var attributes: System_Reflection_FieldAttributes /* System.Reflection.FieldAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var fieldType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_FieldType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isInitOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsInitOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isLiteral: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsLiteral_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isNotSerialized: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsNotSerialized_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPinvokeImpl: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsPinvokeImpl_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSpecialName: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsSpecialName_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isStatic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsStatic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFamily: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsFamily_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFamilyAndAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsFamilyAndAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFamilyOrAssembly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsFamilyOrAssembly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPrivate: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsPrivate_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPublic: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsPublic_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecurityCritical: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsSecurityCritical_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecuritySafeCritical: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsSecuritySafeCritical_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSecurityTransparent: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_IsSecurityTransparent_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var fieldHandle: System_RuntimeFieldHandle /* System.RuntimeFieldHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_FieldInfo_FieldHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_RuntimeFieldHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_FieldInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_FieldInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */: System_Array {
	public override class var typeName: String { get {
		"FieldInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.FieldInfo[]"
	}}

	
}















public class System_Reflection_MethodBase_Array /* System.Reflection.MethodBase[] */: System_Array {
	public override class var typeName: String { get {
		"MethodBase[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MethodBase[]"
	}}

	
}
















public class System_Reflection_ParameterModifier_Array /* System.Reflection.ParameterModifier[] */: System_Array {
	public override class var typeName: String { get {
		"ParameterModifier[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ParameterModifier[]"
	}}

	
}










public class System_Reflection_ParameterModifier /* System.Reflection.ParameterModifier */: System_ValueType {
	public override class var typeName: String { get {
		"ParameterModifier"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ParameterModifier"
	}}

	public convenience init(_ parameterCount: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterModifier_Create(parameterCount, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item(_ index: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterModifier_Item_Get(self.__handle, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	public func item_set(_ index: Int32 /* System.Int32 */, _ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_ParameterModifier_Item_Set(self.__handle, index, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ParameterModifier_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ParameterModifier_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ParameterModifier_Destroy(self.__handle)
		
	}
	
	
}








public class System_Reflection_PropertyInfo /* System.Reflection.PropertyInfo */: System_Reflection_MemberInfo {
	public override class var typeName: String { get {
		"PropertyInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.PropertyInfo"
	}}

	public func getIndexParameters() throws -> System_Reflection_ParameterInfo_Array /* System.Reflection.ParameterInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetIndexParameters(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ParameterInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAccessors() throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetAccessors(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAccessors(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetAccessors_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getGetMethod() throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetGetMethod(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getGetMethod(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetGetMethod_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getSetMethod() throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetSetMethod(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getSetMethod(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetSetMethod_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getModifiedPropertyType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetModifiedPropertyType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getOptionalCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetOptionalCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRequiredCustomModifiers() throws -> System_Type_Array /* System.Type[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetRequiredCustomModifiers(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ obj: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetValue(self.__handle, objC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ obj: System_Object? /* System.Object */, _ index: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let objC = obj?.__handle
		let indexC = index?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetValue_1(self.__handle, objC, indexC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getValue(_ obj: System_Object? /* System.Object */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ index: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_Object? /* System.Object */ {
		let objC = obj?.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let indexC = index?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetValue_2(self.__handle, objC, invokeAttrC, binderC, indexC, cultureC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getConstantValue() throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetConstantValue(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRawConstantValue() throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetRawConstantValue(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setValue(_ obj: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let objC = obj?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_PropertyInfo_SetValue(self.__handle, objC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ obj: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */, _ index: System_Object_Array? /* System.Object[] */) throws {
		let objC = obj?.__handle
		let valueC = value?.__handle
		let indexC = index?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_PropertyInfo_SetValue_1(self.__handle, objC, valueC, indexC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setValue(_ obj: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ index: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let objC = obj?.__handle
		let valueC = value?.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let indexC = index?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_PropertyInfo_SetValue_2(self.__handle, objC, valueC, invokeAttrC, binderC, indexC, cultureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var propertyType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_PropertyType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var attributes: System_Reflection_PropertyAttributes /* System.Reflection.PropertyAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isSpecialName: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_IsSpecialName_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var canRead: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_CanRead_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var canWrite: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_CanWrite_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var getMethod: System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_GetMethod_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var setMethod: System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_PropertyInfo_SetMethod_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_PropertyInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_PropertyInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */: System_Array {
	public override class var typeName: String { get {
		"MethodInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MethodInfo[]"
	}}

	
}















public class System_Reflection_PropertyInfo_Array /* System.Reflection.PropertyInfo[] */: System_Array {
	public override class var typeName: String { get {
		"PropertyInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.PropertyInfo[]"
	}}

	
}















public class System_Reflection_ConstructorInfo /* System.Reflection.ConstructorInfo */: System_Reflection_MethodBase {
	public override class var typeName: String { get {
		"ConstructorInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ConstructorInfo"
	}}

	public func invoke(_ parameters: System_Object_Array? /* System.Object[] */) throws -> System_Object /* System.Object */ {
		let parametersC = parameters?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ConstructorInfo_Invoke(self.__handle, parametersC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invoke(_ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ parameters: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws -> System_Object /* System.Object */ {
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let parametersC = parameters?.__handle
		let cultureC = culture?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ConstructorInfo_Invoke_1(self.__handle, invokeAttrC, binderC, parametersC, cultureC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ConstructorInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ConstructorInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ConstructorInfo_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var constructorName: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Reflection_ConstructorInfo_ConstructorName_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var typeConstructorName: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Reflection_ConstructorInfo_TypeConstructorName_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ConstructorInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ConstructorInfo_Destroy(self.__handle)
		
	}
	
	
}










public class System_Reflection_CustomAttributeTypedArgument /* System.Reflection.CustomAttributeTypedArgument */: System_ValueType {
	public override class var typeName: String { get {
		"CustomAttributeTypedArgument"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.CustomAttributeTypedArgument"
	}}

	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Reflection_CustomAttributeTypedArgument /* System.Reflection.CustomAttributeTypedArgument */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ argumentType: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws {
		let argumentTypeC = argumentType.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_Create(argumentTypeC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: System_Object /* System.Object */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_Create_1(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var argumentType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_ArgumentType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var value: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeTypedArgument_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_CustomAttributeTypedArgument_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_CustomAttributeTypedArgument_Destroy(self.__handle)
		
	}
	
	
}




public class System_Reflection_CustomAttributeTypedArgument_Array /* System.Reflection.CustomAttributeTypedArgument[] */: System_Array {
	public override class var typeName: String { get {
		"CustomAttributeTypedArgument[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.CustomAttributeTypedArgument[]"
	}}

	
}















public class System_Reflection_CustomAttributeNamedArgument /* System.Reflection.CustomAttributeNamedArgument */: System_ValueType {
	public override class var typeName: String { get {
		"CustomAttributeNamedArgument"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.CustomAttributeNamedArgument"
	}}

	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Reflection_CustomAttributeNamedArgument /* System.Reflection.CustomAttributeNamedArgument */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ memberInfo: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ value: System_Object? /* System.Object */) throws {
		let memberInfoC = memberInfo.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_Create(memberInfoC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ memberInfo: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ typedArgument: System_Reflection_CustomAttributeTypedArgument /* System.Reflection.CustomAttributeTypedArgument */) throws {
		let memberInfoC = memberInfo.__handle
		let typedArgumentC = typedArgument.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_Create_1(memberInfoC, typedArgumentC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var memberInfo: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_MemberInfo_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var typedValue: System_Reflection_CustomAttributeTypedArgument /* System.Reflection.CustomAttributeTypedArgument */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_TypedValue_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_CustomAttributeTypedArgument(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var memberName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_MemberName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isField: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_IsField_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_CustomAttributeNamedArgument_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_CustomAttributeNamedArgument_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_CustomAttributeNamedArgument_Destroy(self.__handle)
		
	}
	
	
}




public class System_Reflection_CustomAttributeNamedArgument_Array /* System.Reflection.CustomAttributeNamedArgument[] */: System_Array {
	public override class var typeName: String { get {
		"CustomAttributeNamedArgument[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.CustomAttributeNamedArgument[]"
	}}

	
}












public class System_Reflection_MethodBody /* System.Reflection.MethodBody */: System_Object {
	public override class var typeName: String { get {
		"MethodBody"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MethodBody"
	}}

	public func getILAsByteArray() throws -> System_Byte_Array? /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBody_GetILAsByteArray(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var localSignatureMetadataToken: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBody_LocalSignatureMetadataToken_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var localVariables: System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.LocalVariableInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBody_LocalVariables_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var maxStackSize: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBody_MaxStackSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var initLocals: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBody_InitLocals_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var exceptionHandlingClauses: System_Collections_Generic_IList_A1 /* System.Collections.Generic.IList<System.Reflection.ExceptionHandlingClause> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_MethodBody_ExceptionHandlingClauses_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IList_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MethodBody_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_MethodBody_Destroy(self.__handle)
		
	}
	
	
}










public class System_Reflection_LocalVariableInfo /* System.Reflection.LocalVariableInfo */: System_Object {
	public override class var typeName: String { get {
		"LocalVariableInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.LocalVariableInfo"
	}}

	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_LocalVariableInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var localType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_LocalVariableInfo_LocalType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var localIndex: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_LocalVariableInfo_LocalIndex_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isPinned: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_LocalVariableInfo_IsPinned_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_LocalVariableInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_LocalVariableInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_LocalVariableInfo_Array /* System.Reflection.LocalVariableInfo[] */: System_Array {
	public override class var typeName: String { get {
		"LocalVariableInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.LocalVariableInfo[]"
	}}

	
}















public class System_Reflection_ExceptionHandlingClause /* System.Reflection.ExceptionHandlingClause */: System_Object {
	public override class var typeName: String { get {
		"ExceptionHandlingClause"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ExceptionHandlingClause"
	}}

	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var flags: System_Reflection_ExceptionHandlingClauseOptions /* System.Reflection.ExceptionHandlingClauseOptions */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_Flags_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ExceptionHandlingClauseOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var tryOffset: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_TryOffset_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var tryLength: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_TryLength_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var handlerOffset: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_HandlerOffset_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var handlerLength: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_HandlerLength_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var filterOffset: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_FilterOffset_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var catchType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ExceptionHandlingClause_CatchType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ExceptionHandlingClause_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ExceptionHandlingClause_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_ExceptionHandlingClause_Array /* System.Reflection.ExceptionHandlingClause[] */: System_Array {
	public override class var typeName: String { get {
		"ExceptionHandlingClause[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ExceptionHandlingClause[]"
	}}

	
}







public class System_Collections_IDictionary /* System.Collections.IDictionary */: DNObject {
	public override class var typeName: String { get {
		"IDictionary"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IDictionary"
	}}

	public func contains(_ key: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_Contains(self.__handle, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func add(_ key: System_Object /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let keyC = key.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IDictionary_Add(self.__handle, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clear() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IDictionary_Clear(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getEnumerator() throws -> System_Collections_IDictionaryEnumerator /* System.Collections.IDictionaryEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IDictionaryEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func remove(_ key: System_Object /* System.Object */) throws {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IDictionary_Remove(self.__handle, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func item(_ key: System_Object /* System.Object */) throws -> System_Object? /* System.Object */ {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_Item_Get(self.__handle, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(_ key: System_Object /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let keyC = key.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_IDictionary_Item_Set(self.__handle, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var keys: System_Collections_ICollection /* System.Collections.ICollection */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_Keys_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_ICollection(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var values: System_Collections_ICollection /* System.Collections.ICollection */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_Values_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_ICollection(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFixedSize: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionary_IsFixedSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IDictionary_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IDictionary_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IDictionaryEnumerator /* System.Collections.IDictionaryEnumerator */: DNObject {
	public override class var typeName: String { get {
		"IDictionaryEnumerator"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IDictionaryEnumerator"
	}}

	public var key: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionaryEnumerator_Key_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var value: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionaryEnumerator_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var entry: System_Collections_DictionaryEntry /* System.Collections.DictionaryEntry */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IDictionaryEnumerator_Entry_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_DictionaryEntry(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IDictionaryEnumerator_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IDictionaryEnumerator_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_DictionaryEntry /* System.Collections.DictionaryEntry */: System_ValueType {
	public override class var typeName: String { get {
		"DictionaryEntry"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.DictionaryEntry"
	}}

	public func deconstruct(_ key: inout System_Object /* System.Object */, _ value: inout System_Object? /* System.Object */) throws {
		var keyC = key.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_DictionaryEntry_Deconstruct(self.__handle, &keyC, &valueC, &__exceptionC)
		
		key = System_Object(handle: keyC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_DictionaryEntry_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ key: System_Object /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let keyC = key.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_DictionaryEntry_Create(keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var key: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_DictionaryEntry_Key_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func key_set(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_DictionaryEntry_Key_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var value: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_DictionaryEntry_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func value_set(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_DictionaryEntry_Value_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_DictionaryEntry_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_DictionaryEntry_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_DictionaryEntry_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_Tasks_Task /* System.Threading.Tasks.Task */: System_Object {
	public override class var typeName: String { get {
		"Task"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.Task"
	}}

	public func start() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_Start(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func start(_ scheduler: System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */) throws {
		let schedulerC = scheduler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_Start_1(self.__handle, schedulerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func runSynchronously() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_RunSynchronously(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func runSynchronously(_ scheduler: System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */) throws {
		let schedulerC = scheduler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_RunSynchronously_1(self.__handle, schedulerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getAwaiter() throws -> System_Runtime_CompilerServices_TaskAwaiter /* System.Runtime.CompilerServices.TaskAwaiter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_GetAwaiter(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_TaskAwaiter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func configureAwait(_ continueOnCapturedContext: Bool /* System.Boolean */) throws -> System_Runtime_CompilerServices_ConfiguredTaskAwaitable /* System.Runtime.CompilerServices.ConfiguredTaskAwaitable */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_ConfigureAwait(self.__handle, continueOnCapturedContext, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_ConfiguredTaskAwaitable(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func configureAwait(_ options: System_Threading_Tasks_ConfigureAwaitOptions /* System.Threading.Tasks.ConfigureAwaitOptions */) throws -> System_Runtime_CompilerServices_ConfiguredTaskAwaitable /* System.Runtime.CompilerServices.ConfiguredTaskAwaitable */ {
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_ConfigureAwait_1(self.__handle, optionsC, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_ConfiguredTaskAwaitable(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func yield() throws -> System_Runtime_CompilerServices_YieldAwaitable /* System.Runtime.CompilerServices.YieldAwaitable */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Yield(&__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_YieldAwaitable(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func wait() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_Wait(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func wait(_ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Wait_1(self.__handle, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func wait(_ timeout: System_TimeSpan /* System.TimeSpan */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> Bool /* System.Boolean */ {
		let timeoutC = timeout.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Wait_2(self.__handle, timeoutC, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func wait(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_Wait_3(self.__handle, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func wait(_ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Wait_4(self.__handle, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func wait(_ millisecondsTimeout: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> Bool /* System.Boolean */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Wait_5(self.__handle, millisecondsTimeout, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func waitAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAsync(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(_ timeout: System_TimeSpan /* System.TimeSpan */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAsync_1(self.__handle, timeoutC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(_ timeout: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider /* System.TimeProvider */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let timeoutC = timeout.__handle
		let timeProviderC = timeProvider.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAsync_2(self.__handle, timeoutC, timeProviderC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(_ timeout: System_TimeSpan /* System.TimeSpan */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let timeoutC = timeout.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAsync_3(self.__handle, timeoutC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(_ timeout: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider /* System.TimeProvider */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let timeoutC = timeout.__handle
		let timeProviderC = timeProvider.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAsync_4(self.__handle, timeoutC, timeProviderC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func waitAll(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */) throws {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_WaitAll(tasksC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func waitAll(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let tasksC = tasks.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAll_1(tasksC, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAll_2(tasksC, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAll(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws {
		let tasksC = tasks.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Task_WaitAll_3(tasksC, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func waitAll(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ millisecondsTimeout: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> Bool /* System.Boolean */ {
		let tasksC = tasks.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAll_4(tasksC, millisecondsTimeout, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */) throws -> Int32 /* System.Int32 */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAny(tasksC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Int32 /* System.Int32 */ {
		let tasksC = tasks.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAny_1(tasksC, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> Int32 /* System.Int32 */ {
		let tasksC = tasks.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAny_2(tasksC, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAny_3(tasksC, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitAny(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */, _ millisecondsTimeout: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> Int32 /* System.Int32 */ {
		let tasksC = tasks.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WaitAny_4(tasksC, millisecondsTimeout, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromException(_ exception: System_Exception /* System.Exception */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let exceptionC = exception.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_FromException(exceptionC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromCanceled(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_FromCanceled(cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func run(_ action: System_Action /* System.Action */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let actionC = action.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Run_1(actionC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func run(_ action: System_Action /* System.Action */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let actionC = action.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Run_2(actionC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delay(_ delay: System_TimeSpan /* System.TimeSpan */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let delayC = delay.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Delay(delayC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delay(_ delay: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider /* System.TimeProvider */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let delayC = delay.__handle
		let timeProviderC = timeProvider.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Delay_1(delayC, timeProviderC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delay(_ delay: System_TimeSpan /* System.TimeSpan */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let delayC = delay.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Delay_2(delayC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delay(_ delay: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider /* System.TimeProvider */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let delayC = delay.__handle
		let timeProviderC = timeProvider.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Delay_3(delayC, timeProviderC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delay(_ millisecondsDelay: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Delay_4(millisecondsDelay, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delay(_ millisecondsDelay: Int32 /* System.Int32 */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Delay_5(millisecondsDelay, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func whenAll(_ tasks: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WhenAll(tasksC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func whenAll(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WhenAll_1(tasksC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func whenAny(_ tasks: System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Threading.Tasks.Task> */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WhenAny(tasksC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func whenAny(_ task1: System_Threading_Tasks_Task /* System.Threading.Tasks.Task */, _ task2: System_Threading_Tasks_Task /* System.Threading.Tasks.Task */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Threading.Tasks.Task> */ {
		let task1C = task1.__handle
		let task2C = task2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WhenAny_1(task1C, task2C, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func whenAny(_ tasks: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Threading.Tasks.Task> */ {
		let tasksC = tasks.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_WhenAny_2(tasksC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ action: System_Action /* System.Action */) throws {
		let actionC = action.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Create(actionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ action: System_Action /* System.Action */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws {
		let actionC = action.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Create_1(actionC, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ action: System_Action /* System.Action */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */) throws {
		let actionC = action.__handle
		let creationOptionsC = creationOptions.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Create_2(actionC, creationOptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ action: System_Action /* System.Action */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */) throws {
		let actionC = action.__handle
		let cancellationTokenC = cancellationToken.__handle
		let creationOptionsC = creationOptions.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Create_3(actionC, cancellationTokenC, creationOptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var id: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Id_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var exception: System_AggregateException? /* System.AggregateException */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Exception_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_AggregateException(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var status: System_Threading_Tasks_TaskStatus /* System.Threading.Tasks.TaskStatus */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Status_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isCanceled: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_IsCanceled_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isCompletedSuccessfully: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_IsCompletedSuccessfully_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_CreationOptions_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskCreationOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var asyncState: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_AsyncState_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var factory: System_Threading_Tasks_TaskFactory /* System.Threading.Tasks.TaskFactory */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_Factory_Get(&__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskFactory(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var completedTask: System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_CompletedTask_Get(&__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isFaulted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_IsFaulted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_Task_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_Task_Destroy(self.__handle)
		
	}
	
	
}


public class System_IAsyncResult /* System.IAsyncResult */: DNObject {
	public override class var typeName: String { get {
		"IAsyncResult"
	}}

	public override class var fullTypeName: String { get {
		"System.IAsyncResult"
	}}

	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IAsyncResult_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var asyncWaitHandle: System_Threading_WaitHandle /* System.Threading.WaitHandle */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IAsyncResult_AsyncWaitHandle_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_WaitHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var asyncState: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IAsyncResult_AsyncState_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var completedSynchronously: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IAsyncResult_CompletedSynchronously_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IAsyncResult_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IAsyncResult_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */: System_Object {
	public override class var typeName: String { get {
		"TaskScheduler"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.TaskScheduler"
	}}

	public class func fromCurrentSynchronizationContext() throws -> System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskScheduler_FromCurrentSynchronizationContext(&__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskScheduler(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var maximumConcurrencyLevel: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskScheduler_MaximumConcurrencyLevel_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var `default`: System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskScheduler_Default_Get(&__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskScheduler(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var current: System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskScheduler_Current_Get(&__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskScheduler(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var id: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskScheduler_Id_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_TaskScheduler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_TaskScheduler_Destroy(self.__handle)
		
	}
	
	
}


public class System_AggregateException /* System.AggregateException */: System_Exception {
	public override class var typeName: String { get {
		"AggregateException"
	}}

	public override class var fullTypeName: String { get {
		"System.AggregateException"
	}}

	public override func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AggregateException_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func getBaseException() throws -> System_Exception /* System.Exception */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_GetBaseException(self.__handle, &__exceptionC)
		
		let __returnValue = System_Exception(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func flatten() throws -> System_AggregateException /* System.AggregateException */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Flatten(self.__handle, &__exceptionC)
		
		let __returnValue = System_AggregateException(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */) throws {
		let messageC = message?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create_1(messageC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerException: System_Exception /* System.Exception */) throws {
		let messageC = message?.__handle
		let innerExceptionC = innerException.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create_2(messageC, innerExceptionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ innerExceptions: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Exception> */) throws {
		let innerExceptionsC = innerExceptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create_3(innerExceptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ innerExceptions: System_Exception_Array /* System.Exception[] */) throws {
		let innerExceptionsC = innerExceptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create_4(innerExceptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerExceptions: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Exception> */) throws {
		let messageC = message?.__handle
		let innerExceptionsC = innerExceptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create_5(messageC, innerExceptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerExceptions: System_Exception_Array /* System.Exception[] */) throws {
		let messageC = message?.__handle
		let innerExceptionsC = innerExceptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Create_6(messageC, innerExceptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var innerExceptions: System_Collections_ObjectModel_ReadOnlyCollection_A1 /* System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_InnerExceptions_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_ObjectModel_ReadOnlyCollection_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override var message: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AggregateException_Message_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AggregateException_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AggregateException_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_ObjectModel_ReadOnlyCollection_A1 /* System.Collections.ObjectModel.ReadOnlyCollection<> */: System_Object {
	public override class var typeName: String { get {
		"ReadOnlyCollection`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.ObjectModel.ReadOnlyCollection<>"
	}}

	public func contains(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ObjectModel_ReadOnlyCollection_A1_Contains(self.__handle, TC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copyTo(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ObjectModel_ReadOnlyCollection_A1_CopyTo(self.__handle, TC, arrayC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func indexOf(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ObjectModel_ReadOnlyCollection_A1_IndexOf(self.__handle, TC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func empty(T: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ObjectModel_ReadOnlyCollection_A1_Empty_Get(TC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func count(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ObjectModel_ReadOnlyCollection_A1_Count_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public func item(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ObjectModel_ReadOnlyCollection_A1_Item_Get(self.__handle, TC, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_ObjectModel_ReadOnlyCollection_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_ObjectModel_ReadOnlyCollection_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.











public class System_Exception_Array /* System.Exception[] */: System_Array {
	public override class var typeName: String { get {
		"Exception[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Exception[]"
	}}

	
}







public class System_Threading_Tasks_TaskFactory /* System.Threading.Tasks.TaskFactory */: System_Object {
	public override class var typeName: String { get {
		"TaskFactory"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.TaskFactory"
	}}

	public func startNew(_ action: System_Action /* System.Action */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let actionC = action.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_StartNew(self.__handle, actionC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func startNew(_ action: System_Action /* System.Action */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let actionC = action.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_StartNew_1(self.__handle, actionC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func startNew(_ action: System_Action /* System.Action */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let actionC = action.__handle
		let creationOptionsC = creationOptions.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_StartNew_2(self.__handle, actionC, creationOptionsC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func startNew(_ action: System_Action /* System.Action */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */, _ scheduler: System_Threading_Tasks_TaskScheduler /* System.Threading.Tasks.TaskScheduler */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let actionC = action.__handle
		let cancellationTokenC = cancellationToken.__handle
		let creationOptionsC = creationOptions.cValue
		let schedulerC = scheduler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_StartNew_3(self.__handle, actionC, cancellationTokenC, creationOptionsC, schedulerC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_Create_1(cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ scheduler: System_Threading_Tasks_TaskScheduler? /* System.Threading.Tasks.TaskScheduler */) throws {
		let schedulerC = scheduler?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_Create_2(schedulerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */, _ continuationOptions: System_Threading_Tasks_TaskContinuationOptions /* System.Threading.Tasks.TaskContinuationOptions */) throws {
		let creationOptionsC = creationOptions.cValue
		let continuationOptionsC = continuationOptions.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_Create_3(creationOptionsC, continuationOptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */, _ continuationOptions: System_Threading_Tasks_TaskContinuationOptions /* System.Threading.Tasks.TaskContinuationOptions */, _ scheduler: System_Threading_Tasks_TaskScheduler? /* System.Threading.Tasks.TaskScheduler */) throws {
		let cancellationTokenC = cancellationToken.__handle
		let creationOptionsC = creationOptions.cValue
		let continuationOptionsC = continuationOptions.cValue
		let schedulerC = scheduler?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_Create_4(cancellationTokenC, creationOptionsC, continuationOptionsC, schedulerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_CancellationToken_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationToken(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var scheduler: System_Threading_Tasks_TaskScheduler? /* System.Threading.Tasks.TaskScheduler */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_Scheduler_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskScheduler(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_CreationOptions_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskCreationOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var continuationOptions: System_Threading_Tasks_TaskContinuationOptions /* System.Threading.Tasks.TaskContinuationOptions */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_ContinuationOptions_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskContinuationOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_TaskFactory_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_TaskFactory_Destroy(self.__handle)
		
	}
	
	
}


// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg3" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg3" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg3" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg3" was skipped. Reason: It has no full name.
public class System_Threading_Tasks_Task_Array /* System.Threading.Tasks.Task[] */: System_Array {
	public override class var typeName: String { get {
		"Task[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.Task[]"
	}}

	
}















public class System_Runtime_CompilerServices_TaskAwaiter /* System.Runtime.CompilerServices.TaskAwaiter */: System_ValueType {
	public override class var typeName: String { get {
		"TaskAwaiter"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.TaskAwaiter"
	}}

	public func onCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_TaskAwaiter_OnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeOnCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_TaskAwaiter_UnsafeOnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getResult() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_TaskAwaiter_GetResult(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_TaskAwaiter_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_TaskAwaiter_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_TaskAwaiter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_TaskAwaiter_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_ICriticalNotifyCompletion /* System.Runtime.CompilerServices.ICriticalNotifyCompletion */: DNObject {
	public override class var typeName: String { get {
		"ICriticalNotifyCompletion"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ICriticalNotifyCompletion"
	}}

	public func unsafeOnCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ICriticalNotifyCompletion_UnsafeOnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ICriticalNotifyCompletion_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ICriticalNotifyCompletion_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_INotifyCompletion /* System.Runtime.CompilerServices.INotifyCompletion */: DNObject {
	public override class var typeName: String { get {
		"INotifyCompletion"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.INotifyCompletion"
	}}

	public func onCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_INotifyCompletion_OnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_INotifyCompletion_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_INotifyCompletion_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_ConfiguredTaskAwaitable /* System.Runtime.CompilerServices.ConfiguredTaskAwaitable */: System_ValueType {
	public override class var typeName: String { get {
		"ConfiguredTaskAwaitable"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ConfiguredTaskAwaitable"
	}}

	public func getAwaiter() throws -> System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter /* System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_GetAwaiter(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ConfiguredTaskAwaitable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ConfiguredTaskAwaitable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter /* System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter */: System_ValueType {
	public override class var typeName: String { get {
		"ConfiguredTaskAwaiter"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter"
	}}

	public func onCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_OnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeOnCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_UnsafeOnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getResult() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_GetResult(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_YieldAwaitable /* System.Runtime.CompilerServices.YieldAwaitable */: System_ValueType {
	public override class var typeName: String { get {
		"YieldAwaitable"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.YieldAwaitable"
	}}

	public func getAwaiter() throws -> System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter /* System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_YieldAwaitable_GetAwaiter(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_YieldAwaitable_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_YieldAwaitable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_YieldAwaitable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter /* System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter */: System_ValueType {
	public override class var typeName: String { get {
		"YieldAwaiter"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter"
	}}

	public func onCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_OnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeOnCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_UnsafeOnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getResult() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_GetResult(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter_Destroy(self.__handle)
		
	}
	
	
}


public class System_TimeProvider /* System.TimeProvider */: System_Object {
	public override class var typeName: String { get {
		"TimeProvider"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeProvider"
	}}

	public func getUtcNow() throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_GetUtcNow(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getLocalNow() throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_GetLocalNow(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getTimestamp() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_GetTimestamp(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getElapsedTime(_ startingTimestamp: Int64 /* System.Int64 */, _ endingTimestamp: Int64 /* System.Int64 */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_GetElapsedTime(self.__handle, startingTimestamp, endingTimestamp, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getElapsedTime(_ startingTimestamp: Int64 /* System.Int64 */) throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_GetElapsedTime_1(self.__handle, startingTimestamp, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createTimer(_ callback: System_Threading_TimerCallback /* System.Threading.TimerCallback */, _ state: System_Object? /* System.Object */, _ dueTime: System_TimeSpan /* System.TimeSpan */, _ period: System_TimeSpan /* System.TimeSpan */) throws -> System_Threading_ITimer /* System.Threading.ITimer */ {
		let callbackC = callback.__handle
		let stateC = state?.__handle
		let dueTimeC = dueTime.__handle
		let periodC = period.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_CreateTimer(self.__handle, callbackC, stateC, dueTimeC, periodC, &__exceptionC)
		
		let __returnValue = System_Threading_ITimer(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var system: System_TimeProvider /* System.TimeProvider */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_System_Get(&__exceptionC)
		
		let __returnValue = System_TimeProvider(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var localTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_LocalTimeZone_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var timestampFrequency: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeProvider_TimestampFrequency_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TimeProvider_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_TimeProvider_Destroy(self.__handle)
		
	}
	
	
}


public class System_DateTimeOffset /* System.DateTimeOffset */: System_ValueType {
	public override class var typeName: String { get {
		"DateTimeOffset"
	}}

	public override class var fullTypeName: String { get {
		"System.DateTimeOffset"
	}}

	public func toOffset(_ offset: System_TimeSpan /* System.TimeSpan */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToOffset(self.__handle, offsetC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func add(_ timeSpan: System_TimeSpan /* System.TimeSpan */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let timeSpanC = timeSpan.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Add(self.__handle, timeSpanC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addDays(_ days: Double /* System.Double */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddDays(self.__handle, days, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addHours(_ hours: Double /* System.Double */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddHours(self.__handle, hours, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMilliseconds(_ milliseconds: Double /* System.Double */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddMilliseconds(self.__handle, milliseconds, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMicroseconds(_ microseconds: Double /* System.Double */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddMicroseconds(self.__handle, microseconds, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMinutes(_ minutes: Double /* System.Double */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddMinutes(self.__handle, minutes, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addMonths(_ months: Int32 /* System.Int32 */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddMonths(self.__handle, months, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addSeconds(_ seconds: Double /* System.Double */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddSeconds(self.__handle, seconds, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addTicks(_ ticks: Int64 /* System.Int64 */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddTicks(self.__handle, ticks, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addYears(_ years: Int32 /* System.Int32 */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_AddYears(self.__handle, years, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func compare(_ first: System_DateTimeOffset /* System.DateTimeOffset */, _ second: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Int32 /* System.Int32 */ {
		let firstC = first.__handle
		let secondC = second.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Compare(firstC, secondC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ other: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Int32 /* System.Int32 */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_CompareTo(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equalsExact(_ other: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_EqualsExact(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func equals(_ first: System_DateTimeOffset /* System.DateTimeOffset */, _ second: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let firstC = first.__handle
		let secondC = second.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Equals_2(firstC, secondC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromFileTime(_ fileTime: Int64 /* System.Int64 */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_FromFileTime(fileTime, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromUnixTimeSeconds(_ seconds: Int64 /* System.Int64 */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_FromUnixTimeSeconds(seconds, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromUnixTimeMilliseconds(_ milliseconds: Int64 /* System.Int64 */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_FromUnixTimeMilliseconds(milliseconds, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ input: System_String /* System.String */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let inputC = input.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Parse(inputC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ input: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let inputC = input.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Parse_1(inputC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ input: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let inputC = input.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Parse_2(inputC, formatProviderC, stylesC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ format: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let inputC = input.__handle
		let formatC = format.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ParseExact(inputC, formatC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ format: System_String /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let inputC = input.__handle
		let formatC = format.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ParseExact_1(inputC, formatC, formatProviderC, stylesC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parseExact(_ input: System_String /* System.String */, _ formats: System_String_Array /* System.String[] */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let inputC = input.__handle
		let formatsC = formats.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ParseExact_2(inputC, formatsC, formatProviderC, stylesC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func subtract(_ value: System_DateTimeOffset /* System.DateTimeOffset */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Subtract(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func subtract(_ value: System_TimeSpan /* System.TimeSpan */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Subtract_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toFileTime() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToFileTime(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUnixTimeSeconds() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToUnixTimeSeconds(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toUnixTimeMilliseconds() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToUnixTimeMilliseconds(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toLocalTime() throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToLocalTime(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToString_2(self.__handle, formatProviderC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToString_3(self.__handle, formatC, formatProviderC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUniversalTime() throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_ToUniversalTime(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ input: System_String? /* System.String */, _ result: inout System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TryParse(inputC, &resultC, &__exceptionC)
		
		result = System_DateTimeOffset(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ input: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TryParse_1(inputC, formatProviderC, stylesC, &resultC, &__exceptionC)
		
		result = System_DateTimeOffset(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ format: System_String? /* System.String */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatC = format?.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TryParseExact(inputC, formatC, formatProviderC, stylesC, &resultC, &__exceptionC)
		
		result = System_DateTimeOffset(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParseExact(_ input: System_String? /* System.String */, _ formats: System_String_Array? /* System.String[] */, _ formatProvider: System_IFormatProvider? /* System.IFormatProvider */, _ styles: System_Globalization_DateTimeStyles /* System.Globalization.DateTimeStyles */, _ result: inout System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let inputC = input?.__handle
		let formatsC = formats?.__handle
		let formatProviderC = formatProvider?.__handle
		let stylesC = styles.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TryParseExact_1(inputC, formatsC, formatProviderC, stylesC, &resultC, &__exceptionC)
		
		result = System_DateTimeOffset(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func deconstruct(_ date: inout System_DateOnly /* System.DateOnly */, _ time: inout System_TimeOnly /* System.TimeOnly */, _ offset: inout System_TimeSpan /* System.TimeSpan */) throws {
		var dateC = date.__handle
		var timeC = time.__handle
		var offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_DateTimeOffset_Deconstruct(self.__handle, &dateC, &timeC, &offsetC, &__exceptionC)
		
		date = System_DateOnly(handle: dateC)
		
		time = System_TimeOnly(handle: timeC)
		
		offset = System_TimeSpan(handle: offsetC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TryParse_2(sC, providerC, &resultC, &__exceptionC)
		
		result = System_DateTimeOffset(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ ticks: Int64 /* System.Int64 */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create(ticks, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ dateTime: System_DateTime /* System.DateTime */) throws {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_1(dateTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ dateTime: System_DateTime /* System.DateTime */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let dateTimeC = dateTime.__handle
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_2(dateTimeC, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ date: System_DateOnly /* System.DateOnly */, _ time: System_TimeOnly /* System.TimeOnly */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let dateC = date.__handle
		let timeC = time.__handle
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_3(dateC, timeC, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_4(year, month, day, hour, minute, second, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_5(year, month, day, hour, minute, second, millisecond, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let calendarC = calendar.__handle
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_6(year, month, day, hour, minute, second, millisecond, calendarC, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_7(year, month, day, hour, minute, second, millisecond, microsecond, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ year: Int32 /* System.Int32 */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */, _ hour: Int32 /* System.Int32 */, _ minute: Int32 /* System.Int32 */, _ second: Int32 /* System.Int32 */, _ millisecond: Int32 /* System.Int32 */, _ microsecond: Int32 /* System.Int32 */, _ calendar: System_Globalization_Calendar /* System.Globalization.Calendar */, _ offset: System_TimeSpan /* System.TimeSpan */) throws {
		let calendarC = calendar.__handle
		let offsetC = offset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_8(year, month, day, hour, minute, second, millisecond, microsecond, calendarC, offsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var utcNow: System_DateTimeOffset /* System.DateTimeOffset */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_UtcNow_Get(&__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dateTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_DateTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var utcDateTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_UtcDateTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var localDateTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_LocalDateTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var date: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Date_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var day: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Day_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var dayOfWeek: System_DayOfWeek /* System.DayOfWeek */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_DayOfWeek_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DayOfWeek(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dayOfYear: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_DayOfYear_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var hour: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Hour_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var millisecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Millisecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var microsecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Microsecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var nanosecond: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Nanosecond_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var minute: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Minute_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var month: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Month_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var offset: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Offset_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var totalOffsetMinutes: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TotalOffsetMinutes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var second: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Second_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var ticks: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Ticks_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var utcTicks: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_UtcTicks_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var timeOfDay: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_TimeOfDay_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var year: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Year_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var now: System_DateTimeOffset /* System.DateTimeOffset */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Now_Get(&__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var minValue: System_DateTimeOffset /* System.DateTimeOffset */ { get {
		
		
		let __returnValueC = System_DateTimeOffset_MinValue_Get()
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_DateTimeOffset /* System.DateTimeOffset */ { get {
		
		
		let __returnValueC = System_DateTimeOffset_MaxValue_Get()
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var unixEpoch: System_DateTimeOffset /* System.DateTimeOffset */ { get {
		
		
		let __returnValueC = System_DateTimeOffset_UnixEpoch_Get()
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_DateTimeOffset_Create_9(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_DateTimeOffset_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_DateTimeOffset_Destroy(self.__handle)
		
	}
	
	
}











public class System_TimeZoneInfo /* System.TimeZoneInfo */: System_Object {
	public override class var typeName: String { get {
		"TimeZoneInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeZoneInfo"
	}}

	public func getAmbiguousTimeOffsets(_ dateTimeOffset: System_DateTimeOffset /* System.DateTimeOffset */) throws -> System_TimeSpan_Array /* System.TimeSpan[] */ {
		let dateTimeOffsetC = dateTimeOffset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetAmbiguousTimeOffsets(self.__handle, dateTimeOffsetC, &__exceptionC)
		
		let __returnValue = System_TimeSpan_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAmbiguousTimeOffsets(_ dateTime: System_DateTime /* System.DateTime */) throws -> System_TimeSpan_Array /* System.TimeSpan[] */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetAmbiguousTimeOffsets_1(self.__handle, dateTimeC, &__exceptionC)
		
		let __returnValue = System_TimeSpan_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getUtcOffset(_ dateTimeOffset: System_DateTimeOffset /* System.DateTimeOffset */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let dateTimeOffsetC = dateTimeOffset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetUtcOffset(self.__handle, dateTimeOffsetC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getUtcOffset(_ dateTime: System_DateTime /* System.DateTime */) throws -> System_TimeSpan /* System.TimeSpan */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetUtcOffset_1(self.__handle, dateTimeC, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isAmbiguousTime(_ dateTimeOffset: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let dateTimeOffsetC = dateTimeOffset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_IsAmbiguousTime(self.__handle, dateTimeOffsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isAmbiguousTime(_ dateTime: System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_IsAmbiguousTime_1(self.__handle, dateTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isDaylightSavingTime(_ dateTimeOffset: System_DateTimeOffset /* System.DateTimeOffset */) throws -> Bool /* System.Boolean */ {
		let dateTimeOffsetC = dateTimeOffset.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_IsDaylightSavingTime(self.__handle, dateTimeOffsetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isDaylightSavingTime(_ dateTime: System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_IsDaylightSavingTime_1(self.__handle, dateTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isInvalidTime(_ dateTime: System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_IsInvalidTime(self.__handle, dateTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clearCachedData() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_TimeZoneInfo_ClearCachedData(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func convertTimeBySystemTimeZoneId(_ dateTimeOffset: System_DateTimeOffset /* System.DateTimeOffset */, _ destinationTimeZoneId: System_String /* System.String */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let dateTimeOffsetC = dateTimeOffset.__handle
		let destinationTimeZoneIdC = destinationTimeZoneId.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTimeBySystemTimeZoneId(dateTimeOffsetC, destinationTimeZoneIdC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTimeBySystemTimeZoneId(_ dateTime: System_DateTime /* System.DateTime */, _ destinationTimeZoneId: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		let destinationTimeZoneIdC = destinationTimeZoneId.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTimeBySystemTimeZoneId_1(dateTimeC, destinationTimeZoneIdC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func findSystemTimeZoneById(_ id: System_String /* System.String */) throws -> System_TimeZoneInfo /* System.TimeZoneInfo */ {
		let idC = id.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_FindSystemTimeZoneById(idC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryFindSystemTimeZoneById(_ id: System_String /* System.String */, _ timeZoneInfo: inout System_TimeZoneInfo? /* System.TimeZoneInfo */) throws -> Bool /* System.Boolean */ {
		let idC = id.__handle
		var timeZoneInfoC = timeZoneInfo?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TryFindSystemTimeZoneById(idC, &timeZoneInfoC, &__exceptionC)
		
		timeZoneInfo = System_TimeZoneInfo(handle: timeZoneInfoC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func convertTimeBySystemTimeZoneId(_ dateTime: System_DateTime /* System.DateTime */, _ sourceTimeZoneId: System_String /* System.String */, _ destinationTimeZoneId: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		let sourceTimeZoneIdC = sourceTimeZoneId.__handle
		let destinationTimeZoneIdC = destinationTimeZoneId.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTimeBySystemTimeZoneId_2(dateTimeC, sourceTimeZoneIdC, destinationTimeZoneIdC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTime(_ dateTimeOffset: System_DateTimeOffset /* System.DateTimeOffset */, _ destinationTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */) throws -> System_DateTimeOffset /* System.DateTimeOffset */ {
		let dateTimeOffsetC = dateTimeOffset.__handle
		let destinationTimeZoneC = destinationTimeZone.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTime_1(dateTimeOffsetC, destinationTimeZoneC, &__exceptionC)
		
		let __returnValue = System_DateTimeOffset(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTime(_ dateTime: System_DateTime /* System.DateTime */, _ destinationTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		let destinationTimeZoneC = destinationTimeZone.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTime_2(dateTimeC, destinationTimeZoneC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTime(_ dateTime: System_DateTime /* System.DateTime */, _ sourceTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */, _ destinationTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		let sourceTimeZoneC = sourceTimeZone.__handle
		let destinationTimeZoneC = destinationTimeZone.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTime_3(dateTimeC, sourceTimeZoneC, destinationTimeZoneC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTimeFromUtc(_ dateTime: System_DateTime /* System.DateTime */, _ destinationTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		let destinationTimeZoneC = destinationTimeZone.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTimeFromUtc(dateTimeC, destinationTimeZoneC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTimeToUtc(_ dateTime: System_DateTime /* System.DateTime */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTimeToUtc(dateTimeC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convertTimeToUtc(_ dateTime: System_DateTime /* System.DateTime */, _ sourceTimeZone: System_TimeZoneInfo /* System.TimeZoneInfo */) throws -> System_DateTime /* System.DateTime */ {
		let dateTimeC = dateTime.__handle
		let sourceTimeZoneC = sourceTimeZone.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ConvertTimeToUtc_1(dateTimeC, sourceTimeZoneC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func equals(_ other: System_TimeZoneInfo? /* System.TimeZoneInfo */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_Equals(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_Equals_1(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromSerializedString(_ source: System_String /* System.String */) throws -> System_TimeZoneInfo /* System.TimeZoneInfo */ {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_FromSerializedString(sourceC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getSystemTimeZones() throws -> System_Collections_ObjectModel_ReadOnlyCollection_A1 /* System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetSystemTimeZones(&__exceptionC)
		
		let __returnValue = System_Collections_ObjectModel_ReadOnlyCollection_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getSystemTimeZones(_ skipSorting: Bool /* System.Boolean */) throws -> System_Collections_ObjectModel_ReadOnlyCollection_A1 /* System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetSystemTimeZones_1(skipSorting, &__exceptionC)
		
		let __returnValue = System_Collections_ObjectModel_ReadOnlyCollection_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func hasSameRules(_ other: System_TimeZoneInfo /* System.TimeZoneInfo */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_HasSameRules(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toSerializedString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ToSerializedString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createCustomTimeZone(_ id: System_String /* System.String */, _ baseUtcOffset: System_TimeSpan /* System.TimeSpan */, _ displayName: System_String? /* System.String */, _ standardDisplayName: System_String? /* System.String */) throws -> System_TimeZoneInfo /* System.TimeZoneInfo */ {
		let idC = id.__handle
		let baseUtcOffsetC = baseUtcOffset.__handle
		let displayNameC = displayName?.__handle
		let standardDisplayNameC = standardDisplayName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_CreateCustomTimeZone(idC, baseUtcOffsetC, displayNameC, standardDisplayNameC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createCustomTimeZone(_ id: System_String /* System.String */, _ baseUtcOffset: System_TimeSpan /* System.TimeSpan */, _ displayName: System_String? /* System.String */, _ standardDisplayName: System_String? /* System.String */, _ daylightDisplayName: System_String? /* System.String */, _ adjustmentRules: System_TimeZoneInfo_AdjustmentRule_Array? /* System.TimeZoneInfo.AdjustmentRule[] */) throws -> System_TimeZoneInfo /* System.TimeZoneInfo */ {
		let idC = id.__handle
		let baseUtcOffsetC = baseUtcOffset.__handle
		let displayNameC = displayName?.__handle
		let standardDisplayNameC = standardDisplayName?.__handle
		let daylightDisplayNameC = daylightDisplayName?.__handle
		let adjustmentRulesC = adjustmentRules?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_CreateCustomTimeZone_1(idC, baseUtcOffsetC, displayNameC, standardDisplayNameC, daylightDisplayNameC, adjustmentRulesC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createCustomTimeZone(_ id: System_String /* System.String */, _ baseUtcOffset: System_TimeSpan /* System.TimeSpan */, _ displayName: System_String? /* System.String */, _ standardDisplayName: System_String? /* System.String */, _ daylightDisplayName: System_String? /* System.String */, _ adjustmentRules: System_TimeZoneInfo_AdjustmentRule_Array? /* System.TimeZoneInfo.AdjustmentRule[] */, _ disableDaylightSavingTime: Bool /* System.Boolean */) throws -> System_TimeZoneInfo /* System.TimeZoneInfo */ {
		let idC = id.__handle
		let baseUtcOffsetC = baseUtcOffset.__handle
		let displayNameC = displayName?.__handle
		let standardDisplayNameC = standardDisplayName?.__handle
		let daylightDisplayNameC = daylightDisplayName?.__handle
		let adjustmentRulesC = adjustmentRules?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_CreateCustomTimeZone_2(idC, baseUtcOffsetC, displayNameC, standardDisplayNameC, daylightDisplayNameC, adjustmentRulesC, disableDaylightSavingTime, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryConvertIanaIdToWindowsId(_ ianaId: System_String /* System.String */, _ windowsId: inout System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let ianaIdC = ianaId.__handle
		var windowsIdC = windowsId?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TryConvertIanaIdToWindowsId(ianaIdC, &windowsIdC, &__exceptionC)
		
		windowsId = System_String(handle: windowsIdC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryConvertWindowsIdToIanaId(_ windowsId: System_String /* System.String */, _ ianaId: inout System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let windowsIdC = windowsId.__handle
		var ianaIdC = ianaId?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TryConvertWindowsIdToIanaId(windowsIdC, &ianaIdC, &__exceptionC)
		
		ianaId = System_String(handle: ianaIdC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryConvertWindowsIdToIanaId(_ windowsId: System_String /* System.String */, _ region: System_String? /* System.String */, _ ianaId: inout System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let windowsIdC = windowsId.__handle
		let regionC = region?.__handle
		var ianaIdC = ianaId?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TryConvertWindowsIdToIanaId_1(windowsIdC, regionC, &ianaIdC, &__exceptionC)
		
		ianaId = System_String(handle: ianaIdC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getAdjustmentRules() throws -> System_TimeZoneInfo_AdjustmentRule_Array /* System.TimeZoneInfo.AdjustmentRule[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_GetAdjustmentRules(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_AdjustmentRule_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var id: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_Id_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var hasIanaId: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_HasIanaId_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var displayName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_DisplayName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var standardName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_StandardName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var daylightName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_DaylightName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var baseUtcOffset: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_BaseUtcOffset_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var supportsDaylightSavingTime: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_SupportsDaylightSavingTime_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var local: System_TimeZoneInfo /* System.TimeZoneInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_Local_Get(&__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var utc: System_TimeZoneInfo /* System.TimeZoneInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_Utc_Get(&__exceptionC)
		
		let __returnValue = System_TimeZoneInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TimeZoneInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_TimeZoneInfo_Destroy(self.__handle)
		
	}
	
	
}




public class System_TimeSpan_Array /* System.TimeSpan[] */: System_Array {
	public override class var typeName: String { get {
		"TimeSpan[]"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeSpan[]"
	}}

	
}

























public class System_TimeZoneInfo_Array /* System.TimeZoneInfo[] */: System_Array {
	public override class var typeName: String { get {
		"TimeZoneInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeZoneInfo[]"
	}}

	
}






public class System_TimeZoneInfo_AdjustmentRule_Array /* System.TimeZoneInfo.AdjustmentRule[] */: System_Array {
	public override class var typeName: String { get {
		"AdjustmentRule[]"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeZoneInfo.AdjustmentRule[]"
	}}

	
}










public class System_TimeZoneInfo_AdjustmentRule /* System.TimeZoneInfo.AdjustmentRule */: System_Object {
	public override class var typeName: String { get {
		"AdjustmentRule"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeZoneInfo.AdjustmentRule"
	}}

	public func equals(_ other: System_TimeZoneInfo_AdjustmentRule? /* System.TimeZoneInfo.AdjustmentRule */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_Equals(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_Equals_1(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createAdjustmentRule(_ dateStart: System_DateTime /* System.DateTime */, _ dateEnd: System_DateTime /* System.DateTime */, _ daylightDelta: System_TimeSpan /* System.TimeSpan */, _ daylightTransitionStart: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */, _ daylightTransitionEnd: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */, _ baseUtcOffsetDelta: System_TimeSpan /* System.TimeSpan */) throws -> System_TimeZoneInfo_AdjustmentRule /* System.TimeZoneInfo.AdjustmentRule */ {
		let dateStartC = dateStart.__handle
		let dateEndC = dateEnd.__handle
		let daylightDeltaC = daylightDelta.__handle
		let daylightTransitionStartC = daylightTransitionStart.__handle
		let daylightTransitionEndC = daylightTransitionEnd.__handle
		let baseUtcOffsetDeltaC = baseUtcOffsetDelta.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_CreateAdjustmentRule(dateStartC, dateEndC, daylightDeltaC, daylightTransitionStartC, daylightTransitionEndC, baseUtcOffsetDeltaC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_AdjustmentRule(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createAdjustmentRule(_ dateStart: System_DateTime /* System.DateTime */, _ dateEnd: System_DateTime /* System.DateTime */, _ daylightDelta: System_TimeSpan /* System.TimeSpan */, _ daylightTransitionStart: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */, _ daylightTransitionEnd: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */) throws -> System_TimeZoneInfo_AdjustmentRule /* System.TimeZoneInfo.AdjustmentRule */ {
		let dateStartC = dateStart.__handle
		let dateEndC = dateEnd.__handle
		let daylightDeltaC = daylightDelta.__handle
		let daylightTransitionStartC = daylightTransitionStart.__handle
		let daylightTransitionEndC = daylightTransitionEnd.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_CreateAdjustmentRule_1(dateStartC, dateEndC, daylightDeltaC, daylightTransitionStartC, daylightTransitionEndC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_AdjustmentRule(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var dateStart: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_DateStart_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dateEnd: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_DateEnd_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var daylightDelta: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_DaylightDelta_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var daylightTransitionStart: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_DaylightTransitionStart_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_TransitionTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var daylightTransitionEnd: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_DaylightTransitionEnd_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_TransitionTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var baseUtcOffsetDelta: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_AdjustmentRule_BaseUtcOffsetDelta_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TimeZoneInfo_AdjustmentRule_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_TimeZoneInfo_AdjustmentRule_Destroy(self.__handle)
		
	}
	
	
}




public class System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */: System_ValueType {
	public override class var typeName: String { get {
		"TransitionTime"
	}}

	public override class var fullTypeName: String { get {
		"System.TimeZoneInfo.TransitionTime"
	}}

	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createFixedDateRule(_ timeOfDay: System_DateTime /* System.DateTime */, _ month: Int32 /* System.Int32 */, _ day: Int32 /* System.Int32 */) throws -> System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */ {
		let timeOfDayC = timeOfDay.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_CreateFixedDateRule(timeOfDayC, month, day, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_TransitionTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createFloatingDateRule(_ timeOfDay: System_DateTime /* System.DateTime */, _ month: Int32 /* System.Int32 */, _ week: Int32 /* System.Int32 */, _ dayOfWeek: System_DayOfWeek /* System.DayOfWeek */) throws -> System_TimeZoneInfo_TransitionTime /* System.TimeZoneInfo.TransitionTime */ {
		let timeOfDayC = timeOfDay.__handle
		let dayOfWeekC = dayOfWeek.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_CreateFloatingDateRule(timeOfDayC, month, week, dayOfWeekC, &__exceptionC)
		
		let __returnValue = System_TimeZoneInfo_TransitionTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var timeOfDay: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_TimeOfDay_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var month: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_Month_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var week: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_Week_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var day: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_Day_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var dayOfWeek: System_DayOfWeek /* System.DayOfWeek */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_DayOfWeek_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DayOfWeek(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isFixedDateRule: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_IsFixedDateRule_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_TimeZoneInfo_TransitionTime_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_TimeZoneInfo_TransitionTime_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_TimeZoneInfo_TransitionTime_Destroy(self.__handle)
		
	}
	
	
}









public class System_Threading_ITimer /* System.Threading.ITimer */: DNObject {
	public override class var typeName: String { get {
		"ITimer"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.ITimer"
	}}

	public func change(_ dueTime: System_TimeSpan /* System.TimeSpan */, _ period: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let dueTimeC = dueTime.__handle
		let periodC = period.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_ITimer_Change(self.__handle, dueTimeC, periodC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ITimer_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_ITimer_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
public class System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<> */: System_Threading_Tasks_Task {
	public override class var typeName: String { get {
		"Task`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.Task<>"
	}}

	public func waitAsync(TResult: System_Type /* System.Type */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Object /* System.Object */ {
		let TResultC = TResult.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_A1_WaitAsync(self.__handle, TResultC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(TResult: System_Type /* System.Type */, _ timeout: System_TimeSpan /* System.TimeSpan */) throws -> System_Object /* System.Object */ {
		let TResultC = TResult.__handle
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_A1_WaitAsync_1(self.__handle, TResultC, timeoutC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(TResult: System_Type /* System.Type */, _ timeout: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider? /* System.TimeProvider */) throws -> System_Object /* System.Object */ {
		let TResultC = TResult.__handle
		let timeoutC = timeout.__handle
		let timeProviderC = timeProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_A1_WaitAsync_2(self.__handle, TResultC, timeoutC, timeProviderC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(TResult: System_Type /* System.Type */, _ timeout: System_TimeSpan /* System.TimeSpan */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Object /* System.Object */ {
		let TResultC = TResult.__handle
		let timeoutC = timeout.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_A1_WaitAsync_3(self.__handle, TResultC, timeoutC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func waitAsync(TResult: System_Type /* System.Type */, _ timeout: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider? /* System.TimeProvider */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Object /* System.Object */ {
		let TResultC = TResult.__handle
		let timeoutC = timeout.__handle
		let timeProviderC = timeProvider?.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_A1_WaitAsync_4(self.__handle, TResultC, timeoutC, timeProviderC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func result(TResult: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Task_A1_Result_Get(self.__handle, TResultC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_Task_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_Task_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "Task`1" was skipped. Reason: It has no full name.
// Type "TResult[]" was skipped. Reason: It has no full name.
// Type "TResult" was skipped. Reason: It has no full name.

public class System_Threading_Tasks_TaskFactory_A1 /* System.Threading.Tasks.TaskFactory<> */: System_Object {
	public override class var typeName: String { get {
		"TaskFactory`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.TaskFactory<>"
	}}

	public convenience init(TResult: System_Type /* System.Type */) throws {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_Create(TResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(TResult: System_Type /* System.Type */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws {
		let TResultC = TResult.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_Create_1(TResultC, cancellationTokenC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(TResult: System_Type /* System.Type */, _ scheduler: System_Threading_Tasks_TaskScheduler? /* System.Threading.Tasks.TaskScheduler */) throws {
		let TResultC = TResult.__handle
		let schedulerC = scheduler?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_Create_2(TResultC, schedulerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(TResult: System_Type /* System.Type */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */, _ continuationOptions: System_Threading_Tasks_TaskContinuationOptions /* System.Threading.Tasks.TaskContinuationOptions */) throws {
		let TResultC = TResult.__handle
		let creationOptionsC = creationOptions.cValue
		let continuationOptionsC = continuationOptions.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_Create_3(TResultC, creationOptionsC, continuationOptionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(TResult: System_Type /* System.Type */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */, _ creationOptions: System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */, _ continuationOptions: System_Threading_Tasks_TaskContinuationOptions /* System.Threading.Tasks.TaskContinuationOptions */, _ scheduler: System_Threading_Tasks_TaskScheduler? /* System.Threading.Tasks.TaskScheduler */) throws {
		let TResultC = TResult.__handle
		let cancellationTokenC = cancellationToken.__handle
		let creationOptionsC = creationOptions.cValue
		let continuationOptionsC = continuationOptions.cValue
		let schedulerC = scheduler?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_Create_4(TResultC, cancellationTokenC, creationOptionsC, continuationOptionsC, schedulerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func cancellationToken(TResult: System_Type /* System.Type */) throws -> System_Threading_CancellationToken /* System.Threading.CancellationToken */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_CancellationToken_Get(self.__handle, TResultC, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationToken(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func scheduler(TResult: System_Type /* System.Type */) throws -> System_Threading_Tasks_TaskScheduler? /* System.Threading.Tasks.TaskScheduler */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_Scheduler_Get(self.__handle, TResultC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskScheduler(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func creationOptions(TResult: System_Type /* System.Type */) throws -> System_Threading_Tasks_TaskCreationOptions /* System.Threading.Tasks.TaskCreationOptions */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_CreationOptions_Get(self.__handle, TResultC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskCreationOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func continuationOptions(TResult: System_Type /* System.Type */) throws -> System_Threading_Tasks_TaskContinuationOptions /* System.Threading.Tasks.TaskContinuationOptions */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_TaskFactory_A1_ContinuationOptions_Get(self.__handle, TResultC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_TaskContinuationOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_TaskFactory_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_TaskFactory_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg3" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
// Type "TArg3" was skipped. Reason: It has no full name.
// Type "TaskFactory`1" was skipped. Reason: It has no full name.
public class System_Runtime_CompilerServices_TaskAwaiter_A1 /* System.Runtime.CompilerServices.TaskAwaiter<> */: System_ValueType {
	public override class var typeName: String { get {
		"TaskAwaiter`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.TaskAwaiter<>"
	}}

	public func onCompleted(TResult: System_Type /* System.Type */, _ continuation: System_Action? /* System.Action */) throws {
		let TResultC = TResult.__handle
		let continuationC = continuation?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_TaskAwaiter_A1_OnCompleted(self.__handle, TResultC, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeOnCompleted(TResult: System_Type /* System.Type */, _ continuation: System_Action? /* System.Action */) throws {
		let TResultC = TResult.__handle
		let continuationC = continuation?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_TaskAwaiter_A1_UnsafeOnCompleted(self.__handle, TResultC, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getResult(TResult: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_TaskAwaiter_A1_GetResult(self.__handle, TResultC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isCompleted(TResult: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_TaskAwaiter_A1_IsCompleted_Get(self.__handle, TResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public convenience init(TResult: System_Type /* System.Type */) throws {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_TaskAwaiter_A1_Create(TResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_TaskAwaiter_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_TaskAwaiter_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "TResult" was skipped. Reason: It has no full name.
// Type "TaskAwaiter`1" was skipped. Reason: It has no full name.
public class System_Runtime_CompilerServices_ConfiguredTaskAwaitable_A1 /* System.Runtime.CompilerServices.ConfiguredTaskAwaitable<> */: System_ValueType {
	public override class var typeName: String { get {
		"ConfiguredTaskAwaitable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ConfiguredTaskAwaitable<>"
	}}

	public convenience init(TResult: System_Type /* System.Type */) throws {
		let TResultC = TResult.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_A1_Create(TResultC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ConfiguredTaskAwaitable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ConfiguredTaskAwaitable_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "ConfiguredTaskAwaitable`1" was skipped. Reason: It has no full name.
// Type "Task`1" was skipped. Reason: It has no full name.
// Type "TResult[]" was skipped. Reason: It has no full name.
// Type "TResult" was skipped. Reason: It has no full name.

// Type "TaskFactory`1" was skipped. Reason: It has no full name.
// Type "TaskAwaiter`1" was skipped. Reason: It has no full name.
// Type "ConfiguredTaskAwaitable`1" was skipped. Reason: It has no full name.








public class System_Runtime_CompilerServices_ValueTaskAwaiter /* System.Runtime.CompilerServices.ValueTaskAwaiter */: System_ValueType {
	public override class var typeName: String { get {
		"ValueTaskAwaiter"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ValueTaskAwaiter"
	}}

	public func getResult() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ValueTaskAwaiter_GetResult(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func onCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ValueTaskAwaiter_OnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeOnCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ValueTaskAwaiter_UnsafeOnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ValueTaskAwaiter_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ValueTaskAwaiter_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ValueTaskAwaiter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ValueTaskAwaiter_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable /* System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable */: System_ValueType {
	public override class var typeName: String { get {
		"ConfiguredValueTaskAwaitable"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable"
	}}

	public func getAwaiter() throws -> System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter /* System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_GetAwaiter(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter /* System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter */: System_ValueType {
	public override class var typeName: String { get {
		"ConfiguredValueTaskAwaiter"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter"
	}}

	public func getResult() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_GetResult(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func onCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_OnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeOnCompleted(_ continuation: System_Action /* System.Action */) throws {
		let continuationC = continuation.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_UnsafeOnCompleted(self.__handle, continuationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var isCompleted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_IsCompleted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_Tasks_Sources_IValueTaskSource /* System.Threading.Tasks.Sources.IValueTaskSource */: DNObject {
	public override class var typeName: String { get {
		"IValueTaskSource"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Tasks.Sources.IValueTaskSource"
	}}

	public func getStatus(_ token: Int16 /* System.Int16 */) throws -> System_Threading_Tasks_Sources_ValueTaskSourceStatus /* System.Threading.Tasks.Sources.ValueTaskSourceStatus */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Tasks_Sources_IValueTaskSource_GetStatus(self.__handle, token, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Sources_ValueTaskSourceStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getResult(_ token: Int16 /* System.Int16 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Tasks_Sources_IValueTaskSource_GetResult(self.__handle, token, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Tasks_Sources_IValueTaskSource_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Tasks_Sources_IValueTaskSource_Destroy(self.__handle)
		
	}
	
	
}










public class Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */: Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid {
	public override class var typeName: String { get {
		"SafeFileHandle"
	}}

	public override class var fullTypeName: String { get {
		"Microsoft.Win32.SafeHandles.SafeFileHandle"
	}}

	public convenience init(_ preexistingHandle: UnsafeMutableRawPointer? /* System.IntPtr */, _ ownsHandle: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeFileHandle_Create(preexistingHandle, ownsHandle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeFileHandle_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var isAsync: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeFileHandle_IsAsync_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override var isInvalid: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Microsoft_Win32_SafeHandles_SafeFileHandle_IsInvalid_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Microsoft_Win32_SafeHandles_SafeFileHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		Microsoft_Win32_SafeHandles_SafeFileHandle_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_FileStreamOptions /* System.IO.FileStreamOptions */: System_Object {
	public override class var typeName: String { get {
		"FileStreamOptions"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileStreamOptions"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var mode: System_IO_FileMode /* System.IO.FileMode */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_Mode_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileMode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func mode_set(_ value: System_IO_FileMode /* System.IO.FileMode */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStreamOptions_Mode_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var access: System_IO_FileAccess /* System.IO.FileAccess */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_Access_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileAccess(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func access_set(_ value: System_IO_FileAccess /* System.IO.FileAccess */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStreamOptions_Access_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var share: System_IO_FileShare /* System.IO.FileShare */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_Share_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileShare(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func share_set(_ value: System_IO_FileShare /* System.IO.FileShare */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStreamOptions_Share_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var options: System_IO_FileOptions /* System.IO.FileOptions */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_Options_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileOptions(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func options_set(_ value: System_IO_FileOptions /* System.IO.FileOptions */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStreamOptions_Options_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var preallocationSize: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_PreallocationSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func preallocationSize_set(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStreamOptions_PreallocationSize_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var bufferSize: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileStreamOptions_BufferSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func bufferSize_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileStreamOptions_BufferSize_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileStreamOptions_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_FileStreamOptions_Destroy(self.__handle)
		
	}
	
	
}






public class System_Reflection_TypeInfo /* System.Reflection.TypeInfo */: System_Type {
	public override class var typeName: String { get {
		"TypeInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.TypeInfo"
	}}

	public func asType() throws -> System_Type /* System.Type */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_AsType(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDeclaredEvent(_ name: System_String /* System.String */) throws -> System_Reflection_EventInfo? /* System.Reflection.EventInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GetDeclaredEvent(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_EventInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDeclaredField(_ name: System_String /* System.String */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GetDeclaredField(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDeclaredMethod(_ name: System_String /* System.String */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GetDeclaredMethod(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDeclaredNestedType(_ name: System_String /* System.String */) throws -> System_Reflection_TypeInfo? /* System.Reflection.TypeInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GetDeclaredNestedType(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_TypeInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDeclaredProperty(_ name: System_String /* System.String */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GetDeclaredProperty(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDeclaredMethods(_ name: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GetDeclaredMethods(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isAssignableFrom(_ typeInfo: System_Reflection_TypeInfo? /* System.Reflection.TypeInfo */) throws -> Bool /* System.Boolean */ {
		let typeInfoC = typeInfo?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_IsAssignableFrom(self.__handle, typeInfoC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var genericTypeParameters: System_Type_Array /* System.Type[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_GenericTypeParameters_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredConstructors: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredConstructors_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredEvents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredEvents_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredFields: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredFields_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredMembers: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredMembers_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredMethods: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredMethods_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredNestedTypes: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredNestedTypes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var declaredProperties: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_DeclaredProperties_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var implementedInterfaces: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Type> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_TypeInfo_ImplementedInterfaces_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_TypeInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_TypeInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_IReflect /* System.Reflection.IReflect */: DNObject {
	public override class var typeName: String { get {
		"IReflect"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.IReflect"
	}}

	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetMethod(self.__handle, nameC, bindingAttrC, binderC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethod(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetMethod_1(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMethods(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetMethods(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getField(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_FieldInfo? /* System.Reflection.FieldInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetField(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFields(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_FieldInfo_Array /* System.Reflection.FieldInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetFields(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_FieldInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetProperty(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperty(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ returnType: System_Type? /* System.Type */, _ types: System_Type_Array /* System.Type[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */) throws -> System_Reflection_PropertyInfo? /* System.Reflection.PropertyInfo */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let returnTypeC = returnType?.__handle
		let typesC = types.__handle
		let modifiersC = modifiers?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetProperty_1(self.__handle, nameC, bindingAttrC, binderC, returnTypeC, typesC, modifiersC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getProperties(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_PropertyInfo_Array /* System.Reflection.PropertyInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetProperties(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_PropertyInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMember(_ name: System_String /* System.String */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let nameC = name.__handle
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetMember(self.__handle, nameC, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMembers(_ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */) throws -> System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */ {
		let bindingAttrC = bindingAttr.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_GetMembers(self.__handle, bindingAttrC, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func invokeMember(_ name: System_String /* System.String */, _ invokeAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ target: System_Object? /* System.Object */, _ args: System_Object_Array? /* System.Object[] */, _ modifiers: System_Reflection_ParameterModifier_Array? /* System.Reflection.ParameterModifier[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ namedParameters: System_String_Array? /* System.String[] */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		let invokeAttrC = invokeAttr.cValue
		let binderC = binder?.__handle
		let targetC = target?.__handle
		let argsC = args?.__handle
		let modifiersC = modifiers?.__handle
		let cultureC = culture?.__handle
		let namedParametersC = namedParameters?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_InvokeMember(self.__handle, nameC, invokeAttrC, binderC, targetC, argsC, modifiersC, cultureC, namedParametersC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var underlyingSystemType: System_Type /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflect_UnderlyingSystemType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_IReflect_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_IReflect_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_MemberInfo_Array /* System.Reflection.MemberInfo[] */: System_Array {
	public override class var typeName: String { get {
		"MemberInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.MemberInfo[]"
	}}

	
}















public class System_Reflection_IReflectableType /* System.Reflection.IReflectableType */: DNObject {
	public override class var typeName: String { get {
		"IReflectableType"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.IReflectableType"
	}}

	public func getTypeInfo() throws -> System_Reflection_TypeInfo /* System.Reflection.TypeInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_IReflectableType_GetTypeInfo(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_TypeInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_IReflectableType_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_IReflectableType_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_EventInfo /* System.Reflection.EventInfo */: System_Reflection_MemberInfo {
	public override class var typeName: String { get {
		"EventInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.EventInfo"
	}}

	public func getOtherMethods() throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetOtherMethods(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getOtherMethods(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetOtherMethods_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAddMethod() throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetAddMethod(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRemoveMethod() throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetRemoveMethod(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRaiseMethod() throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetRaiseMethod(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAddMethod(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetAddMethod_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRemoveMethod(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetRemoveMethod_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getRaiseMethod(_ nonPublic: Bool /* System.Boolean */) throws -> System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetRaiseMethod_1(self.__handle, nonPublic, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addEventHandler(_ target: System_Object? /* System.Object */, _ handler: System_Delegate? /* System.Delegate */) throws {
		let targetC = target?.__handle
		let handlerC = handler?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_EventInfo_AddEventHandler(self.__handle, targetC, handlerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeEventHandler(_ target: System_Object? /* System.Object */, _ handler: System_Delegate? /* System.Delegate */) throws {
		let targetC = target?.__handle
		let handlerC = handler?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Reflection_EventInfo_RemoveEventHandler(self.__handle, targetC, handlerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override var memberType: System_Reflection_MemberTypes /* System.Reflection.MemberTypes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_MemberType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MemberTypes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var attributes: System_Reflection_EventAttributes /* System.Reflection.EventAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_EventAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isSpecialName: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_IsSpecialName_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var addMethod: System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_AddMethod_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var removeMethod: System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_RemoveMethod_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var raiseMethod: System_Reflection_MethodInfo? /* System.Reflection.MethodInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_RaiseMethod_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_MethodInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isMulticast: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_IsMulticast_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var eventHandlerType: System_Type? /* System.Type */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_EventInfo_EventHandlerType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_EventInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_EventInfo_Destroy(self.__handle)
		
	}
	
	
}










public class System_Reflection_ManifestResourceInfo /* System.Reflection.ManifestResourceInfo */: System_Object {
	public override class var typeName: String { get {
		"ManifestResourceInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ManifestResourceInfo"
	}}

	public convenience init(_ containingAssembly: System_Reflection_Assembly? /* System.Reflection.Assembly */, _ containingFileName: System_String? /* System.String */, _ resourceLocation: System_Reflection_ResourceLocation /* System.Reflection.ResourceLocation */) throws {
		let containingAssemblyC = containingAssembly?.__handle
		let containingFileNameC = containingFileName?.__handle
		let resourceLocationC = resourceLocation.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ManifestResourceInfo_Create(containingAssemblyC, containingFileNameC, resourceLocationC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var referencedAssembly: System_Reflection_Assembly? /* System.Reflection.Assembly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ManifestResourceInfo_ReferencedAssembly_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var fileName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ManifestResourceInfo_FileName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var resourceLocation: System_Reflection_ResourceLocation /* System.Reflection.ResourceLocation */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_ManifestResourceInfo_ResourceLocation_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_ResourceLocation(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ManifestResourceInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ManifestResourceInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_ResolveEventArgs /* System.ResolveEventArgs */: System_EventArgs {
	public override class var typeName: String { get {
		"ResolveEventArgs"
	}}

	public override class var fullTypeName: String { get {
		"System.ResolveEventArgs"
	}}

	public convenience init(_ name: System_String /* System.String */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ResolveEventArgs_Create(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ name: System_String /* System.String */, _ requestingAssembly: System_Reflection_Assembly? /* System.Reflection.Assembly */) throws {
		let nameC = name.__handle
		let requestingAssemblyC = requestingAssembly?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ResolveEventArgs_Create_1(nameC, requestingAssemblyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ResolveEventArgs_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var requestingAssembly: System_Reflection_Assembly? /* System.Reflection.Assembly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_ResolveEventArgs_RequestingAssembly_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ResolveEventArgs_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ResolveEventArgs_Destroy(self.__handle)
		
	}
	
	
}


public class System_EventArgs /* System.EventArgs */: System_Object {
	public override class var typeName: String { get {
		"EventArgs"
	}}

	public override class var fullTypeName: String { get {
		"System.EventArgs"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_EventArgs_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var empty: System_EventArgs /* System.EventArgs */ { get {
		
		
		let __returnValueC = System_EventArgs_Empty_Get()
		
		let __returnValue = System_EventArgs(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_EventArgs_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_EventArgs_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_Module_Array /* System.Reflection.Module[] */: System_Array {
	public override class var typeName: String { get {
		"Module[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.Module[]"
	}}

	
}















public class System_Reflection_AssemblyName_Array /* System.Reflection.AssemblyName[] */: System_Array {
	public override class var typeName: String { get {
		"AssemblyName[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.AssemblyName[]"
	}}

	
}















public class System_IO_FileStream_Array /* System.IO.FileStream[] */: System_Array {
	public override class var typeName: String { get {
		"FileStream[]"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileStream[]"
	}}

	
}















public class System_Text_Rune /* System.Text.Rune */: System_ValueType {
	public override class var typeName: String { get {
		"Rune"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.Rune"
	}}

	public func compareTo(_ other: System_Text_Rune /* System.Text.Rune */) throws -> Int32 /* System.Int32 */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_CompareTo(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func decodeFromUtf8(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ result: inout System_Text_Rune /* System.Text.Rune */, _ bytesConsumed: inout Int32 /* System.Int32 */) throws -> System_Buffers_OperationStatus /* System.Buffers.OperationStatus */ {
		let sourceC = source.readOnlySpanOfByte()
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_DecodeFromUtf8(sourceC, &resultC, &bytesConsumed, &__exceptionC)
		
		let __returnValue = System_Buffers_OperationStatus(cValue: __returnValueC)
		
		result = System_Text_Rune(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func decodeLastFromUtf8(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_Text_Rune /* System.Text.Rune */, _ bytesConsumed: inout Int32 /* System.Int32 */) throws -> System_Buffers_OperationStatus /* System.Buffers.OperationStatus */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_DecodeLastFromUtf8(sourceC, &valueC, &bytesConsumed, &__exceptionC)
		
		let __returnValue = System_Buffers_OperationStatus(cValue: __returnValueC)
		
		value = System_Text_Rune(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getRuneAt(_ input: System_String /* System.String */, _ index: Int32 /* System.Int32 */) throws -> System_Text_Rune /* System.Text.Rune */ {
		let inputC = input.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_GetRuneAt(inputC, index, &__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isValid(_ value: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsValid(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isValid(_ value: UInt32 /* System.UInt32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsValid_1(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryCreate(_ ch: DNChar /* System.Char */, _ result: inout System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let chC = ch.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_TryCreate(chC, &resultC, &__exceptionC)
		
		result = System_Text_Rune(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryCreate(_ highSurrogate: DNChar /* System.Char */, _ lowSurrogate: DNChar /* System.Char */, _ result: inout System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let highSurrogateC = highSurrogate.cValue
		let lowSurrogateC = lowSurrogate.cValue
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_TryCreate_1(highSurrogateC, lowSurrogateC, &resultC, &__exceptionC)
		
		result = System_Text_Rune(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryCreate(_ value: Int32 /* System.Int32 */, _ result: inout System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_TryCreate_2(value, &resultC, &__exceptionC)
		
		result = System_Text_Rune(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryCreate(_ value: UInt32 /* System.UInt32 */, _ result: inout System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_TryCreate_3(value, &resultC, &__exceptionC)
		
		result = System_Text_Rune(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryGetRuneAt(_ input: System_String /* System.String */, _ index: Int32 /* System.Int32 */, _ value: inout System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let inputC = input.__handle
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_TryGetRuneAt(inputC, index, &valueC, &__exceptionC)
		
		value = System_Text_Rune(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getNumericValue(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Double /* System.Double */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_GetNumericValue(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getUnicodeCategory(_ value: System_Text_Rune /* System.Text.Rune */) throws -> System_Globalization_UnicodeCategory /* System.Globalization.UnicodeCategory */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_GetUnicodeCategory(valueC, &__exceptionC)
		
		let __returnValue = System_Globalization_UnicodeCategory(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isControl(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsControl(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDigit(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsDigit(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isLetter(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsLetter(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isLetterOrDigit(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsLetterOrDigit(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isLower(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsLower(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNumber(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsNumber(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isPunctuation(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsPunctuation(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isSeparator(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsSeparator(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isSymbol(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsSymbol(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isUpper(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsUpper(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isWhiteSpace(_ value: System_Text_Rune /* System.Text.Rune */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsWhiteSpace(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toLower(_ value: System_Text_Rune /* System.Text.Rune */, _ culture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */) throws -> System_Text_Rune /* System.Text.Rune */ {
		let valueC = value.__handle
		let cultureC = culture.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_ToLower(valueC, cultureC, &__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toLowerInvariant(_ value: System_Text_Rune /* System.Text.Rune */) throws -> System_Text_Rune /* System.Text.Rune */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_ToLowerInvariant(valueC, &__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toUpper(_ value: System_Text_Rune /* System.Text.Rune */, _ culture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */) throws -> System_Text_Rune /* System.Text.Rune */ {
		let valueC = value.__handle
		let cultureC = culture.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_ToUpper(valueC, cultureC, &__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toUpperInvariant(_ value: System_Text_Rune /* System.Text.Rune */) throws -> System_Text_Rune /* System.Text.Rune */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_ToUpperInvariant(valueC, &__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ ch: DNChar /* System.Char */) throws {
		let chC = ch.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Create(chC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ highSurrogate: DNChar /* System.Char */, _ lowSurrogate: DNChar /* System.Char */) throws {
		let highSurrogateC = highSurrogate.cValue
		let lowSurrogateC = lowSurrogate.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Create_1(highSurrogateC, lowSurrogateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Create_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: UInt32 /* System.UInt32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Create_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var isAscii: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsAscii_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isBmp: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_IsBmp_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var plane: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Plane_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var replacementChar: System_Text_Rune /* System.Text.Rune */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_ReplacementChar_Get(&__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var utf16SequenceLength: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Utf16SequenceLength_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var utf8SequenceLength: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Utf8SequenceLength_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var value: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Value_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Rune_Create_4(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_Rune_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_Rune_Destroy(self.__handle)
		
	}
	
	
}







public class System_Globalization_SortKey /* System.Globalization.SortKey */: System_Object {
	public override class var typeName: String { get {
		"SortKey"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.SortKey"
	}}

	public class func compare(_ sortkey1: System_Globalization_SortKey /* System.Globalization.SortKey */, _ sortkey2: System_Globalization_SortKey /* System.Globalization.SortKey */) throws -> Int32 /* System.Int32 */ {
		let sortkey1C = sortkey1.__handle
		let sortkey2C = sortkey2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortKey_Compare(sortkey1C, sortkey2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortKey_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortKey_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortKey_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var originalString: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortKey_OriginalString_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var keyData: System_Byte_Array /* System.Byte[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortKey_KeyData_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_SortKey_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_SortKey_Destroy(self.__handle)
		
	}
	
	
}


public class System_Globalization_SortVersion /* System.Globalization.SortVersion */: System_Object {
	public override class var typeName: String { get {
		"SortVersion"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.SortVersion"
	}}

	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortVersion_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Globalization_SortVersion? /* System.Globalization.SortVersion */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortVersion_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortVersion_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ fullVersion: Int32 /* System.Int32 */, _ sortId: System_Guid /* System.Guid */) throws {
		let sortIdC = sortId.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortVersion_Create(fullVersion, sortIdC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var fullVersion: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortVersion_FullVersion_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var sortId: System_Guid /* System.Guid */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_SortVersion_SortId_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_SortVersion_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_SortVersion_Destroy(self.__handle)
		
	}
	
	
}




public class System_Globalization_TextInfo /* System.Globalization.TextInfo */: System_Object {
	public override class var typeName: String { get {
		"TextInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.TextInfo"
	}}

	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readOnly(_ textInfo: System_Globalization_TextInfo /* System.Globalization.TextInfo */) throws -> System_Globalization_TextInfo /* System.Globalization.TextInfo */ {
		let textInfoC = textInfo.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ReadOnly(textInfoC, &__exceptionC)
		
		let __returnValue = System_Globalization_TextInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLower(_ c: DNChar /* System.Char */) throws -> DNChar /* System.Char */ {
		let cC = c.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ToLower(self.__handle, cC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toLower(_ str: System_String /* System.String */) throws -> System_String /* System.String */ {
		let strC = str.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ToLower_1(self.__handle, strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUpper(_ c: DNChar /* System.Char */) throws -> DNChar /* System.Char */ {
		let cC = c.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ToUpper(self.__handle, cC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toUpper(_ str: System_String /* System.String */) throws -> System_String /* System.String */ {
		let strC = str.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ToUpper_1(self.__handle, strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toTitleCase(_ str: System_String /* System.String */) throws -> System_String /* System.String */ {
		let strC = str.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ToTitleCase(self.__handle, strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var aNSICodePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ANSICodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var oEMCodePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_OEMCodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var macCodePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_MacCodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var eBCDICCodePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_EBCDICCodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var lCID: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_LCID_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var cultureName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_CultureName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var listSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_ListSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func listSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_TextInfo_ListSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isRightToLeft: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_TextInfo_IsRightToLeft_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_TextInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_TextInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */: System_Object {
	public override class var typeName: String { get {
		"NumberFormatInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.NumberFormatInfo"
	}}

	public class func getInstance(_ formatProvider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */ {
		let formatProviderC = formatProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_GetInstance(formatProviderC, &__exceptionC)
		
		let __returnValue = System_Globalization_NumberFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFormat(_ formatType: System_Type? /* System.Type */) throws -> System_Object? /* System.Object */ {
		let formatTypeC = formatType?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_GetFormat(self.__handle, formatTypeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readOnly(_ nfi: System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */) throws -> System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */ {
		let nfiC = nfi.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_ReadOnly(nfiC, &__exceptionC)
		
		let __returnValue = System_Globalization_NumberFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var invariantInfo: System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_InvariantInfo_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_NumberFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var currencyDecimalDigits: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencyDecimalDigits_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func currencyDecimalDigits_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencyDecimalDigits_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var currencyDecimalSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencyDecimalSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func currencyDecimalSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencyDecimalSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var currencyGroupSizes: System_Int32_Array /* System.Int32[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencyGroupSizes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Int32_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func currencyGroupSizes_set(_ value: System_Int32_Array? /* System.Int32[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencyGroupSizes_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var numberGroupSizes: System_Int32_Array /* System.Int32[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NumberGroupSizes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Int32_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func numberGroupSizes_set(_ value: System_Int32_Array? /* System.Int32[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NumberGroupSizes_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentGroupSizes: System_Int32_Array /* System.Int32[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentGroupSizes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Int32_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func percentGroupSizes_set(_ value: System_Int32_Array? /* System.Int32[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentGroupSizes_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var currencyGroupSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencyGroupSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func currencyGroupSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencyGroupSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var currencySymbol: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencySymbol_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func currencySymbol_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencySymbol_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var currentInfo: System_Globalization_NumberFormatInfo /* System.Globalization.NumberFormatInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrentInfo_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_NumberFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var naNSymbol: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NaNSymbol_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func naNSymbol_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NaNSymbol_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var currencyNegativePattern: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencyNegativePattern_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func currencyNegativePattern_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencyNegativePattern_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var numberNegativePattern: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NumberNegativePattern_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func numberNegativePattern_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NumberNegativePattern_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentPositivePattern: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentPositivePattern_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func percentPositivePattern_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentPositivePattern_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentNegativePattern: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentNegativePattern_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func percentNegativePattern_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentNegativePattern_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var negativeInfinitySymbol: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NegativeInfinitySymbol_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func negativeInfinitySymbol_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NegativeInfinitySymbol_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var negativeSign: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NegativeSign_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func negativeSign_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NegativeSign_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var numberDecimalDigits: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NumberDecimalDigits_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func numberDecimalDigits_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NumberDecimalDigits_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var numberDecimalSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NumberDecimalSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func numberDecimalSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NumberDecimalSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var numberGroupSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NumberGroupSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func numberGroupSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NumberGroupSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var currencyPositivePattern: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_CurrencyPositivePattern_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func currencyPositivePattern_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_CurrencyPositivePattern_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var positiveInfinitySymbol: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PositiveInfinitySymbol_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func positiveInfinitySymbol_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PositiveInfinitySymbol_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var positiveSign: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PositiveSign_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func positiveSign_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PositiveSign_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentDecimalDigits: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentDecimalDigits_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func percentDecimalDigits_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentDecimalDigits_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentDecimalSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentDecimalSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func percentDecimalSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentDecimalSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentGroupSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentGroupSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func percentGroupSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentGroupSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var percentSymbol: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PercentSymbol_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func percentSymbol_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PercentSymbol_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var perMilleSymbol: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_PerMilleSymbol_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func perMilleSymbol_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_PerMilleSymbol_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var nativeDigits: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_NativeDigits_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func nativeDigits_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_NativeDigits_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var digitSubstitution: System_Globalization_DigitShapes /* System.Globalization.DigitShapes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_NumberFormatInfo_DigitSubstitution_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_DigitShapes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func digitSubstitution_set(_ value: System_Globalization_DigitShapes /* System.Globalization.DigitShapes */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_NumberFormatInfo_DigitSubstitution_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_NumberFormatInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_NumberFormatInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */: System_Object {
	public override class var typeName: String { get {
		"DateTimeFormatInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.DateTimeFormatInfo"
	}}

	public class func getInstance(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetInstance(providerC, &__exceptionC)
		
		let __returnValue = System_Globalization_DateTimeFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFormat(_ formatType: System_Type? /* System.Type */) throws -> System_Object? /* System.Object */ {
		let formatTypeC = formatType?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetFormat(self.__handle, formatTypeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEra(_ eraName: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let eraNameC = eraName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetEra(self.__handle, eraNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getEraName(_ era: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetEraName(self.__handle, era, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAbbreviatedEraName(_ era: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetAbbreviatedEraName(self.__handle, era, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAbbreviatedDayName(_ dayofweek: System_DayOfWeek /* System.DayOfWeek */) throws -> System_String /* System.String */ {
		let dayofweekC = dayofweek.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetAbbreviatedDayName(self.__handle, dayofweekC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getShortestDayName(_ dayOfWeek: System_DayOfWeek /* System.DayOfWeek */) throws -> System_String /* System.String */ {
		let dayOfWeekC = dayOfWeek.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetShortestDayName(self.__handle, dayOfWeekC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAllDateTimePatterns() throws -> System_String_Array /* System.String[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetAllDateTimePatterns(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAllDateTimePatterns(_ format: DNChar /* System.Char */) throws -> System_String_Array /* System.String[] */ {
		let formatC = format.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetAllDateTimePatterns_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDayName(_ dayofweek: System_DayOfWeek /* System.DayOfWeek */) throws -> System_String /* System.String */ {
		let dayofweekC = dayofweek.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetDayName(self.__handle, dayofweekC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getAbbreviatedMonthName(_ month: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetAbbreviatedMonthName(self.__handle, month, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMonthName(_ month: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_GetMonthName(self.__handle, month, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readOnly(_ dtfi: System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */) throws -> System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */ {
		let dtfiC = dtfi.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_ReadOnly(dtfiC, &__exceptionC)
		
		let __returnValue = System_Globalization_DateTimeFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setAllDateTimePatterns(_ patterns: System_String_Array /* System.String[] */, _ format: DNChar /* System.Char */) throws {
		let patternsC = patterns.__handle
		let formatC = format.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_SetAllDateTimePatterns(self.__handle, patternsC, formatC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var invariantInfo: System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_InvariantInfo_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_DateTimeFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var currentInfo: System_Globalization_DateTimeFormatInfo /* System.Globalization.DateTimeFormatInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_CurrentInfo_Get(&__exceptionC)
		
		let __returnValue = System_Globalization_DateTimeFormatInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var aMDesignator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_AMDesignator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func aMDesignator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_AMDesignator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var calendar: System_Globalization_Calendar /* System.Globalization.Calendar */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_Calendar_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_Calendar(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func calendar_set(_ value: System_Globalization_Calendar? /* System.Globalization.Calendar */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_Calendar_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var dateSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_DateSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func dateSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_DateSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var firstDayOfWeek: System_DayOfWeek /* System.DayOfWeek */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_FirstDayOfWeek_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DayOfWeek(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func firstDayOfWeek_set(_ value: System_DayOfWeek /* System.DayOfWeek */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_FirstDayOfWeek_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var calendarWeekRule: System_Globalization_CalendarWeekRule /* System.Globalization.CalendarWeekRule */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_CalendarWeekRule_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CalendarWeekRule(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func calendarWeekRule_set(_ value: System_Globalization_CalendarWeekRule /* System.Globalization.CalendarWeekRule */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_CalendarWeekRule_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var fullDateTimePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_FullDateTimePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func fullDateTimePattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_FullDateTimePattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var longDatePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_LongDatePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func longDatePattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_LongDatePattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var longTimePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_LongTimePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func longTimePattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_LongTimePattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var monthDayPattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_MonthDayPattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func monthDayPattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_MonthDayPattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var pMDesignator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_PMDesignator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func pMDesignator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_PMDesignator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var rFC1123Pattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_RFC1123Pattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var shortDatePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_ShortDatePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func shortDatePattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_ShortDatePattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var shortTimePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_ShortTimePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func shortTimePattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_ShortTimePattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var sortableDateTimePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_SortableDateTimePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var timeSeparator: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_TimeSeparator_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func timeSeparator_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_TimeSeparator_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var universalSortableDateTimePattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_UniversalSortableDateTimePattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var yearMonthPattern: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_YearMonthPattern_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func yearMonthPattern_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_YearMonthPattern_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var abbreviatedDayNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_AbbreviatedDayNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func abbreviatedDayNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_AbbreviatedDayNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var shortestDayNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_ShortestDayNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func shortestDayNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_ShortestDayNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var dayNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_DayNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func dayNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_DayNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var abbreviatedMonthNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_AbbreviatedMonthNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func abbreviatedMonthNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_AbbreviatedMonthNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var monthNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_MonthNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func monthNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_MonthNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var nativeCalendarName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_NativeCalendarName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var abbreviatedMonthGenitiveNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_AbbreviatedMonthGenitiveNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func abbreviatedMonthGenitiveNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_AbbreviatedMonthGenitiveNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var monthGenitiveNames: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Globalization_DateTimeFormatInfo_MonthGenitiveNames_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func monthGenitiveNames_set(_ value: System_String_Array? /* System.String[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Globalization_DateTimeFormatInfo_MonthGenitiveNames_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Globalization_DateTimeFormatInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Globalization_DateTimeFormatInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Globalization_Calendar_Array /* System.Globalization.Calendar[] */: System_Array {
	public override class var typeName: String { get {
		"Calendar[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Globalization.Calendar[]"
	}}

	
}























// Type "TState" was skipped. Reason: It has no full name.
public class System_Char_Array /* System.Char[] */: System_Array {
	public override class var typeName: String { get {
		"Char[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Char[]"
	}}

	
}










public class System_CharEnumerator /* System.CharEnumerator */: System_Object {
	public override class var typeName: String { get {
		"CharEnumerator"
	}}

	public override class var fullTypeName: String { get {
		"System.CharEnumerator"
	}}

	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_CharEnumerator_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func moveNext() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_CharEnumerator_MoveNext(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_CharEnumerator_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_CharEnumerator_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var current: DNChar /* System.Char */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_CharEnumerator_Current_Get(self.__handle, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_CharEnumerator_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_CharEnumerator_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_StringRuneEnumerator /* System.Text.StringRuneEnumerator */: System_ValueType {
	public override class var typeName: String { get {
		"StringRuneEnumerator"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.StringRuneEnumerator"
	}}

	public func getEnumerator() throws -> System_Text_StringRuneEnumerator /* System.Text.StringRuneEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringRuneEnumerator_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_StringRuneEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func moveNext() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringRuneEnumerator_MoveNext(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var current: System_Text_Rune /* System.Text.Rune */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringRuneEnumerator_Current_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Rune(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringRuneEnumerator_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_StringRuneEnumerator_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_StringRuneEnumerator_Destroy(self.__handle)
		
	}
	
	
}






public class System_Text_CompositeFormat /* System.Text.CompositeFormat */: System_Object {
	public override class var typeName: String { get {
		"CompositeFormat"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.CompositeFormat"
	}}

	public class func parse(_ format: System_String /* System.String */) throws -> System_Text_CompositeFormat /* System.Text.CompositeFormat */ {
		let formatC = format.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_CompositeFormat_Parse(formatC, &__exceptionC)
		
		let __returnValue = System_Text_CompositeFormat(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var format: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_CompositeFormat_Format_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var minimumArgumentCount: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_CompositeFormat_MinimumArgumentCount_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_CompositeFormat_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_CompositeFormat_Destroy(self.__handle)
		
	}
	
	
}


// Type "TArg0" was skipped. Reason: It has no full name.
// Type "TArg0" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg0" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
public class System_Text_Encoding /* System.Text.Encoding */: System_Object {
	public override class var typeName: String { get {
		"Encoding"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.Encoding"
	}}

	public class func convert(_ srcEncoding: System_Text_Encoding /* System.Text.Encoding */, _ dstEncoding: System_Text_Encoding /* System.Text.Encoding */, _ bytes: System_Byte_Array /* System.Byte[] */) throws -> System_Byte_Array /* System.Byte[] */ {
		let srcEncodingC = srcEncoding.__handle
		let dstEncodingC = dstEncoding.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Convert(srcEncodingC, dstEncodingC, bytesC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func convert(_ srcEncoding: System_Text_Encoding /* System.Text.Encoding */, _ dstEncoding: System_Text_Encoding /* System.Text.Encoding */, _ bytes: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Byte_Array /* System.Byte[] */ {
		let srcEncodingC = srcEncoding.__handle
		let dstEncodingC = dstEncoding.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Convert_1(srcEncodingC, dstEncodingC, bytesC, index, count, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func registerProvider(_ provider: System_Text_EncodingProvider /* System.Text.EncodingProvider */) throws {
		let providerC = provider.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Encoding_RegisterProvider(providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getEncoding(_ codepage: Int32 /* System.Int32 */) throws -> System_Text_Encoding /* System.Text.Encoding */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetEncoding(codepage, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getEncoding(_ codepage: Int32 /* System.Int32 */, _ encoderFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */, _ decoderFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */) throws -> System_Text_Encoding /* System.Text.Encoding */ {
		let encoderFallbackC = encoderFallback.__handle
		let decoderFallbackC = decoderFallback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetEncoding_1(codepage, encoderFallbackC, decoderFallbackC, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getEncoding(_ name: System_String /* System.String */) throws -> System_Text_Encoding /* System.Text.Encoding */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetEncoding_2(nameC, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getEncoding(_ name: System_String /* System.String */, _ encoderFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */, _ decoderFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */) throws -> System_Text_Encoding /* System.Text.Encoding */ {
		let nameC = name.__handle
		let encoderFallbackC = encoderFallback.__handle
		let decoderFallbackC = decoderFallback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetEncoding_3(nameC, encoderFallbackC, decoderFallbackC, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getEncodings() throws -> System_Text_EncodingInfo_Array /* System.Text.EncodingInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetEncodings(&__exceptionC)
		
		let __returnValue = System_Text_EncodingInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getPreamble() throws -> System_Byte_Array /* System.Byte[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetPreamble(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getByteCount(_ chars: System_Char_Array /* System.Char[] */) throws -> Int32 /* System.Int32 */ {
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetByteCount(self.__handle, charsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getByteCount(_ s: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetByteCount_1(self.__handle, sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getByteCount(_ chars: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetByteCount_2(self.__handle, charsC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getByteCount(_ s: System_String /* System.String */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetByteCount_3(self.__handle, sC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getBytes(_ chars: System_Char_Array /* System.Char[] */) throws -> System_Byte_Array /* System.Byte[] */ {
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetBytes(self.__handle, charsC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getBytes(_ chars: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Byte_Array /* System.Byte[] */ {
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetBytes_1(self.__handle, charsC, index, count, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getBytes(_ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */, _ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let charsC = chars.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetBytes_2(self.__handle, charsC, charIndex, charCount, bytesC, byteIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getBytes(_ s: System_String /* System.String */) throws -> System_Byte_Array /* System.Byte[] */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetBytes_3(self.__handle, sC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getBytes(_ s: System_String /* System.String */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Byte_Array /* System.Byte[] */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetBytes_4(self.__handle, sC, index, count, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getBytes(_ s: System_String /* System.String */, _ charIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */, _ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let sC = s.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetBytes_5(self.__handle, sC, charIndex, charCount, bytesC, byteIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCharCount(_ bytes: System_Byte_Array /* System.Byte[] */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetCharCount(self.__handle, bytesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCharCount(_ bytes: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetCharCount_1(self.__handle, bytesC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCharCount(_ bytes: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetCharCount_2(self.__handle, bytesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getChars(_ bytes: System_Byte_Array /* System.Byte[] */) throws -> System_Char_Array /* System.Char[] */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetChars(self.__handle, bytesC, &__exceptionC)
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getChars(_ bytes: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Char_Array /* System.Char[] */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetChars_1(self.__handle, bytesC, index, count, &__exceptionC)
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getChars(_ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */, _ byteCount: Int32 /* System.Int32 */, _ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetChars_2(self.__handle, bytesC, byteIndex, byteCount, charsC, charIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getString(_ bytes: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_String /* System.String */ {
		let bytesC = bytes.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetString(self.__handle, bytesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isAlwaysNormalized() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsAlwaysNormalized(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isAlwaysNormalized(_ form: System_Text_NormalizationForm /* System.Text.NormalizationForm */) throws -> Bool /* System.Boolean */ {
		let formC = form.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsAlwaysNormalized_1(self.__handle, formC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getDecoder() throws -> System_Text_Decoder /* System.Text.Decoder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetDecoder(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Decoder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEncoder() throws -> System_Text_Encoder /* System.Text.Encoder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetEncoder(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Encoder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getMaxByteCount(_ charCount: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetMaxByteCount(self.__handle, charCount, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getMaxCharCount(_ byteCount: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetMaxCharCount(self.__handle, byteCount, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getString(_ bytes: System_Byte_Array /* System.Byte[] */) throws -> System_String /* System.String */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetString_1(self.__handle, bytesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getString(_ bytes: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetString_2(self.__handle, bytesC, index, count, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createTranscodingStream(_ innerStream: System_IO_Stream /* System.IO.Stream */, _ innerStreamEncoding: System_Text_Encoding /* System.Text.Encoding */, _ outerStreamEncoding: System_Text_Encoding /* System.Text.Encoding */, _ leaveOpen: Bool /* System.Boolean */) throws -> System_IO_Stream /* System.IO.Stream */ {
		let innerStreamC = innerStream.__handle
		let innerStreamEncodingC = innerStreamEncoding.__handle
		let outerStreamEncodingC = outerStreamEncoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_CreateTranscodingStream(innerStreamC, innerStreamEncodingC, outerStreamEncodingC, leaveOpen, &__exceptionC)
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var `default`: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Default_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var preamble: Data? /* System.ReadOnlySpan<System.Byte> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Preamble_Get(self.__handle, &__exceptionC)
		
		let __returnValue = __returnValueC.data()
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var bodyName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_BodyName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var encodingName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_EncodingName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var headerName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_HeaderName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var webName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_WebName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var windowsCodePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_WindowsCodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isBrowserDisplay: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsBrowserDisplay_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isBrowserSave: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsBrowserSave_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isMailNewsDisplay: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsMailNewsDisplay_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isMailNewsSave: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsMailNewsSave_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSingleByte: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsSingleByte_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var encoderFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_EncoderFallback_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_EncoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func encoderFallback_set(_ value: System_Text_EncoderFallback? /* System.Text.EncoderFallback */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Encoding_EncoderFallback_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var decoderFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_DecoderFallback_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_DecoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func decoderFallback_set(_ value: System_Text_DecoderFallback? /* System.Text.DecoderFallback */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Encoding_DecoderFallback_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var aSCII: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_ASCII_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var latin1: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Latin1_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var codePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_CodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var unicode: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_Unicode_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var bigEndianUnicode: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_BigEndianUnicode_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var uTF7: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_UTF7_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var uTF8: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_UTF8_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var uTF32: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoding_UTF32_Get(&__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_Encoding_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_Encoding_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_EncodingProvider /* System.Text.EncodingProvider */: System_Object {
	public override class var typeName: String { get {
		"EncodingProvider"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.EncodingProvider"
	}}

	public func getEncoding(_ name: System_String /* System.String */) throws -> System_Text_Encoding? /* System.Text.Encoding */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingProvider_GetEncoding(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEncoding(_ codepage: Int32 /* System.Int32 */) throws -> System_Text_Encoding? /* System.Text.Encoding */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingProvider_GetEncoding_1(self.__handle, codepage, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEncoding(_ name: System_String /* System.String */, _ encoderFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */, _ decoderFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */) throws -> System_Text_Encoding? /* System.Text.Encoding */ {
		let nameC = name.__handle
		let encoderFallbackC = encoderFallback.__handle
		let decoderFallbackC = decoderFallback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingProvider_GetEncoding_2(self.__handle, nameC, encoderFallbackC, decoderFallbackC, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEncoding(_ codepage: Int32 /* System.Int32 */, _ encoderFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */, _ decoderFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */) throws -> System_Text_Encoding? /* System.Text.Encoding */ {
		let encoderFallbackC = encoderFallback.__handle
		let decoderFallbackC = decoderFallback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingProvider_GetEncoding_3(self.__handle, codepage, encoderFallbackC, decoderFallbackC, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEncodings() throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.Text.EncodingInfo> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingProvider_GetEncodings(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_EncodingProvider_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_EncodingProvider_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_EncoderFallback /* System.Text.EncoderFallback */: System_Object {
	public override class var typeName: String { get {
		"EncoderFallback"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.EncoderFallback"
	}}

	public func createFallbackBuffer() throws -> System_Text_EncoderFallbackBuffer /* System.Text.EncoderFallbackBuffer */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallback_CreateFallbackBuffer(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_EncoderFallbackBuffer(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var replacementFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallback_ReplacementFallback_Get(&__exceptionC)
		
		let __returnValue = System_Text_EncoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var exceptionFallback: System_Text_EncoderFallback /* System.Text.EncoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallback_ExceptionFallback_Get(&__exceptionC)
		
		let __returnValue = System_Text_EncoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var maxCharCount: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallback_MaxCharCount_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_EncoderFallback_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_EncoderFallback_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_EncoderFallbackBuffer /* System.Text.EncoderFallbackBuffer */: System_Object {
	public override class var typeName: String { get {
		"EncoderFallbackBuffer"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.EncoderFallbackBuffer"
	}}

	public func fallback(_ charUnknown: DNChar /* System.Char */, _ index: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let charUnknownC = charUnknown.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallbackBuffer_Fallback(self.__handle, charUnknownC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func fallback(_ charUnknownHigh: DNChar /* System.Char */, _ charUnknownLow: DNChar /* System.Char */, _ index: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let charUnknownHighC = charUnknownHigh.cValue
		let charUnknownLowC = charUnknownLow.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallbackBuffer_Fallback_1(self.__handle, charUnknownHighC, charUnknownLowC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getNextChar() throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallbackBuffer_GetNextChar(self.__handle, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func movePrevious() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallbackBuffer_MovePrevious(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_EncoderFallbackBuffer_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var remaining: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncoderFallbackBuffer_Remaining_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_EncoderFallbackBuffer_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_EncoderFallbackBuffer_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_DecoderFallback /* System.Text.DecoderFallback */: System_Object {
	public override class var typeName: String { get {
		"DecoderFallback"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.DecoderFallback"
	}}

	public func createFallbackBuffer() throws -> System_Text_DecoderFallbackBuffer /* System.Text.DecoderFallbackBuffer */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallback_CreateFallbackBuffer(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_DecoderFallbackBuffer(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var replacementFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallback_ReplacementFallback_Get(&__exceptionC)
		
		let __returnValue = System_Text_DecoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var exceptionFallback: System_Text_DecoderFallback /* System.Text.DecoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallback_ExceptionFallback_Get(&__exceptionC)
		
		let __returnValue = System_Text_DecoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var maxCharCount: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallback_MaxCharCount_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_DecoderFallback_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_DecoderFallback_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_DecoderFallbackBuffer /* System.Text.DecoderFallbackBuffer */: System_Object {
	public override class var typeName: String { get {
		"DecoderFallbackBuffer"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.DecoderFallbackBuffer"
	}}

	public func fallback(_ bytesUnknown: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let bytesUnknownC = bytesUnknown.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallbackBuffer_Fallback(self.__handle, bytesUnknownC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getNextChar() throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallbackBuffer_GetNextChar(self.__handle, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func movePrevious() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallbackBuffer_MovePrevious(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_DecoderFallbackBuffer_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var remaining: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_DecoderFallbackBuffer_Remaining_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_DecoderFallbackBuffer_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_DecoderFallbackBuffer_Destroy(self.__handle)
		
	}
	
	
}






public class System_Text_EncodingInfo /* System.Text.EncodingInfo */: System_Object {
	public override class var typeName: String { get {
		"EncodingInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.EncodingInfo"
	}}

	public func getEncoding() throws -> System_Text_Encoding /* System.Text.Encoding */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_GetEncoding(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_Equals(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ provider: System_Text_EncodingProvider /* System.Text.EncodingProvider */, _ codePage: Int32 /* System.Int32 */, _ name: System_String /* System.String */, _ displayName: System_String /* System.String */) throws {
		let providerC = provider.__handle
		let nameC = name.__handle
		let displayNameC = displayName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_Create(providerC, codePage, nameC, displayNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var codePage: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_CodePage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var displayName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_EncodingInfo_DisplayName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_EncodingInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_EncodingInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_EncodingInfo_Array /* System.Text.EncodingInfo[] */: System_Array {
	public override class var typeName: String { get {
		"EncodingInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.EncodingInfo[]"
	}}

	
}











public class System_Text_Decoder /* System.Text.Decoder */: System_Object {
	public override class var typeName: String { get {
		"Decoder"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.Decoder"
	}}

	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Decoder_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getCharCount(_ bytes: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_GetCharCount(self.__handle, bytesC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCharCount(_ bytes: System_Byte_Array /* System.Byte[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ flush: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_GetCharCount_1(self.__handle, bytesC, index, count, flush, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCharCount(_ bytes: Data? /* System.ReadOnlySpan<System.Byte> */, _ flush: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_GetCharCount_2(self.__handle, bytesC, flush, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getChars(_ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */, _ byteCount: Int32 /* System.Int32 */, _ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_GetChars(self.__handle, bytesC, byteIndex, byteCount, charsC, charIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getChars(_ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */, _ byteCount: Int32 /* System.Int32 */, _ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */, _ flush: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let bytesC = bytes.__handle
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_GetChars_1(self.__handle, bytesC, byteIndex, byteCount, charsC, charIndex, flush, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func convert(_ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */, _ byteCount: Int32 /* System.Int32 */, _ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */, _ flush: Bool /* System.Boolean */, _ bytesUsed: inout Int32 /* System.Int32 */, _ charsUsed: inout Int32 /* System.Int32 */, _ completed: inout Bool /* System.Boolean */) throws {
		let bytesC = bytes.__handle
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Decoder_Convert(self.__handle, bytesC, byteIndex, byteCount, charsC, charIndex, charCount, flush, &bytesUsed, &charsUsed, &completed, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var fallback: System_Text_DecoderFallback? /* System.Text.DecoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_Fallback_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_DecoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func fallback_set(_ value: System_Text_DecoderFallback? /* System.Text.DecoderFallback */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Decoder_Fallback_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var fallbackBuffer: System_Text_DecoderFallbackBuffer /* System.Text.DecoderFallbackBuffer */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Decoder_FallbackBuffer_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_DecoderFallbackBuffer(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_Decoder_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_Decoder_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_Encoder /* System.Text.Encoder */: System_Object {
	public override class var typeName: String { get {
		"Encoder"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.Encoder"
	}}

	public func reset() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Encoder_Reset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getByteCount(_ chars: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ flush: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let charsC = chars.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoder_GetByteCount(self.__handle, charsC, index, count, flush, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getBytes(_ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */, _ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */, _ flush: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		let charsC = chars.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoder_GetBytes(self.__handle, charsC, charIndex, charCount, bytesC, byteIndex, flush, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func convert(_ chars: System_Char_Array /* System.Char[] */, _ charIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */, _ bytes: System_Byte_Array /* System.Byte[] */, _ byteIndex: Int32 /* System.Int32 */, _ byteCount: Int32 /* System.Int32 */, _ flush: Bool /* System.Boolean */, _ charsUsed: inout Int32 /* System.Int32 */, _ bytesUsed: inout Int32 /* System.Int32 */, _ completed: inout Bool /* System.Boolean */) throws {
		let charsC = chars.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Encoder_Convert(self.__handle, charsC, charIndex, charCount, bytesC, byteIndex, byteCount, flush, &charsUsed, &bytesUsed, &completed, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var fallback: System_Text_EncoderFallback? /* System.Text.EncoderFallback */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoder_Fallback_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_EncoderFallback(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func fallback_set(_ value: System_Text_EncoderFallback? /* System.Text.EncoderFallback */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_Encoder_Fallback_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var fallbackBuffer: System_Text_EncoderFallbackBuffer /* System.Text.EncoderFallbackBuffer */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_Encoder_FallbackBuffer_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_EncoderFallbackBuffer(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_Encoder_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_Encoder_Destroy(self.__handle)
		
	}
	
	
}


// Type "TEnum" was skipped. Reason: It has no full name.
// Type "TEnum[]" was skipped. Reason: It has no full name.
// Type "TEnum" was skipped. Reason: It has no full name.

// Type "TEnum" was skipped. Reason: It has no full name.
// Type "TEnum" was skipped. Reason: It has no full name.
// Type "TEnum" was skipped. Reason: It has no full name.
// Type "TEnum" was skipped. Reason: It has no full name.
// Type "TEnum" was skipped. Reason: It has no full name.
// Type "TEnum" was skipped. Reason: It has no full name.

// Type "TEnum" was skipped. Reason: It has no full name.

// Type "TEnum" was skipped. Reason: It has no full name.

// Type "TEnum" was skipped. Reason: It has no full name.

// Type "TEnum" was skipped. Reason: It has no full name.














































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.








// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.


public class System_Int64_Array /* System.Int64[] */: System_Array {
	public override class var typeName: String { get {
		"Int64[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Int64[]"
	}}

	
}














// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "TOutput[]" was skipped. Reason: It has no full name.
// Type "TOutput" was skipped. Reason: It has no full name.

// Type "TInput[]" was skipped. Reason: It has no full name.
// Type "TInput" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "TKey[]" was skipped. Reason: It has no full name.
// Type "TKey" was skipped. Reason: It has no full name.

// Type "TValue[]" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "TKey[]" was skipped. Reason: It has no full name.
// Type "TKey" was skipped. Reason: It has no full name.

// Type "TValue[]" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "TKey[]" was skipped. Reason: It has no full name.
// Type "TKey" was skipped. Reason: It has no full name.

// Type "TValue[]" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "TKey[]" was skipped. Reason: It has no full name.
// Type "TKey" was skipped. Reason: It has no full name.

// Type "TValue[]" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.













public class System_Runtime_InteropServices_StructLayoutAttribute /* System.Runtime.InteropServices.StructLayoutAttribute */: System_Attribute {
	public override class var typeName: String { get {
		"StructLayoutAttribute"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.InteropServices.StructLayoutAttribute"
	}}

	public convenience init(_ layoutKind: System_Runtime_InteropServices_LayoutKind /* System.Runtime.InteropServices.LayoutKind */) throws {
		let layoutKindC = layoutKind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_StructLayoutAttribute_Create(layoutKindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ layoutKind: Int16 /* System.Int16 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_StructLayoutAttribute_Create_1(layoutKind, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var value: System_Runtime_InteropServices_LayoutKind /* System.Runtime.InteropServices.LayoutKind */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_StructLayoutAttribute_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Runtime_InteropServices_LayoutKind(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var pack: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = System_Runtime_InteropServices_StructLayoutAttribute_Pack_Get(self.__handle)
		
		return __returnValueC
		
	}}
	public func pack_set(_ value: Int32 /* System.Int32 */) {
		
		
		System_Runtime_InteropServices_StructLayoutAttribute_Pack_Set(self.__handle, value)
		
		
	}
	
	
	public var size: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = System_Runtime_InteropServices_StructLayoutAttribute_Size_Get(self.__handle)
		
		return __returnValueC
		
	}}
	public func size_set(_ value: Int32 /* System.Int32 */) {
		
		
		System_Runtime_InteropServices_StructLayoutAttribute_Size_Set(self.__handle, value)
		
		
	}
	
	
	public var charSet: System_Runtime_InteropServices_CharSet /* System.Runtime.InteropServices.CharSet */ { get {
		
		
		let __returnValueC = System_Runtime_InteropServices_StructLayoutAttribute_CharSet_Get(self.__handle)
		
		let __returnValue = System_Runtime_InteropServices_CharSet(cValue: __returnValueC)
		
		return __returnValue
		
	}}
	public func charSet_set(_ value: System_Runtime_InteropServices_CharSet /* System.Runtime.InteropServices.CharSet */) {
		let valueC = value.cValue
		
		
		System_Runtime_InteropServices_StructLayoutAttribute_CharSet_Set(self.__handle, valueC)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_StructLayoutAttribute_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_InteropServices_StructLayoutAttribute_Destroy(self.__handle)
		
	}
	
	
}


public class System_Attribute /* System.Attribute */: System_Object {
	public override class var typeName: String { get {
		"Attribute"
	}}

	public override class var fullTypeName: String { get {
		"System.Attribute"
	}}

	public class func getCustomAttributes(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_1(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_2(elementC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_3(elementC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isDefined(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ attributeType: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined(elementC, attributeTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDefined(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_1(elementC, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_1(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_2(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_4(elementC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_5(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_6(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_7(elementC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isDefined(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ attributeType: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_2(elementC, attributeTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDefined(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_3(elementC, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_3(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_ParameterInfo /* System.Reflection.ParameterInfo */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_4(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Module /* System.Reflection.Module */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_8(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Module /* System.Reflection.Module */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_9(elementC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Module /* System.Reflection.Module */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_10(elementC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Module /* System.Reflection.Module */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_11(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isDefined(_ element: System_Reflection_Module /* System.Reflection.Module */, _ attributeType: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_4(elementC, attributeTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDefined(_ element: System_Reflection_Module /* System.Reflection.Module */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_5(elementC, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_Module /* System.Reflection.Module */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_5(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_Module /* System.Reflection.Module */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_6(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_12(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_13(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_14(elementC, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttributes(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute_Array /* System.Attribute[] */ {
		let elementC = element.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttributes_15(elementC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isDefined(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ attributeType: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_6(elementC, attributeTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isDefined(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefined_7(elementC, attributeTypeC, inherit, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ attributeType: System_Type /* System.Type */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_7(elementC, attributeTypeC, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCustomAttribute(_ element: System_Reflection_Assembly /* System.Reflection.Assembly */, _ attributeType: System_Type /* System.Type */, _ inherit: Bool /* System.Boolean */) throws -> System_Attribute? /* System.Attribute */ {
		let elementC = element.__handle
		let attributeTypeC = attributeType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetCustomAttribute_8(elementC, attributeTypeC, inherit, &__exceptionC)
		
		let __returnValue = System_Attribute(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func match(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_Match(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isDefaultAttribute() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_IsDefaultAttribute(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var typeId: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Attribute_TypeId_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Attribute_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Attribute_Destroy(self.__handle)
		
	}
	
	
}


public class System_Attribute_Array /* System.Attribute[] */: System_Array {
	public override class var typeName: String { get {
		"Attribute[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Attribute[]"
	}}

	
}















public class System_Reflection_ConstructorInfo_Array /* System.Reflection.ConstructorInfo[] */: System_Array {
	public override class var typeName: String { get {
		"ConstructorInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.ConstructorInfo[]"
	}}

	
}











public class System_Reflection_EventInfo_Array /* System.Reflection.EventInfo[] */: System_Array {
	public override class var typeName: String { get {
		"EventInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.EventInfo[]"
	}}

	
}











public class System_Reflection_InterfaceMapping /* System.Reflection.InterfaceMapping */: System_ValueType {
	public override class var typeName: String { get {
		"InterfaceMapping"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.InterfaceMapping"
	}}

	public var targetType: System_Type /* System.Type */ { get {
		
		
		let __returnValueC = System_Reflection_InterfaceMapping_TargetType_Get(self.__handle)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func targetType_set(_ value: System_Type? /* System.Type */) {
		let valueC = value?.__handle
		
		
		System_Reflection_InterfaceMapping_TargetType_Set(self.__handle, valueC)
		
		
	}
	
	
	public var interfaceType: System_Type /* System.Type */ { get {
		
		
		let __returnValueC = System_Reflection_InterfaceMapping_InterfaceType_Get(self.__handle)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func interfaceType_set(_ value: System_Type? /* System.Type */) {
		let valueC = value?.__handle
		
		
		System_Reflection_InterfaceMapping_InterfaceType_Set(self.__handle, valueC)
		
		
	}
	
	
	public var targetMethods: System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ { get {
		
		
		let __returnValueC = System_Reflection_InterfaceMapping_TargetMethods_Get(self.__handle)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func targetMethods_set(_ value: System_Reflection_MethodInfo_Array? /* System.Reflection.MethodInfo[] */) {
		let valueC = value?.__handle
		
		
		System_Reflection_InterfaceMapping_TargetMethods_Set(self.__handle, valueC)
		
		
	}
	
	
	public var interfaceMethods: System_Reflection_MethodInfo_Array /* System.Reflection.MethodInfo[] */ { get {
		
		
		let __returnValueC = System_Reflection_InterfaceMapping_InterfaceMethods_Get(self.__handle)
		
		let __returnValue = System_Reflection_MethodInfo_Array(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func interfaceMethods_set(_ value: System_Reflection_MethodInfo_Array? /* System.Reflection.MethodInfo[] */) {
		let valueC = value?.__handle
		
		
		System_Reflection_InterfaceMapping_InterfaceMethods_Set(self.__handle, valueC)
		
		
	}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Reflection_InterfaceMapping_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_InterfaceMapping_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_InterfaceMapping_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_InteropServices_Marshal /* System.Runtime.InteropServices.Marshal */: System_Object {
	public override class var typeName: String { get {
		"Marshal"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.InteropServices.Marshal"
	}}

	public class func offsetOf(_ t: System_Type /* System.Type */, _ fieldName: System_String /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let tC = t.__handle
		let fieldNameC = fieldName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_OffsetOf(tC, fieldNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readByte(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */) throws -> UInt8 /* System.Byte */ {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadByte(ptrC, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt16(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */) throws -> Int16 /* System.Int16 */ {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt16(ptrC, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt32(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt32(ptrC, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt64(_ ptr: inout System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */) throws -> Int64 /* System.Int64 */ {
		var ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt64(&ptrC, ofs, &__exceptionC)
		
		ptr = System_Object(handle: ptrC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func writeByte(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */, _ val: UInt8 /* System.Byte */) throws {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteByte(ptrC, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeInt32(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */, _ val: Int32 /* System.Int32 */) throws {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteInt32(ptrC, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeInt64(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */, _ val: Int64 /* System.Int64 */) throws {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteInt64(ptrC, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastPInvokeError() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetLastPInvokeError(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func setLastPInvokeError(_ error: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_SetLastPInvokeError(error, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getExceptionPointers() throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetExceptionPointers(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getExceptionCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetExceptionCode(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func structureToPtr(_ structure: System_Object /* System.Object */, _ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ fDeleteOld: Bool /* System.Boolean */) throws {
		let structureC = structure.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_StructureToPtr(structureC, ptr, fDeleteOld, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func destroyStructure(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ structuretype: System_Type /* System.Type */) throws {
		let structuretypeC = structuretype.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_DestroyStructure(ptr, structuretypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func allocHGlobal(_ cb: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_AllocHGlobal(cb, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func ptrToStringAnsi(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringAnsi(ptr, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStringAnsi(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ len: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringAnsi_1(ptr, len, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStringUni(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringUni(ptr, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStringUni(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ len: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringUni_1(ptr, len, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStringUTF8(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringUTF8(ptr, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStringUTF8(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ byteLen: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringUTF8_1(ptr, byteLen, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sizeOf(_ structure: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let structureC = structure.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SizeOf(structureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sizeOf(T: System_Type /* System.Type */, _ structure: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let structureC = structure?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SizeOf_A1(TC, structureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sizeOf(_ t: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SizeOf_1(tC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sizeOf(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SizeOf_A1_1(TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func queryInterface(_ pUnk: UnsafeMutableRawPointer? /* System.IntPtr */, _ iid: inout System_Guid /* System.Guid */, _ ppv: inout UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int32 /* System.Int32 */ {
		var iidC = iid.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_QueryInterface(pUnk, &iidC, &ppv, &__exceptionC)
		
		iid = System_Guid(handle: iidC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func addRef(_ pUnk: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_AddRef(pUnk, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func release(_ pUnk: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_Release(pUnk, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func unsafeAddrOfPinnedArrayElement(_ arr: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let arrC = arr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_UnsafeAddrOfPinnedArrayElement(arrC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func unsafeAddrOfPinnedArrayElement(T: System_Type /* System.Type */, _ arr: System_Array? /* System.Array */, _ index: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let TC = T.__handle
		let arrC = arr?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_UnsafeAddrOfPinnedArrayElement_A1(TC, arrC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func offsetOf(T: System_Type /* System.Type */, _ fieldName: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let TC = T.__handle
		let fieldNameC = fieldName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_OffsetOf_A1(TC, fieldNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func copy(_ source: System_Int32_Array /* System.Int32[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_1(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_Int16_Array /* System.Int16[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_2(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_Int64_Array /* System.Int64[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_3(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_Single_Array /* System.Single[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_4(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_Double_Array /* System.Double[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_5(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_Byte_Array /* System.Byte[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_6(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: System_IntPtr_Array /* System.IntPtr[] */, _ startIndex: Int32 /* System.Int32 */, _ destination: UnsafeMutableRawPointer? /* System.IntPtr */, _ length: Int32 /* System.Int32 */) throws {
		let sourceC = source.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_7(sourceC, startIndex, destination, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Int32_Array /* System.Int32[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_8(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Char_Array /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_9(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Int16_Array /* System.Int16[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_10(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Int64_Array /* System.Int64[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_11(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Single_Array /* System.Single[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_12(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Double_Array /* System.Double[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_13(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_Byte_Array /* System.Byte[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_14(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ source: UnsafeMutableRawPointer? /* System.IntPtr */, _ destination: System_IntPtr_Array /* System.IntPtr[] */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Copy_15(source, destinationC, startIndex, length, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func readByte(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadByte_1(ptr, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readByte(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadByte_2(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt16(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt16_1(ptr, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt16(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt16_2(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt32(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt32_1(ptr, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt32(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt32_2(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readIntPtr(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadIntPtr(ptrC, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readIntPtr(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadIntPtr_1(ptr, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readIntPtr(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadIntPtr_2(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt64(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt64_1(ptr, ofs, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt64(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReadInt64_2(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func writeByte(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */, _ val: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteByte_1(ptr, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeByte(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ val: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteByte_2(ptr, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeInt32(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */, _ val: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteInt32_1(ptr, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeInt32(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ val: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteInt32_2(ptr, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeIntPtr(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */, _ val: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteIntPtr(ptr, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeIntPtr(_ ptr: System_Object /* System.Object */, _ ofs: Int32 /* System.Int32 */, _ val: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		let ptrC = ptr.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteIntPtr_1(ptrC, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeIntPtr(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ val: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteIntPtr_2(ptr, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeInt64(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ ofs: Int32 /* System.Int32 */, _ val: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteInt64_1(ptr, ofs, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeInt64(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ val: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_WriteInt64_2(ptr, val, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func prelink(_ m: System_Reflection_MethodInfo /* System.Reflection.MethodInfo */) throws {
		let mC = m.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_Prelink(mC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func prelinkAll(_ c: System_Type /* System.Type */) throws {
		let cC = c.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_PrelinkAll(cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func structureToPtr(T: System_Type /* System.Type */, _ structure: System_Object? /* System.Object */, _ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ fDeleteOld: Bool /* System.Boolean */) throws {
		let TC = T.__handle
		let structureC = structure?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_StructureToPtr_A1(TC, structureC, ptr, fDeleteOld, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func ptrToStructure(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ structureType: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let structureTypeC = structureType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStructure(ptr, structureTypeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStructure(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ structure: System_Object /* System.Object */) throws {
		let structureC = structure.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_PtrToStructure_1(ptr, structureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func ptrToStructure(T: System_Type /* System.Type */, _ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ structure: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let structureC = structure?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_PtrToStructure_A1(TC, ptr, structureC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func ptrToStructure(T: System_Type /* System.Type */, _ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStructure_A1_1(TC, ptr, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func destroyStructure(T: System_Type /* System.Type */, _ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_DestroyStructure_A1(TC, ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getHINSTANCE(_ m: System_Reflection_Module /* System.Reflection.Module */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let mC = m.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetHINSTANCE(mC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getExceptionForHR(_ errorCode: Int32 /* System.Int32 */) throws -> System_Exception? /* System.Exception */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetExceptionForHR(errorCode, &__exceptionC)
		
		let __returnValue = System_Exception(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getExceptionForHR(_ errorCode: Int32 /* System.Int32 */, _ errorInfo: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Exception? /* System.Exception */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetExceptionForHR_1(errorCode, errorInfo, &__exceptionC)
		
		let __returnValue = System_Exception(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func throwExceptionForHR(_ errorCode: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ThrowExceptionForHR(errorCode, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func throwExceptionForHR(_ errorCode: Int32 /* System.Int32 */, _ errorInfo: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ThrowExceptionForHR_1(errorCode, errorInfo, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func secureStringToBSTR(_ s: System_Security_SecureString /* System.Security.SecureString */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SecureStringToBSTR(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func secureStringToCoTaskMemAnsi(_ s: System_Security_SecureString /* System.Security.SecureString */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SecureStringToCoTaskMemAnsi(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func secureStringToCoTaskMemUnicode(_ s: System_Security_SecureString /* System.Security.SecureString */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SecureStringToCoTaskMemUnicode(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func secureStringToGlobalAllocAnsi(_ s: System_Security_SecureString /* System.Security.SecureString */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SecureStringToGlobalAllocAnsi(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func secureStringToGlobalAllocUnicode(_ s: System_Security_SecureString /* System.Security.SecureString */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SecureStringToGlobalAllocUnicode(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func stringToHGlobalAnsi(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToHGlobalAnsi(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func stringToHGlobalUni(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToHGlobalUni(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func stringToCoTaskMemUni(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToCoTaskMemUni(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func stringToCoTaskMemUTF8(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToCoTaskMemUTF8(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func stringToCoTaskMemAnsi(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToCoTaskMemAnsi(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func generateGuidForType(_ type: System_Type /* System.Type */) throws -> System_Guid /* System.Guid */ {
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GenerateGuidForType(typeC, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func generateProgIdForType(_ type: System_Type /* System.Type */) throws -> System_String? /* System.String */ {
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GenerateProgIdForType(typeC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDelegateForFunctionPointer(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ t: System_Type /* System.Type */) throws -> System_Delegate /* System.Delegate */ {
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointer(ptr, tC, &__exceptionC)
		
		let __returnValue = System_Delegate(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDelegateForFunctionPointer(TDelegate: System_Type /* System.Type */, _ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Object? /* System.Object */ {
		let TDelegateC = TDelegate.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointer_A1(TDelegateC, ptr, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFunctionPointerForDelegate(_ d: System_Delegate /* System.Delegate */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetFunctionPointerForDelegate(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getFunctionPointerForDelegate(TDelegate: System_Type /* System.Type */, _ d: System_Object? /* System.Object */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let TDelegateC = TDelegate.__handle
		let dC = d?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetFunctionPointerForDelegate_A1(TDelegateC, dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getHRForLastWin32Error() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetHRForLastWin32Error(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func zeroFreeBSTR(_ s: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ZeroFreeBSTR(s, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func zeroFreeCoTaskMemAnsi(_ s: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ZeroFreeCoTaskMemAnsi(s, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func zeroFreeCoTaskMemUnicode(_ s: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ZeroFreeCoTaskMemUnicode(s, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func zeroFreeCoTaskMemUTF8(_ s: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ZeroFreeCoTaskMemUTF8(s, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func zeroFreeGlobalAllocAnsi(_ s: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ZeroFreeGlobalAllocAnsi(s, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func zeroFreeGlobalAllocUnicode(_ s: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ZeroFreeGlobalAllocUnicode(s, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func stringToBSTR(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToBSTR(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func ptrToStringBSTR(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringBSTR(ptr, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTypeFromCLSID(_ clsid: System_Guid /* System.Guid */) throws -> System_Type? /* System.Type */ {
		let clsidC = clsid.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetTypeFromCLSID(clsidC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func initHandle(_ safeHandle: System_Runtime_InteropServices_SafeHandle /* System.Runtime.InteropServices.SafeHandle */, _ handle: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		let safeHandleC = safeHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_InitHandle(safeHandleC, handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastWin32Error() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetLastWin32Error(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getLastPInvokeErrorMessage() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetLastPInvokeErrorMessage(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getHRForException(_ e: System_Exception? /* System.Exception */) throws -> Int32 /* System.Int32 */ {
		let eC = e?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetHRForException(eC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func areComObjectsAvailableForCleanup() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_AreComObjectsAvailableForCleanup(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createAggregatedObject(_ pOuter: UnsafeMutableRawPointer? /* System.IntPtr */, _ o: System_Object /* System.Object */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_CreateAggregatedObject(pOuter, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func bindToMoniker(_ monikerName: System_String /* System.String */) throws -> System_Object /* System.Object */ {
		let monikerNameC = monikerName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_BindToMoniker(monikerNameC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cleanupUnusedObjectsInCurrentContext() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_CleanupUnusedObjectsInCurrentContext(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func createAggregatedObject(T: System_Type /* System.Type */, _ pOuter: UnsafeMutableRawPointer? /* System.IntPtr */, _ o: System_Object? /* System.Object */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let TC = T.__handle
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_CreateAggregatedObject_A1(TC, pOuter, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createWrapperOfType(_ o: System_Object? /* System.Object */, _ t: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let oC = o?.__handle
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_CreateWrapperOfType(oC, tC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createWrapperOfType(T: System_Type /* System.Type */, TWrapper: System_Type /* System.Type */, _ o: System_Object? /* System.Object */) throws -> System_Object /* System.Object */ {
		let TC = T.__handle
		let TWrapperC = TWrapper.__handle
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_CreateWrapperOfType_A2(TC, TWrapperC, oC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func changeWrapperHandleStrength(_ otp: System_Object /* System.Object */, _ fIsWeak: Bool /* System.Boolean */) throws {
		let otpC = otp.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_ChangeWrapperHandleStrength(otpC, fIsWeak, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func finalReleaseComObject(_ o: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_FinalReleaseComObject(oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getComInterfaceForObject(_ o: System_Object /* System.Object */, _ T: System_Type /* System.Type */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let oC = o.__handle
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetComInterfaceForObject(oC, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getComInterfaceForObject(_ o: System_Object /* System.Object */, _ T: System_Type /* System.Type */, _ mode: System_Runtime_InteropServices_CustomQueryInterfaceMode /* System.Runtime.InteropServices.CustomQueryInterfaceMode */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let oC = o.__handle
		let TC = T.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetComInterfaceForObject_1(oC, TC, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getComInterfaceForObject(T: System_Type /* System.Type */, TInterface: System_Type /* System.Type */, _ o: System_Object? /* System.Object */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let TC = T.__handle
		let TInterfaceC = TInterface.__handle
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetComInterfaceForObject_A2(TC, TInterfaceC, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getComObjectData(_ obj: System_Object /* System.Object */, _ key: System_Object /* System.Object */) throws -> System_Object? /* System.Object */ {
		let objC = obj.__handle
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetComObjectData(objC, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getIDispatchForObject(_ o: System_Object /* System.Object */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetIDispatchForObject(oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getIUnknownForObject(_ o: System_Object /* System.Object */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetIUnknownForObject(oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getNativeVariantForObject(_ obj: System_Object? /* System.Object */, _ pDstNativeVariant: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_GetNativeVariantForObject(objC, pDstNativeVariant, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getNativeVariantForObject(T: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */, _ pDstNativeVariant: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		let TC = T.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_GetNativeVariantForObject_A1(TC, objC, pDstNativeVariant, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getTypedObjectForIUnknown(_ pUnk: UnsafeMutableRawPointer? /* System.IntPtr */, _ t: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetTypedObjectForIUnknown(pUnk, tC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getObjectForIUnknown(_ pUnk: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetObjectForIUnknown(pUnk, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getObjectForNativeVariant(_ pSrcNativeVariant: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetObjectForNativeVariant(pSrcNativeVariant, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getObjectForNativeVariant(T: System_Type /* System.Type */, _ pSrcNativeVariant: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetObjectForNativeVariant_A1(TC, pSrcNativeVariant, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getObjectsForNativeVariants(_ aSrcNativeVariant: UnsafeMutableRawPointer? /* System.IntPtr */, _ cVars: Int32 /* System.Int32 */) throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetObjectsForNativeVariants(aSrcNativeVariant, cVars, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getObjectsForNativeVariants(T: System_Type /* System.Type */, _ aSrcNativeVariant: UnsafeMutableRawPointer? /* System.IntPtr */, _ cVars: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetObjectsForNativeVariants_A1(TC, aSrcNativeVariant, cVars, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getStartComSlot(_ t: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetStartComSlot(tC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getEndComSlot(_ t: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetEndComSlot(tC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getUniqueObjectForIUnknown(_ unknown: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetUniqueObjectForIUnknown(unknown, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isComObject(_ o: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_IsComObject(oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isTypeVisibleFromCom(_ t: System_Type /* System.Type */) throws -> Bool /* System.Boolean */ {
		let tC = t.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_IsTypeVisibleFromCom(tC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func releaseComObject(_ o: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let oC = o.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReleaseComObject(oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func setComObjectData(_ obj: System_Object /* System.Object */, _ key: System_Object /* System.Object */, _ data: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj.__handle
		let keyC = key.__handle
		let dataC = data?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SetComObjectData(objC, keyC, dataC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func ptrToStringAuto(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */, _ len: Int32 /* System.Int32 */) throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringAuto(ptr, len, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ptrToStringAuto(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_PtrToStringAuto_1(ptr, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func stringToHGlobalAuto(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToHGlobalAuto(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func stringToCoTaskMemAuto(_ s: System_String? /* System.String */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sC = s?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_StringToCoTaskMemAuto(sC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func allocHGlobal(_ cb: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_AllocHGlobal_1(cb, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func freeHGlobal(_ hglobal: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_FreeHGlobal(hglobal, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func reAllocHGlobal(_ pv: UnsafeMutableRawPointer? /* System.IntPtr */, _ cb: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReAllocHGlobal(pv, cb, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func allocCoTaskMem(_ cb: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_AllocCoTaskMem(cb, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func freeCoTaskMem(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_FreeCoTaskMem(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func reAllocCoTaskMem(_ pv: UnsafeMutableRawPointer? /* System.IntPtr */, _ cb: Int32 /* System.Int32 */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_ReAllocCoTaskMem(pv, cb, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func freeBSTR(_ ptr: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_FreeBSTR(ptr, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastSystemError() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetLastSystemError(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func setLastSystemError(_ error: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_Marshal_SetLastSystemError(error, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getPInvokeErrorMessage(_ error: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_GetPInvokeErrorMessage(error, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var systemDefaultCharSize: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SystemDefaultCharSize_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var systemMaxDBCSCharSize: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = System_Runtime_InteropServices_Marshal_SystemMaxDBCSCharSize_Get()
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_Marshal_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_InteropServices_Marshal_Destroy_1(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

public class System_Int16_Array /* System.Int16[] */: System_Array {
	public override class var typeName: String { get {
		"Int16[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Int16[]"
	}}

	
}














public class System_Single_Array /* System.Single[] */: System_Array {
	public override class var typeName: String { get {
		"Single[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Single[]"
	}}

	
}














public class System_Double_Array /* System.Double[] */: System_Array {
	public override class var typeName: String { get {
		"Double[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Double[]"
	}}

	
}














public class System_IntPtr_Array /* System.IntPtr[] */: System_Array {
	public override class var typeName: String { get {
		"IntPtr[]"
	}}

	public override class var fullTypeName: String { get {
		"System.IntPtr[]"
	}}

	
}














// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
public class System_Security_SecureString /* System.Security.SecureString */: System_Object {
	public override class var typeName: String { get {
		"SecureString"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.SecureString"
	}}

	public func appendChar(_ c: DNChar /* System.Char */) throws {
		let cC = c.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_AppendChar(self.__handle, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clear() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_Clear(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copy() throws -> System_Security_SecureString /* System.Security.SecureString */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecureString_Copy(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_SecureString(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func insertAt(_ index: Int32 /* System.Int32 */, _ c: DNChar /* System.Char */) throws {
		let cC = c.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_InsertAt(self.__handle, index, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func isReadOnly() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecureString_IsReadOnly(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func makeReadOnly() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_MakeReadOnly(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeAt(_ index: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_RemoveAt(self.__handle, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setAt(_ index: Int32 /* System.Int32 */, _ c: DNChar /* System.Char */) throws {
		let cC = c.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecureString_SetAt(self.__handle, index, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecureString_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var length: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecureString_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_SecureString_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_SecureString_Destroy(self.__handle)
		
	}
	
	
}


// Type "TDelegate" was skipped. Reason: It has no full name.
// Type "TDelegate" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "TWrapper" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

public class System_NullReferenceException /* System.NullReferenceException */: System_SystemException {
	public override class var typeName: String { get {
		"NullReferenceException"
	}}

	public override class var fullTypeName: String { get {
		"System.NullReferenceException"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_NullReferenceException_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */) throws {
		let messageC = message?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_NullReferenceException_Create_1(messageC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerException: System_Exception? /* System.Exception */) throws {
		let messageC = message?.__handle
		let innerExceptionC = innerException?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_NullReferenceException_Create_2(messageC, innerExceptionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_NullReferenceException_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_NullReferenceException_Destroy(self.__handle)
		
	}
	
	
}


public class System_SystemException /* System.SystemException */: System_Exception {
	public override class var typeName: String { get {
		"SystemException"
	}}

	public override class var fullTypeName: String { get {
		"System.SystemException"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_SystemException_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */) throws {
		let messageC = message?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_SystemException_Create_1(messageC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerException: System_Exception? /* System.Exception */) throws {
		let messageC = message?.__handle
		let innerExceptionC = innerException?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_SystemException_Create_2(messageC, innerExceptionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_SystemException_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_SystemException_Destroy(self.__handle)
		
	}
	
	
}


public class System_PlatformNotSupportedException /* System.PlatformNotSupportedException */: System_NotSupportedException {
	public override class var typeName: String { get {
		"PlatformNotSupportedException"
	}}

	public override class var fullTypeName: String { get {
		"System.PlatformNotSupportedException"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_PlatformNotSupportedException_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */) throws {
		let messageC = message?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_PlatformNotSupportedException_Create_1(messageC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ inner: System_Exception? /* System.Exception */) throws {
		let messageC = message?.__handle
		let innerC = inner?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_PlatformNotSupportedException_Create_2(messageC, innerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_PlatformNotSupportedException_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_PlatformNotSupportedException_Destroy(self.__handle)
		
	}
	
	
}


public class System_NotSupportedException /* System.NotSupportedException */: System_SystemException {
	public override class var typeName: String { get {
		"NotSupportedException"
	}}

	public override class var fullTypeName: String { get {
		"System.NotSupportedException"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_NotSupportedException_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */) throws {
		let messageC = message?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_NotSupportedException_Create_1(messageC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ message: System_String? /* System.String */, _ innerException: System_Exception? /* System.Exception */) throws {
		let messageC = message?.__handle
		let innerExceptionC = innerException?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_NotSupportedException_Create_2(messageC, innerExceptionC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_NotSupportedException_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_NotSupportedException_Destroy(self.__handle)
		
	}
	
	
}


public class System_UIntPtr /* System.UIntPtr */: System_ValueType {
	public override class var typeName: String { get {
		"UIntPtr"
	}}

	public override class var fullTypeName: String { get {
		"System.UIntPtr"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UIntPtr_TypeOf())
		
	}}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_AppContext /* System.AppContext */: System_Object {
	public override class var typeName: String { get {
		"AppContext"
	}}

	public override class var fullTypeName: String { get {
		"System.AppContext"
	}}

	public class func getData(_ name: System_String /* System.String */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppContext_GetData(nameC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setData(_ name: System_String /* System.String */, _ data: System_Object? /* System.Object */) throws {
		let nameC = name.__handle
		let dataC = data?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppContext_SetData(nameC, dataC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func tryGetSwitch(_ switchName: System_String /* System.String */, _ isEnabled: inout Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		let switchNameC = switchName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppContext_TryGetSwitch(switchNameC, &isEnabled, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func setSwitch(_ switchName: System_String /* System.String */, _ isEnabled: Bool /* System.Boolean */) throws {
		let switchNameC = switchName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppContext_SetSwitch(switchNameC, isEnabled, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class var baseDirectory: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppContext_BaseDirectory_Get(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var targetFrameworkName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppContext_TargetFrameworkName_Get(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AppContext_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AppContext_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_InteropServices_GCHandle /* System.Runtime.InteropServices.GCHandle */: System_ValueType {
	public override class var typeName: String { get {
		"GCHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.InteropServices.GCHandle"
	}}

	public class func alloc(_ value: System_Object? /* System.Object */) throws -> System_Runtime_InteropServices_GCHandle /* System.Runtime.InteropServices.GCHandle */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_Alloc(valueC, &__exceptionC)
		
		let __returnValue = System_Runtime_InteropServices_GCHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func alloc(_ value: System_Object? /* System.Object */, _ type: System_Runtime_InteropServices_GCHandleType /* System.Runtime.InteropServices.GCHandleType */) throws -> System_Runtime_InteropServices_GCHandle /* System.Runtime.InteropServices.GCHandle */ {
		let valueC = value?.__handle
		let typeC = type.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_Alloc_1(valueC, typeC, &__exceptionC)
		
		let __returnValue = System_Runtime_InteropServices_GCHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func free() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_GCHandle_Free(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addrOfPinnedObject() throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_AddrOfPinnedObject(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromIntPtr(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> System_Runtime_InteropServices_GCHandle /* System.Runtime.InteropServices.GCHandle */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_FromIntPtr(value, &__exceptionC)
		
		let __returnValue = System_Runtime_InteropServices_GCHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toIntPtr(_ value: System_Runtime_InteropServices_GCHandle /* System.Runtime.InteropServices.GCHandle */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_ToIntPtr(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_Equals(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Runtime_InteropServices_GCHandle /* System.Runtime.InteropServices.GCHandle */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var target: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_Target_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func target_set(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_InteropServices_GCHandle_Target_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isAllocated: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_IsAllocated_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_InteropServices_GCHandle_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_InteropServices_GCHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_InteropServices_GCHandle_Destroy(self.__handle)
		
	}
	
	
}




public class System_GC /* System.GC */: System_Object {
	public override class var typeName: String { get {
		"GC"
	}}

	public override class var fullTypeName: String { get {
		"System.GC"
	}}

	public class func getGCMemoryInfo() throws -> System_GCMemoryInfo /* System.GCMemoryInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetGCMemoryInfo(&__exceptionC)
		
		let __returnValue = System_GCMemoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getGCMemoryInfo(_ kind: System_GCKind /* System.GCKind */) throws -> System_GCMemoryInfo /* System.GCMemoryInfo */ {
		let kindC = kind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetGCMemoryInfo_1(kindC, &__exceptionC)
		
		let __returnValue = System_GCMemoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func addMemoryPressure(_ bytesAllocated: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_AddMemoryPressure(bytesAllocated, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func removeMemoryPressure(_ bytesAllocated: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_RemoveMemoryPressure(bytesAllocated, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getGeneration(_ obj: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetGeneration(objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func collect(_ generation: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_Collect(generation, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func collect() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_Collect_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func collect(_ generation: Int32 /* System.Int32 */, _ mode: System_GCCollectionMode /* System.GCCollectionMode */) throws {
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_Collect_2(generation, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func collect(_ generation: Int32 /* System.Int32 */, _ mode: System_GCCollectionMode /* System.GCCollectionMode */, _ blocking: Bool /* System.Boolean */) throws {
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_Collect_3(generation, modeC, blocking, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func collect(_ generation: Int32 /* System.Int32 */, _ mode: System_GCCollectionMode /* System.GCCollectionMode */, _ blocking: Bool /* System.Boolean */, _ compacting: Bool /* System.Boolean */) throws {
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_Collect_4(generation, modeC, blocking, compacting, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func collectionCount(_ generation: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_CollectionCount(generation, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func keepAlive(_ obj: System_Object? /* System.Object */) throws {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_KeepAlive(objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getGeneration(_ wo: System_WeakReference /* System.WeakReference */) throws -> Int32 /* System.Int32 */ {
		let woC = wo.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetGeneration_1(woC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func waitForPendingFinalizers() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_WaitForPendingFinalizers(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func suppressFinalize(_ obj: System_Object /* System.Object */) throws {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_SuppressFinalize(objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func reRegisterForFinalize(_ obj: System_Object /* System.Object */) throws {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_ReRegisterForFinalize(objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getTotalMemory(_ forceFullCollection: Bool /* System.Boolean */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetTotalMemory(forceFullCollection, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getAllocatedBytesForCurrentThread() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetAllocatedBytesForCurrentThread(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getTotalAllocatedBytes(_ precise: Bool /* System.Boolean */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetTotalAllocatedBytes(precise, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func registerForFullGCNotification(_ maxGenerationThreshold: Int32 /* System.Int32 */, _ largeObjectHeapThreshold: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_RegisterForFullGCNotification(maxGenerationThreshold, largeObjectHeapThreshold, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func cancelFullGCNotification() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_CancelFullGCNotification(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func waitForFullGCApproach() throws -> System_GCNotificationStatus /* System.GCNotificationStatus */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_WaitForFullGCApproach(&__exceptionC)
		
		let __returnValue = System_GCNotificationStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func waitForFullGCApproach(_ millisecondsTimeout: Int32 /* System.Int32 */) throws -> System_GCNotificationStatus /* System.GCNotificationStatus */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_WaitForFullGCApproach_1(millisecondsTimeout, &__exceptionC)
		
		let __returnValue = System_GCNotificationStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func waitForFullGCComplete() throws -> System_GCNotificationStatus /* System.GCNotificationStatus */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_WaitForFullGCComplete(&__exceptionC)
		
		let __returnValue = System_GCNotificationStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func waitForFullGCComplete(_ millisecondsTimeout: Int32 /* System.Int32 */) throws -> System_GCNotificationStatus /* System.GCNotificationStatus */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_WaitForFullGCComplete_1(millisecondsTimeout, &__exceptionC)
		
		let __returnValue = System_GCNotificationStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryStartNoGCRegion(_ totalSize: Int64 /* System.Int64 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_TryStartNoGCRegion(totalSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryStartNoGCRegion(_ totalSize: Int64 /* System.Int64 */, _ lohSize: Int64 /* System.Int64 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_TryStartNoGCRegion_1(totalSize, lohSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryStartNoGCRegion(_ totalSize: Int64 /* System.Int64 */, _ disallowFullBlockingGC: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_TryStartNoGCRegion_2(totalSize, disallowFullBlockingGC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryStartNoGCRegion(_ totalSize: Int64 /* System.Int64 */, _ lohSize: Int64 /* System.Int64 */, _ disallowFullBlockingGC: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_TryStartNoGCRegion_3(totalSize, lohSize, disallowFullBlockingGC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func endNoGCRegion() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_EndNoGCRegion(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func registerNoGCRegionCallback(_ totalSize: Int64 /* System.Int64 */, _ callback: System_Action /* System.Action */) throws {
		let callbackC = callback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_RegisterNoGCRegionCallback(totalSize, callbackC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func allocateUninitializedArray(T: System_Type /* System.Type */, _ length: Int32 /* System.Int32 */, _ pinned: Bool /* System.Boolean */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_AllocateUninitializedArray_A1(TC, length, pinned, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func allocateArray(T: System_Type /* System.Type */, _ length: Int32 /* System.Int32 */, _ pinned: Bool /* System.Boolean */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_AllocateArray_A1(TC, length, pinned, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTotalPauseDuration() throws -> System_TimeSpan /* System.TimeSpan */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetTotalPauseDuration(&__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getConfigurationVariables() throws -> System_Collections_Generic_IReadOnlyDictionary_A2 /* System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_GetConfigurationVariables(&__exceptionC)
		
		let __returnValue = System_Collections_Generic_IReadOnlyDictionary_A2(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func refreshMemoryLimit() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_GC_RefreshMemoryLimit(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func waitForFullGCApproach(_ timeout: System_TimeSpan /* System.TimeSpan */) throws -> System_GCNotificationStatus /* System.GCNotificationStatus */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_WaitForFullGCApproach_2(timeoutC, &__exceptionC)
		
		let __returnValue = System_GCNotificationStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func waitForFullGCComplete(_ timeout: System_TimeSpan /* System.TimeSpan */) throws -> System_GCNotificationStatus /* System.GCNotificationStatus */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_WaitForFullGCComplete_2(timeoutC, &__exceptionC)
		
		let __returnValue = System_GCNotificationStatus(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var maxGeneration: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GC_MaxGeneration_Get(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_GC_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_GC_Destroy(self.__handle)
		
	}
	
	
}


public class System_GCMemoryInfo /* System.GCMemoryInfo */: System_ValueType {
	public override class var typeName: String { get {
		"GCMemoryInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.GCMemoryInfo"
	}}

	public var highMemoryLoadThresholdBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_HighMemoryLoadThresholdBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var memoryLoadBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_MemoryLoadBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalAvailableMemoryBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_TotalAvailableMemoryBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var heapSizeBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_HeapSizeBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var fragmentedBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_FragmentedBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var index: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_Index_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var generation: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_Generation_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var compacted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_Compacted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var concurrent: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_Concurrent_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var totalCommittedBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_TotalCommittedBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var promotedBytes: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_PromotedBytes_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var pinnedObjectsCount: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_PinnedObjectsCount_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var finalizationPendingCount: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_FinalizationPendingCount_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var pauseTimePercentage: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_PauseTimePercentage_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_GCMemoryInfo_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_GCMemoryInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_GCMemoryInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_WeakReference /* System.WeakReference */: System_Object {
	public override class var typeName: String { get {
		"WeakReference"
	}}

	public override class var fullTypeName: String { get {
		"System.WeakReference"
	}}

	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_WeakReference_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ target: System_Object? /* System.Object */) throws {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_Create(targetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ target: System_Object? /* System.Object */, _ trackResurrection: Bool /* System.Boolean */) throws {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_Create_1(targetC, trackResurrection, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var trackResurrection: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_TrackResurrection_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAlive: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_IsAlive_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var target: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_Target_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func target_set(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_WeakReference_Target_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_WeakReference_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_WeakReference_Destroy(self.__handle)
		
	}
	
	
}


// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

public class System_Collections_Generic_IReadOnlyDictionary_A2 /* System.Collections.Generic.IReadOnlyDictionary<,> */: DNObject {
	public override class var typeName: String { get {
		"IReadOnlyDictionary`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IReadOnlyDictionary<,>"
	}}

	public func containsKey(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IReadOnlyDictionary_A2_ContainsKey(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func tryGetValue(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IReadOnlyDictionary_A2_TryGetValue(self.__handle, TKeyC, TValueC, keyC, &valueC, &__exceptionC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func item(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IReadOnlyDictionary_A2_Item_Get(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IReadOnlyDictionary_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IReadOnlyDictionary_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TKey" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.









public class System_Collections_Generic_KeyValuePair_A2 /* System.Collections.Generic.KeyValuePair<,> */: System_ValueType {
	public override class var typeName: String { get {
		"KeyValuePair`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.KeyValuePair<,>"
	}}

	public func toString(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_KeyValuePair_A2_ToString(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func deconstruct(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: inout System_Object? /* System.Object */, _ value: inout System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		var keyC = key?.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_KeyValuePair_A2_Deconstruct(self.__handle, TKeyC, TValueC, &keyC, &valueC, &__exceptionC)
		
		key = System_Object(handle: keyC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_KeyValuePair_A2_Create(TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func key(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_KeyValuePair_A2_Key_Get(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func value(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_KeyValuePair_A2_Value_Get(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public convenience init(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_KeyValuePair_A2_Create_1(TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_KeyValuePair_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_KeyValuePair_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TKey" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.




public class System_Math /* System.Math */: System_Object {
	public override class var typeName: String { get {
		"Math"
	}}

	public override class var fullTypeName: String { get {
		"System.Math"
	}}

	public class func acos(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Acos(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func acosh(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Acosh(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func asin(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Asin(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func asinh(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Asinh(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func atan(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Atan(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func atanh(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Atanh(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func atan2(_ y: Double /* System.Double */, _ x: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Atan2(y, x, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func cbrt(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Cbrt(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func ceiling(_ a: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Ceiling(a, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func cos(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Cos(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func cosh(_ value: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Cosh(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func exp(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Exp(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func floor(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Floor(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fusedMultiplyAdd(_ x: Double /* System.Double */, _ y: Double /* System.Double */, _ z: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_FusedMultiplyAdd(x, y, z, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Log(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log2(_ x: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Log2(x, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log10(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Log10(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func pow(_ x: Double /* System.Double */, _ y: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Pow(x, y, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sin(_ a: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sin(a, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sinh(_ value: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sinh(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sqrt(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sqrt(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tan(_ a: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Tan(a, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tanh(_ value: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Tanh(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_1(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_5(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func abs(_ value: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: Float /* System.Single */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Abs_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func bigMul(_ a: Int32 /* System.Int32 */, _ b: Int32 /* System.Int32 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_BigMul(a, b, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func bigMul(_ a: UInt64 /* System.UInt64 */, _ b: UInt64 /* System.UInt64 */, _ low: inout UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_BigMul_1(a, b, &low, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func bigMul(_ a: Int64 /* System.Int64 */, _ b: Int64 /* System.Int64 */, _ low: inout Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_BigMul_2(a, b, &low, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func bitDecrement(_ x: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_BitDecrement(x, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func bitIncrement(_ x: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_BitIncrement(x, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func copySign(_ x: Double /* System.Double */, _ y: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_CopySign(x, y, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func divRem(_ a: Int32 /* System.Int32 */, _ b: Int32 /* System.Int32 */, _ result: inout Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_DivRem(a, b, &result, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func divRem(_ a: Int64 /* System.Int64 */, _ b: Int64 /* System.Int64 */, _ result: inout Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_DivRem_1(a, b, &result, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func ceiling(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Ceiling_1(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func clamp(_ value: UInt8 /* System.Byte */, _ min: UInt8 /* System.Byte */, _ max: UInt8 /* System.Byte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: System_Decimal /* System.Decimal */, _ min: System_Decimal /* System.Decimal */, _ max: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		let minC = min.__handle
		let maxC = max.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_1(valueC, minC, maxC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func clamp(_ value: Double /* System.Double */, _ min: Double /* System.Double */, _ max: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_2(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: Int16 /* System.Int16 */, _ min: Int16 /* System.Int16 */, _ max: Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_3(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: Int32 /* System.Int32 */, _ min: Int32 /* System.Int32 */, _ max: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_4(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: Int64 /* System.Int64 */, _ min: Int64 /* System.Int64 */, _ max: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_5(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: UnsafeMutableRawPointer? /* System.IntPtr */, _ min: UnsafeMutableRawPointer? /* System.IntPtr */, _ max: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_6(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: Int8 /* System.SByte */, _ min: Int8 /* System.SByte */, _ max: Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_7(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: Float /* System.Single */, _ min: Float /* System.Single */, _ max: Float /* System.Single */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_8(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: UInt16 /* System.UInt16 */, _ min: UInt16 /* System.UInt16 */, _ max: UInt16 /* System.UInt16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_9(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: UInt32 /* System.UInt32 */, _ min: UInt32 /* System.UInt32 */, _ max: UInt32 /* System.UInt32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_10(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: UInt64 /* System.UInt64 */, _ min: UInt64 /* System.UInt64 */, _ max: UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_11(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func clamp(_ value: UInt /* System.UIntPtr */, _ min: UInt /* System.UIntPtr */, _ max: UInt /* System.UIntPtr */) throws -> UInt /* System.UIntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Clamp_12(value, min, max, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func floor(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Floor_1(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func iEEERemainder(_ x: Double /* System.Double */, _ y: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_IEEERemainder(x, y, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func iLogB(_ x: Double /* System.Double */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_ILogB(x, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log(_ a: Double /* System.Double */, _ newBase: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Log_1(a, newBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: UInt8 /* System.Byte */, _ val2: UInt8 /* System.Byte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: System_Decimal /* System.Decimal */, _ val2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let val1C = val1.__handle
		let val2C = val2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_1(val1C, val2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func max(_ val1: Double /* System.Double */, _ val2: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_2(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: Int16 /* System.Int16 */, _ val2: Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_3(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: Int32 /* System.Int32 */, _ val2: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_4(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: Int64 /* System.Int64 */, _ val2: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_5(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: UnsafeMutableRawPointer? /* System.IntPtr */, _ val2: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_6(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: Int8 /* System.SByte */, _ val2: Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_7(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: Float /* System.Single */, _ val2: Float /* System.Single */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_8(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: UInt16 /* System.UInt16 */, _ val2: UInt16 /* System.UInt16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_9(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: UInt32 /* System.UInt32 */, _ val2: UInt32 /* System.UInt32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_10(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: UInt64 /* System.UInt64 */, _ val2: UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_11(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func max(_ val1: UInt /* System.UIntPtr */, _ val2: UInt /* System.UIntPtr */) throws -> UInt /* System.UIntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Max_12(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func maxMagnitude(_ x: Double /* System.Double */, _ y: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_MaxMagnitude(x, y, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: UInt8 /* System.Byte */, _ val2: UInt8 /* System.Byte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: System_Decimal /* System.Decimal */, _ val2: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let val1C = val1.__handle
		let val2C = val2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_1(val1C, val2C, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func min(_ val1: Double /* System.Double */, _ val2: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_2(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: Int16 /* System.Int16 */, _ val2: Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_3(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: Int32 /* System.Int32 */, _ val2: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_4(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: Int64 /* System.Int64 */, _ val2: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_5(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: UnsafeMutableRawPointer? /* System.IntPtr */, _ val2: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_6(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: Int8 /* System.SByte */, _ val2: Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_7(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: Float /* System.Single */, _ val2: Float /* System.Single */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_8(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: UInt16 /* System.UInt16 */, _ val2: UInt16 /* System.UInt16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_9(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: UInt32 /* System.UInt32 */, _ val2: UInt32 /* System.UInt32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_10(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: UInt64 /* System.UInt64 */, _ val2: UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_11(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func min(_ val1: UInt /* System.UIntPtr */, _ val2: UInt /* System.UIntPtr */) throws -> UInt /* System.UIntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Min_12(val1, val2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func minMagnitude(_ x: Double /* System.Double */, _ y: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_MinMagnitude(x, y, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reciprocalEstimate(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_ReciprocalEstimate(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reciprocalSqrtEstimate(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_ReciprocalSqrtEstimate(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */, _ decimals: Int32 /* System.Int32 */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_1(dC, decimals, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_2(dC, modeC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ d: System_Decimal /* System.Decimal */, _ decimals: Int32 /* System.Int32 */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_3(dC, decimals, modeC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ a: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_4(a, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func round(_ value: Double /* System.Double */, _ digits: Int32 /* System.Int32 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_5(value, digits, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func round(_ value: Double /* System.Double */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> Double /* System.Double */ {
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_6(value, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func round(_ value: Double /* System.Double */, _ digits: Int32 /* System.Int32 */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> Double /* System.Double */ {
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Round_7(value, digits, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: System_Decimal /* System.Decimal */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: Double /* System.Double */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_1(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: Int16 /* System.Int16 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: Int64 /* System.Int64 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: Int8 /* System.SByte */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func sign(_ value: Float /* System.Single */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Sign_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func truncate(_ d: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Truncate(dC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func truncate(_ d: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_Truncate_1(d, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func scaleB(_ x: Double /* System.Double */, _ n: Int32 /* System.Int32 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Math_ScaleB(x, n, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class var e: Double /* System.Double */ { get {
		
		
		let __returnValueC = System_Math_E_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var pI: Double /* System.Double */ { get {
		
		
		let __returnValueC = System_Math_PI_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var tau: Double /* System.Double */ { get {
		
		
		let __returnValueC = System_Math_Tau_Get()
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Math_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Math_Destroy(self.__handle)
		
	}
	
	
}


public class System_Convert /* System.Convert */: System_Object {
	public override class var typeName: String { get {
		"Convert"
	}}

	public override class var fullTypeName: String { get {
		"System.Convert"
	}}

	public class func getTypeCode(_ value: System_Object? /* System.Object */) throws -> System_TypeCode /* System.TypeCode */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_GetTypeCode(valueC, &__exceptionC)
		
		let __returnValue = System_TypeCode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isDBNull(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_IsDBNull(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func changeType(_ value: System_Object? /* System.Object */, _ typeCode: System_TypeCode /* System.TypeCode */) throws -> System_Object? /* System.Object */ {
		let valueC = value?.__handle
		let typeCodeC = typeCode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ChangeType(valueC, typeCodeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func changeType(_ value: System_Object? /* System.Object */, _ typeCode: System_TypeCode /* System.TypeCode */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Object? /* System.Object */ {
		let valueC = value?.__handle
		let typeCodeC = typeCode.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ChangeType_1(valueC, typeCodeC, providerC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func changeType(_ value: System_Object? /* System.Object */, _ conversionType: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let valueC = value?.__handle
		let conversionTypeC = conversionType.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ChangeType_2(valueC, conversionTypeC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func changeType(_ value: System_Object? /* System.Object */, _ conversionType: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Object? /* System.Object */ {
		let valueC = value?.__handle
		let conversionTypeC = conversionType.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ChangeType_3(valueC, conversionTypeC, providerC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBoolean(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Bool /* System.Boolean */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Int8 /* System.SByte */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: DNChar /* System.Char */) throws -> Bool /* System.Boolean */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_4(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: UInt8 /* System.Byte */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Int16 /* System.Int16 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: UInt16 /* System.UInt16 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: UInt32 /* System.UInt32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Int64 /* System.Int64 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: UInt64 /* System.UInt64 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_12(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_13(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Float /* System.Single */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_14(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: Double /* System.Double */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_15(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: System_Decimal /* System.Decimal */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_16(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBoolean(_ value: System_DateTime /* System.DateTime */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBoolean_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toChar(_ value: System_Object? /* System.Object */) throws -> DNChar /* System.Char */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar(valueC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> DNChar /* System.Char */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_1(valueC, providerC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Bool /* System.Boolean */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_2(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: DNChar /* System.Char */) throws -> DNChar /* System.Char */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_3(valueC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Int8 /* System.SByte */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_4(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: UInt8 /* System.Byte */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_5(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Int16 /* System.Int16 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_6(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: UInt16 /* System.UInt16 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_7(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Int32 /* System.Int32 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_8(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: UInt32 /* System.UInt32 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_9(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Int64 /* System.Int64 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_10(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: UInt64 /* System.UInt64 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_11(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: System_String /* System.String */) throws -> DNChar /* System.Char */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_12(valueC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> DNChar /* System.Char */ {
		let valueC = value.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_13(valueC, providerC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Float /* System.Single */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_14(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: Double /* System.Double */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_15(value, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: System_Decimal /* System.Decimal */) throws -> DNChar /* System.Char */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_16(valueC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toChar(_ value: System_DateTime /* System.DateTime */) throws -> DNChar /* System.Char */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToChar_17(valueC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toSByte(_ value: System_Object? /* System.Object */) throws -> Int8 /* System.SByte */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int8 /* System.SByte */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Bool /* System.Boolean */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: DNChar /* System.Char */) throws -> Int8 /* System.SByte */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_4(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: UInt8 /* System.Byte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Int16 /* System.Int16 */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: UInt16 /* System.UInt16 */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Int32 /* System.Int32 */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: UInt32 /* System.UInt32 */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Int64 /* System.Int64 */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: UInt64 /* System.UInt64 */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Float /* System.Single */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: Double /* System.Double */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_Decimal /* System.Decimal */) throws -> Int8 /* System.SByte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_String? /* System.String */) throws -> Int8 /* System.SByte */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int8 /* System.SByte */ {
		let valueC = value.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_DateTime /* System.DateTime */) throws -> Int8 /* System.SByte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: System_Object? /* System.Object */) throws -> UInt8 /* System.Byte */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt8 /* System.Byte */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Bool /* System.Boolean */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: UInt8 /* System.Byte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: DNChar /* System.Char */) throws -> UInt8 /* System.Byte */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_4(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Int8 /* System.SByte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Int16 /* System.Int16 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: UInt16 /* System.UInt16 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Int32 /* System.Int32 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: UInt32 /* System.UInt32 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Int64 /* System.Int64 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: UInt64 /* System.UInt64 */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Float /* System.Single */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: Double /* System.Double */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: System_Decimal /* System.Decimal */) throws -> UInt8 /* System.Byte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: System_String? /* System.String */) throws -> UInt8 /* System.Byte */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt8 /* System.Byte */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toByte(_ value: System_DateTime /* System.DateTime */) throws -> UInt8 /* System.Byte */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_Object? /* System.Object */) throws -> Int16 /* System.Int16 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int16 /* System.Int16 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Bool /* System.Boolean */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: DNChar /* System.Char */) throws -> Int16 /* System.Int16 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_3(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Int8 /* System.SByte */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: UInt8 /* System.Byte */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: UInt16 /* System.UInt16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Int32 /* System.Int32 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: UInt32 /* System.UInt32 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Int64 /* System.Int64 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: UInt64 /* System.UInt64 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Float /* System.Single */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: Double /* System.Double */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_Decimal /* System.Decimal */) throws -> Int16 /* System.Int16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_String? /* System.String */) throws -> Int16 /* System.Int16 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int16 /* System.Int16 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_DateTime /* System.DateTime */) throws -> Int16 /* System.Int16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_Object? /* System.Object */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Bool /* System.Boolean */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: DNChar /* System.Char */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_3(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Int8 /* System.SByte */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: UInt8 /* System.Byte */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Int16 /* System.Int16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Int32 /* System.Int32 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: UInt16 /* System.UInt16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: UInt32 /* System.UInt32 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Int64 /* System.Int64 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: UInt64 /* System.UInt64 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Float /* System.Single */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: Double /* System.Double */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_Decimal /* System.Decimal */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_String? /* System.String */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_DateTime /* System.DateTime */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Bool /* System.Boolean */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: DNChar /* System.Char */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_3(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Int8 /* System.SByte */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: UInt8 /* System.Byte */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Int16 /* System.Int16 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: UInt16 /* System.UInt16 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: UInt32 /* System.UInt32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Int64 /* System.Int64 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: UInt64 /* System.UInt64 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Float /* System.Single */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: Double /* System.Double */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_Decimal /* System.Decimal */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_String? /* System.String */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_DateTime /* System.DateTime */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_Object? /* System.Object */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Bool /* System.Boolean */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: DNChar /* System.Char */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_3(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Int8 /* System.SByte */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: UInt8 /* System.Byte */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Int16 /* System.Int16 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: UInt16 /* System.UInt16 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Int32 /* System.Int32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: UInt32 /* System.UInt32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Int64 /* System.Int64 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: UInt64 /* System.UInt64 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Float /* System.Single */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: Double /* System.Double */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_Decimal /* System.Decimal */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_String? /* System.String */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_DateTime /* System.DateTime */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_Object? /* System.Object */) throws -> Int64 /* System.Int64 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int64 /* System.Int64 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Bool /* System.Boolean */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: DNChar /* System.Char */) throws -> Int64 /* System.Int64 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_3(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Int8 /* System.SByte */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: UInt8 /* System.Byte */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Int16 /* System.Int16 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: UInt16 /* System.UInt16 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Int32 /* System.Int32 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: UInt32 /* System.UInt32 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: UInt64 /* System.UInt64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Float /* System.Single */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: Double /* System.Double */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_Decimal /* System.Decimal */) throws -> Int64 /* System.Int64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_String? /* System.String */) throws -> Int64 /* System.Int64 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Int64 /* System.Int64 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_DateTime /* System.DateTime */) throws -> Int64 /* System.Int64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_Object? /* System.Object */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Bool /* System.Boolean */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: DNChar /* System.Char */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_3(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Int8 /* System.SByte */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: UInt8 /* System.Byte */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Int16 /* System.Int16 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: UInt16 /* System.UInt16 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Int32 /* System.Int32 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: UInt32 /* System.UInt32 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Int64 /* System.Int64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Float /* System.Single */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: Double /* System.Double */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_13(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_Decimal /* System.Decimal */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_String? /* System.String */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_15(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_16(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_DateTime /* System.DateTime */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: System_Object? /* System.Object */) throws -> Float /* System.Single */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Float /* System.Single */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Int8 /* System.SByte */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: UInt8 /* System.Byte */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: DNChar /* System.Char */) throws -> Float /* System.Single */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_4(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Int16 /* System.Int16 */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_5(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: UInt16 /* System.UInt16 */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Int32 /* System.Int32 */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: UInt32 /* System.UInt32 */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Int64 /* System.Int64 */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: UInt64 /* System.UInt64 */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Float /* System.Single */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Double /* System.Double */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: System_Decimal /* System.Decimal */) throws -> Float /* System.Single */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_13(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: System_String? /* System.String */) throws -> Float /* System.Single */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Float /* System.Single */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_15(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: Bool /* System.Boolean */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_16(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSingle(_ value: System_DateTime /* System.DateTime */) throws -> Float /* System.Single */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSingle_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: System_Object? /* System.Object */) throws -> Double /* System.Double */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Double /* System.Double */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_1(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Int8 /* System.SByte */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: UInt8 /* System.Byte */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Int16 /* System.Int16 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: DNChar /* System.Char */) throws -> Double /* System.Double */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_5(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: UInt16 /* System.UInt16 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Int32 /* System.Int32 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: UInt32 /* System.UInt32 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Int64 /* System.Int64 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: UInt64 /* System.UInt64 */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Float /* System.Single */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_11(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_12(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: System_Decimal /* System.Decimal */) throws -> Double /* System.Double */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_13(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: System_String? /* System.String */) throws -> Double /* System.Double */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_14(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> Double /* System.Double */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_15(valueC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: Bool /* System.Boolean */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_16(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDouble(_ value: System_DateTime /* System.DateTime */) throws -> Double /* System.Double */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDouble_17(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toDecimal(_ value: System_Object? /* System.Object */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_1(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Int8 /* System.SByte */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_2(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: UInt8 /* System.Byte */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_3(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: DNChar /* System.Char */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_4(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Int16 /* System.Int16 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_5(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: UInt16 /* System.UInt16 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_6(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Int32 /* System.Int32 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_7(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: UInt32 /* System.UInt32 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_8(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Int64 /* System.Int64 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_9(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: UInt64 /* System.UInt64 */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_10(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Float /* System.Single */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_11(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Double /* System.Double */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_12(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: System_String? /* System.String */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_13(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_14(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: System_Decimal /* System.Decimal */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_15(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: Bool /* System.Boolean */) throws -> System_Decimal /* System.Decimal */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_16(value, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDecimal(_ value: System_DateTime /* System.DateTime */) throws -> System_Decimal /* System.Decimal */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDecimal_17(valueC, &__exceptionC)
		
		let __returnValue = System_Decimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: System_DateTime /* System.DateTime */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime(valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: System_Object? /* System.Object */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_1(valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_2(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: System_String? /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_3(valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_4(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Int8 /* System.SByte */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_5(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: UInt8 /* System.Byte */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_6(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Int16 /* System.Int16 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_7(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: UInt16 /* System.UInt16 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_8(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Int32 /* System.Int32 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_9(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: UInt32 /* System.UInt32 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_10(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Int64 /* System.Int64 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_11(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: UInt64 /* System.UInt64 */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_12(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Bool /* System.Boolean */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_13(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: DNChar /* System.Char */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_14(valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Float /* System.Single */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_15(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: Double /* System.Double */) throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_16(value, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toDateTime(_ value: System_Decimal /* System.Decimal */) throws -> System_DateTime /* System.DateTime */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToDateTime_17(valueC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_Object? /* System.Object */) throws -> System_String? /* System.String */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString(valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_Object? /* System.Object */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String? /* System.String */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_1(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Bool /* System.Boolean */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_2(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Bool /* System.Boolean */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_3(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_4(valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: DNChar /* System.Char */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let valueC = value.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_5(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int8 /* System.SByte */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_6(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int8 /* System.SByte */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_7(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt8 /* System.Byte */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_8(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt8 /* System.Byte */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_9(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int16 /* System.Int16 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_10(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int16 /* System.Int16 */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_11(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt16 /* System.UInt16 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_12(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt16 /* System.UInt16 */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_13(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_14(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int32 /* System.Int32 */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_15(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt32 /* System.UInt32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_16(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt32 /* System.UInt32 */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_17(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int64 /* System.Int64 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_18(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int64 /* System.Int64 */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_19(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt64 /* System.UInt64 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_20(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: UInt64 /* System.UInt64 */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_21(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Float /* System.Single */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_22(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Float /* System.Single */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_23(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Double /* System.Double */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_24(value, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Double /* System.Double */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_25(value, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_Decimal /* System.Decimal */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_26(valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_Decimal /* System.Decimal */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_27(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_DateTime /* System.DateTime */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_28(valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_DateTime /* System.DateTime */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_29(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_30(valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String? /* System.String */ {
		let valueC = value?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_31(valueC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toByte(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> UInt8 /* System.Byte */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToByte_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toSByte(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> Int8 /* System.SByte */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToSByte_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt16(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> Int16 /* System.Int16 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt16_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt16(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> UInt16 /* System.UInt16 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt16_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt32(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt32_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt32(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> UInt32 /* System.UInt32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt32_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toInt64(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> Int64 /* System.Int64 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToInt64_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toUInt64(_ value: System_String? /* System.String */, _ fromBase: Int32 /* System.Int32 */) throws -> UInt64 /* System.UInt64 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToUInt64_18(valueC, fromBase, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toString(_ value: UInt8 /* System.Byte */, _ toBase: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_32(value, toBase, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int16 /* System.Int16 */, _ toBase: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_33(value, toBase, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int32 /* System.Int32 */, _ toBase: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_34(value, toBase, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toString(_ value: Int64 /* System.Int64 */, _ toBase: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToString_35(value, toBase, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBase64String(_ inArray: System_Byte_Array /* System.Byte[] */) throws -> System_String /* System.String */ {
		let inArrayC = inArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64String(inArrayC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBase64String(_ inArray: System_Byte_Array /* System.Byte[] */, _ options: System_Base64FormattingOptions /* System.Base64FormattingOptions */) throws -> System_String /* System.String */ {
		let inArrayC = inArray.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64String_1(inArrayC, optionsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBase64String(_ inArray: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		let inArrayC = inArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64String_2(inArrayC, offset, length, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBase64String(_ inArray: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ options: System_Base64FormattingOptions /* System.Base64FormattingOptions */) throws -> System_String /* System.String */ {
		let inArrayC = inArray.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64String_3(inArrayC, offset, length, optionsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBase64String(_ bytes: Data? /* System.ReadOnlySpan<System.Byte> */, _ options: System_Base64FormattingOptions /* System.Base64FormattingOptions */) throws -> System_String /* System.String */ {
		let bytesC = bytes.readOnlySpanOfByte()
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64String_4(bytesC, optionsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toBase64CharArray(_ inArray: System_Byte_Array /* System.Byte[] */, _ offsetIn: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ outArray: System_Char_Array /* System.Char[] */, _ offsetOut: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let inArrayC = inArray.__handle
		let outArrayC = outArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64CharArray(inArrayC, offsetIn, length, outArrayC, offsetOut, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func toBase64CharArray(_ inArray: System_Byte_Array /* System.Byte[] */, _ offsetIn: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ outArray: System_Char_Array /* System.Char[] */, _ offsetOut: Int32 /* System.Int32 */, _ options: System_Base64FormattingOptions /* System.Base64FormattingOptions */) throws -> Int32 /* System.Int32 */ {
		let inArrayC = inArray.__handle
		let outArrayC = outArray.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToBase64CharArray_1(inArrayC, offsetIn, length, outArrayC, offsetOut, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromBase64String(_ s: System_String /* System.String */) throws -> System_Byte_Array /* System.Byte[] */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_FromBase64String(sC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromBase64CharArray(_ inArray: System_Char_Array /* System.Char[] */, _ offset: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_Byte_Array /* System.Byte[] */ {
		let inArrayC = inArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_FromBase64CharArray(inArrayC, offset, length, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromHexString(_ s: System_String /* System.String */) throws -> System_Byte_Array /* System.Byte[] */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_FromHexString(sC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toHexString(_ inArray: System_Byte_Array /* System.Byte[] */) throws -> System_String /* System.String */ {
		let inArrayC = inArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToHexString(inArrayC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toHexString(_ inArray: System_Byte_Array /* System.Byte[] */, _ offset: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		let inArrayC = inArray.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToHexString_1(inArrayC, offset, length, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func toHexString(_ bytes: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_String /* System.String */ {
		let bytesC = bytes.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Convert_ToHexString_2(bytesC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var dBNull: System_Object /* System.Object */ { get {
		
		
		let __returnValueC = System_Convert_DBNull_Get()
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Convert_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Convert_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_Thread /* System.Threading.Thread */: System_Runtime_ConstrainedExecution_CriticalFinalizerObject {
	public override class var typeName: String { get {
		"Thread"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Thread"
	}}

	public class func spinWait(_ iterations: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_SpinWait(iterations, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func yield() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Yield(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getApartmentState() throws -> System_Threading_ApartmentState /* System.Threading.ApartmentState */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetApartmentState(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_ApartmentState(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func disableComObjectEagerCleanup() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_DisableComObjectEagerCleanup(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func interrupt() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Interrupt(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func join(_ millisecondsTimeout: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Join(self.__handle, millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func start(_ parameter: System_Object? /* System.Object */) throws {
		let parameterC = parameter?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Start(self.__handle, parameterC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeStart(_ parameter: System_Object? /* System.Object */) throws {
		let parameterC = parameter?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_UnsafeStart(self.__handle, parameterC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func start() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Start_1(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func unsafeStart() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_UnsafeStart_1(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sleep(_ millisecondsTimeout: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Sleep(millisecondsTimeout, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func abort() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Abort(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func abort(_ stateInfo: System_Object? /* System.Object */) throws {
		let stateInfoC = stateInfo?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Abort_1(self.__handle, stateInfoC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func resetAbort() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_ResetAbort(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func suspend() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Suspend(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func resume() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Resume(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func beginCriticalRegion() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_BeginCriticalRegion(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func endCriticalRegion() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_EndCriticalRegion(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func beginThreadAffinity() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_BeginThreadAffinity(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func endThreadAffinity() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_EndThreadAffinity(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func allocateDataSlot() throws -> System_LocalDataStoreSlot /* System.LocalDataStoreSlot */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_AllocateDataSlot(&__exceptionC)
		
		let __returnValue = System_LocalDataStoreSlot(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func allocateNamedDataSlot(_ name: System_String /* System.String */) throws -> System_LocalDataStoreSlot /* System.LocalDataStoreSlot */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_AllocateNamedDataSlot(nameC, &__exceptionC)
		
		let __returnValue = System_LocalDataStoreSlot(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getNamedDataSlot(_ name: System_String /* System.String */) throws -> System_LocalDataStoreSlot /* System.LocalDataStoreSlot */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetNamedDataSlot(nameC, &__exceptionC)
		
		let __returnValue = System_LocalDataStoreSlot(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func freeNamedDataSlot(_ name: System_String /* System.String */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_FreeNamedDataSlot(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getData(_ slot: System_LocalDataStoreSlot /* System.LocalDataStoreSlot */) throws -> System_Object? /* System.Object */ {
		let slotC = slot.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetData(slotC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setData(_ slot: System_LocalDataStoreSlot /* System.LocalDataStoreSlot */, _ data: System_Object? /* System.Object */) throws {
		let slotC = slot.__handle
		let dataC = data?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_SetData(slotC, dataC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setApartmentState(_ state: System_Threading_ApartmentState /* System.Threading.ApartmentState */) throws {
		let stateC = state.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_SetApartmentState(self.__handle, stateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func trySetApartmentState(_ state: System_Threading_ApartmentState /* System.Threading.ApartmentState */) throws -> Bool /* System.Boolean */ {
		let stateC = state.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_TrySetApartmentState(self.__handle, stateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getCompressedStack() throws -> System_Threading_CompressedStack /* System.Threading.CompressedStack */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetCompressedStack(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_CompressedStack(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setCompressedStack(_ stack: System_Threading_CompressedStack /* System.Threading.CompressedStack */) throws {
		let stackC = stack.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_SetCompressedStack(self.__handle, stackC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getDomain() throws -> System_AppDomain /* System.AppDomain */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetDomain(&__exceptionC)
		
		let __returnValue = System_AppDomain(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDomainID() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetDomainID(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func join() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Join_1(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func join(_ timeout: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Join_2(self.__handle, timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func memoryBarrier() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_MemoryBarrier(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func sleep(_ timeout: System_TimeSpan /* System.TimeSpan */) throws {
		let timeoutC = timeout.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Sleep_1(timeoutC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileRead(_ address: inout UInt8 /* System.Byte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout Double /* System.Double */) throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_1(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_2(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_3(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_4(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_5(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		var addressC = address?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_6(&addressC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		address = System_Object(handle: addressC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func volatileRead(_ address: inout Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_7(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout Float /* System.Single */) throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_8(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout UInt16 /* System.UInt16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_9(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout UInt32 /* System.UInt32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_10(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_11(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileRead(_ address: inout UInt /* System.UIntPtr */) throws -> UInt /* System.UIntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_VolatileRead_12(&address, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func volatileWrite(_ address: inout UInt8 /* System.Byte */, _ value: UInt8 /* System.Byte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout Double /* System.Double */, _ value: Double /* System.Double */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_1(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout Int16 /* System.Int16 */, _ value: Int16 /* System.Int16 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_2(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout Int32 /* System.Int32 */, _ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_3(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout Int64 /* System.Int64 */, _ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_4(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout UnsafeMutableRawPointer? /* System.IntPtr */, _ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_5(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		var addressC = address?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_6(&addressC, valueC, &__exceptionC)
		
		address = System_Object(handle: addressC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout Int8 /* System.SByte */, _ value: Int8 /* System.SByte */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_7(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout Float /* System.Single */, _ value: Float /* System.Single */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_8(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout UInt16 /* System.UInt16 */, _ value: UInt16 /* System.UInt16 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_9(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout UInt32 /* System.UInt32 */, _ value: UInt32 /* System.UInt32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_10(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout UInt64 /* System.UInt64 */, _ value: UInt64 /* System.UInt64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_11(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func volatileWrite(_ address: inout UInt /* System.UIntPtr */, _ value: UInt /* System.UIntPtr */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_VolatileWrite_12(&address, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getCurrentProcessorId() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_GetCurrentProcessorId(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ start: System_Threading_ThreadStart /* System.Threading.ThreadStart */) throws {
		let startC = start.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Create(startC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ start: System_Threading_ThreadStart /* System.Threading.ThreadStart */, _ maxStackSize: Int32 /* System.Int32 */) throws {
		let startC = start.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Create_1(startC, maxStackSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ start: System_Threading_ParameterizedThreadStart /* System.Threading.ParameterizedThreadStart */) throws {
		let startC = start.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Create_2(startC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ start: System_Threading_ParameterizedThreadStart /* System.Threading.ParameterizedThreadStart */, _ maxStackSize: Int32 /* System.Int32 */) throws {
		let startC = start.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Create_3(startC, maxStackSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var managedThreadId: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_ManagedThreadId_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isAlive: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_IsAlive_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isBackground: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_IsBackground_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func isBackground_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_IsBackground_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isThreadPoolThread: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_IsThreadPoolThread_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var priority: System_Threading_ThreadPriority /* System.Threading.ThreadPriority */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Priority_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_ThreadPriority(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func priority_set(_ value: System_Threading_ThreadPriority /* System.Threading.ThreadPriority */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Priority_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var threadState: System_Threading_ThreadState /* System.Threading.ThreadState */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_ThreadState_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_ThreadState(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var currentCulture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_CurrentCulture_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func currentCulture_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_CurrentCulture_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var currentUICulture: System_Globalization_CultureInfo /* System.Globalization.CultureInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_CurrentUICulture_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Globalization_CultureInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func currentUICulture_set(_ value: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_CurrentUICulture_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var currentPrincipal: System_Security_Principal_IPrincipal? /* System.Security.Principal.IPrincipal */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_CurrentPrincipal_Get(&__exceptionC)
		
		let __returnValue = System_Security_Principal_IPrincipal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public class func currentPrincipal_set(_ value: System_Security_Principal_IPrincipal? /* System.Security.Principal.IPrincipal */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_CurrentPrincipal_Set(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var currentThread: System_Threading_Thread /* System.Threading.Thread */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_CurrentThread_Get(&__exceptionC)
		
		let __returnValue = System_Threading_Thread(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var executionContext: System_Threading_ExecutionContext? /* System.Threading.ExecutionContext */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_ExecutionContext_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_ExecutionContext(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func name_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_Name_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var apartmentState: System_Threading_ApartmentState /* System.Threading.ApartmentState */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Thread_ApartmentState_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_ApartmentState(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func apartmentState_set(_ value: System_Threading_ApartmentState /* System.Threading.ApartmentState */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Thread_ApartmentState_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Thread_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Thread_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_Principal_IPrincipal /* System.Security.Principal.IPrincipal */: DNObject {
	public override class var typeName: String { get {
		"IPrincipal"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.Principal.IPrincipal"
	}}

	public func isInRole(_ role: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let roleC = role.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_Principal_IPrincipal_IsInRole(self.__handle, roleC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public var identity: System_Security_Principal_IIdentity? /* System.Security.Principal.IIdentity */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_Principal_IPrincipal_Identity_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_Principal_IIdentity(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_Principal_IPrincipal_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_Principal_IPrincipal_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_Principal_IIdentity /* System.Security.Principal.IIdentity */: DNObject {
	public override class var typeName: String { get {
		"IIdentity"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.Principal.IIdentity"
	}}

	public var name: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_Principal_IIdentity_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var authenticationType: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_Principal_IIdentity_AuthenticationType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isAuthenticated: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_Principal_IIdentity_IsAuthenticated_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_Principal_IIdentity_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_Principal_IIdentity_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_ExecutionContext /* System.Threading.ExecutionContext */: System_Object {
	public override class var typeName: String { get {
		"ExecutionContext"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.ExecutionContext"
	}}

	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_ExecutionContext_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func capture() throws -> System_Threading_ExecutionContext? /* System.Threading.ExecutionContext */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_ExecutionContext_Capture(&__exceptionC)
		
		let __returnValue = System_Threading_ExecutionContext(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func suppressFlow() throws -> System_Threading_AsyncFlowControl /* System.Threading.AsyncFlowControl */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_ExecutionContext_SuppressFlow(&__exceptionC)
		
		let __returnValue = System_Threading_AsyncFlowControl(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func restoreFlow() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_ExecutionContext_RestoreFlow(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func isFlowSuppressed() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_ExecutionContext_IsFlowSuppressed(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func run(_ executionContext: System_Threading_ExecutionContext /* System.Threading.ExecutionContext */, _ callback: System_Threading_ContextCallback /* System.Threading.ContextCallback */, _ state: System_Object? /* System.Object */) throws {
		let executionContextC = executionContext.__handle
		let callbackC = callback.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_ExecutionContext_Run(executionContextC, callbackC, stateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func restore(_ executionContext: System_Threading_ExecutionContext /* System.Threading.ExecutionContext */) throws {
		let executionContextC = executionContext.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_ExecutionContext_Restore_1(executionContextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func createCopy() throws -> System_Threading_ExecutionContext /* System.Threading.ExecutionContext */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_ExecutionContext_CreateCopy(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_ExecutionContext(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_ExecutionContext_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ExecutionContext_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_ExecutionContext_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_AsyncFlowControl /* System.Threading.AsyncFlowControl */: System_ValueType {
	public override class var typeName: String { get {
		"AsyncFlowControl"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.AsyncFlowControl"
	}}

	public func undo() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_AsyncFlowControl_Undo(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_AsyncFlowControl_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_AsyncFlowControl_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ obj: System_Threading_AsyncFlowControl /* System.Threading.AsyncFlowControl */) throws -> Bool /* System.Boolean */ {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_AsyncFlowControl_Equals_1(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_AsyncFlowControl_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_AsyncFlowControl_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_AsyncFlowControl_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_AsyncFlowControl_Destroy(self.__handle)
		
	}
	
	
}




public class System_LocalDataStoreSlot /* System.LocalDataStoreSlot */: System_Object {
	public override class var typeName: String { get {
		"LocalDataStoreSlot"
	}}

	public override class var fullTypeName: String { get {
		"System.LocalDataStoreSlot"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_LocalDataStoreSlot_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_LocalDataStoreSlot_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_CompressedStack /* System.Threading.CompressedStack */: System_Object {
	public override class var typeName: String { get {
		"CompressedStack"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.CompressedStack"
	}}

	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CompressedStack_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func capture() throws -> System_Threading_CompressedStack /* System.Threading.CompressedStack */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CompressedStack_Capture(&__exceptionC)
		
		let __returnValue = System_Threading_CompressedStack(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createCopy() throws -> System_Threading_CompressedStack /* System.Threading.CompressedStack */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CompressedStack_CreateCopy(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_CompressedStack(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCompressedStack() throws -> System_Threading_CompressedStack /* System.Threading.CompressedStack */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CompressedStack_GetCompressedStack(&__exceptionC)
		
		let __returnValue = System_Threading_CompressedStack(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func run(_ compressedStack: System_Threading_CompressedStack /* System.Threading.CompressedStack */, _ callback: System_Threading_ContextCallback /* System.Threading.ContextCallback */, _ state: System_Object? /* System.Object */) throws {
		let compressedStackC = compressedStack.__handle
		let callbackC = callback.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CompressedStack_Run(compressedStackC, callbackC, stateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_CompressedStack_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_CompressedStack_Destroy(self.__handle)
		
	}
	
	
}


public class System_AppDomain /* System.AppDomain */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"AppDomain"
	}}

	public override class var fullTypeName: String { get {
		"System.AppDomain"
	}}

	public func setDynamicBase(_ path: System_String? /* System.String */) throws {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetDynamicBase(self.__handle, pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func applyPolicy(_ assemblyName: System_String /* System.String */) throws -> System_String /* System.String */ {
		let assemblyNameC = assemblyName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ApplyPolicy(self.__handle, assemblyNameC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createDomain(_ friendlyName: System_String /* System.String */) throws -> System_AppDomain /* System.AppDomain */ {
		let friendlyNameC = friendlyName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateDomain(friendlyNameC, &__exceptionC)
		
		let __returnValue = System_AppDomain(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func executeAssembly(_ assemblyFile: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let assemblyFileC = assemblyFile.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ExecuteAssembly(self.__handle, assemblyFileC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func executeAssembly(_ assemblyFile: System_String /* System.String */, _ args: System_String_Array? /* System.String[] */) throws -> Int32 /* System.Int32 */ {
		let assemblyFileC = assemblyFile.__handle
		let argsC = args?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ExecuteAssembly_1(self.__handle, assemblyFileC, argsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func executeAssembly(_ assemblyFile: System_String /* System.String */, _ args: System_String_Array? /* System.String[] */, _ hashValue: System_Byte_Array? /* System.Byte[] */, _ hashAlgorithm: System_Configuration_Assemblies_AssemblyHashAlgorithm /* System.Configuration.Assemblies.AssemblyHashAlgorithm */) throws -> Int32 /* System.Int32 */ {
		let assemblyFileC = assemblyFile.__handle
		let argsC = args?.__handle
		let hashValueC = hashValue?.__handle
		let hashAlgorithmC = hashAlgorithm.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ExecuteAssembly_2(self.__handle, assemblyFileC, argsC, hashValueC, hashAlgorithmC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func executeAssemblyByName(_ assemblyName: System_Reflection_AssemblyName /* System.Reflection.AssemblyName */, _ args: System_String_Array? /* System.String[] */) throws -> Int32 /* System.Int32 */ {
		let assemblyNameC = assemblyName.__handle
		let argsC = args?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ExecuteAssemblyByName(self.__handle, assemblyNameC, argsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func executeAssemblyByName(_ assemblyName: System_String /* System.String */) throws -> Int32 /* System.Int32 */ {
		let assemblyNameC = assemblyName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ExecuteAssemblyByName_1(self.__handle, assemblyNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func executeAssemblyByName(_ assemblyName: System_String /* System.String */, _ args: System_String_Array? /* System.String[] */) throws -> Int32 /* System.Int32 */ {
		let assemblyNameC = assemblyName.__handle
		let argsC = args?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ExecuteAssemblyByName_2(self.__handle, assemblyNameC, argsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getData(_ name: System_String /* System.String */) throws -> System_Object? /* System.Object */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_GetData(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setData(_ name: System_String /* System.String */, _ data: System_Object? /* System.Object */) throws {
		let nameC = name.__handle
		let dataC = data?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetData(self.__handle, nameC, dataC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func isDefaultAppDomain() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_IsDefaultAppDomain(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isFinalizingForUnload() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_IsFinalizingForUnload(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func unload(_ domain: System_AppDomain /* System.AppDomain */) throws {
		let domainC = domain.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_Unload(domainC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func load(_ rawAssembly: System_Byte_Array /* System.Byte[] */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let rawAssemblyC = rawAssembly.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_Load(self.__handle, rawAssemblyC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func load(_ rawAssembly: System_Byte_Array /* System.Byte[] */, _ rawSymbolStore: System_Byte_Array? /* System.Byte[] */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let rawAssemblyC = rawAssembly.__handle
		let rawSymbolStoreC = rawSymbolStore?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_Load_1(self.__handle, rawAssemblyC, rawSymbolStoreC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func load(_ assemblyRef: System_Reflection_AssemblyName /* System.Reflection.AssemblyName */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyRefC = assemblyRef.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_Load_2(self.__handle, assemblyRefC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func load(_ assemblyString: System_String /* System.String */) throws -> System_Reflection_Assembly /* System.Reflection.Assembly */ {
		let assemblyStringC = assemblyString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_Load_3(self.__handle, assemblyStringC, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func reflectionOnlyGetAssemblies() throws -> System_Reflection_Assembly_Array /* System.Reflection.Assembly[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ReflectionOnlyGetAssemblies(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCurrentThreadId() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_GetCurrentThreadId(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func appendPrivatePath(_ path: System_String? /* System.String */) throws {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_AppendPrivatePath(self.__handle, pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clearPrivatePath() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_ClearPrivatePath(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clearShadowCopyPath() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_ClearShadowCopyPath(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setCachePath(_ path: System_String? /* System.String */) throws {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetCachePath(self.__handle, pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setShadowCopyFiles() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetShadowCopyFiles(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setShadowCopyPath(_ path: System_String? /* System.String */) throws {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetShadowCopyPath(self.__handle, pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getAssemblies() throws -> System_Reflection_Assembly_Array /* System.Reflection.Assembly[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_GetAssemblies(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setPrincipalPolicy(_ policy: System_Security_Principal_PrincipalPolicy /* System.Security.Principal.PrincipalPolicy */) throws {
		let policyC = policy.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetPrincipalPolicy(self.__handle, policyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setThreadPrincipal(_ principal: System_Security_Principal_IPrincipal /* System.Security.Principal.IPrincipal */) throws {
		let principalC = principal.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_SetThreadPrincipal(self.__handle, principalC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func createInstance(_ assemblyName: System_String /* System.String */, _ typeName: System_String /* System.String */) throws -> System_Runtime_Remoting_ObjectHandle? /* System.Runtime.Remoting.ObjectHandle */ {
		let assemblyNameC = assemblyName.__handle
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstance(self.__handle, assemblyNameC, typeNameC, &__exceptionC)
		
		let __returnValue = System_Runtime_Remoting_ObjectHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstance(_ assemblyName: System_String /* System.String */, _ typeName: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ args: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Runtime_Remoting_ObjectHandle? /* System.Runtime.Remoting.ObjectHandle */ {
		let assemblyNameC = assemblyName.__handle
		let typeNameC = typeName.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let argsC = args?.__handle
		let cultureC = culture?.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstance_1(self.__handle, assemblyNameC, typeNameC, ignoreCase, bindingAttrC, binderC, argsC, cultureC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Runtime_Remoting_ObjectHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstance(_ assemblyName: System_String /* System.String */, _ typeName: System_String /* System.String */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Runtime_Remoting_ObjectHandle? /* System.Runtime.Remoting.ObjectHandle */ {
		let assemblyNameC = assemblyName.__handle
		let typeNameC = typeName.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstance_2(self.__handle, assemblyNameC, typeNameC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Runtime_Remoting_ObjectHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceAndUnwrap(_ assemblyName: System_String /* System.String */, _ typeName: System_String /* System.String */) throws -> System_Object? /* System.Object */ {
		let assemblyNameC = assemblyName.__handle
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceAndUnwrap(self.__handle, assemblyNameC, typeNameC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceAndUnwrap(_ assemblyName: System_String /* System.String */, _ typeName: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ args: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let assemblyNameC = assemblyName.__handle
		let typeNameC = typeName.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let argsC = args?.__handle
		let cultureC = culture?.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceAndUnwrap_1(self.__handle, assemblyNameC, typeNameC, ignoreCase, bindingAttrC, binderC, argsC, cultureC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceAndUnwrap(_ assemblyName: System_String /* System.String */, _ typeName: System_String /* System.String */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let assemblyNameC = assemblyName.__handle
		let typeNameC = typeName.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceAndUnwrap_2(self.__handle, assemblyNameC, typeNameC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceFrom(_ assemblyFile: System_String /* System.String */, _ typeName: System_String /* System.String */) throws -> System_Runtime_Remoting_ObjectHandle? /* System.Runtime.Remoting.ObjectHandle */ {
		let assemblyFileC = assemblyFile.__handle
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceFrom(self.__handle, assemblyFileC, typeNameC, &__exceptionC)
		
		let __returnValue = System_Runtime_Remoting_ObjectHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceFrom(_ assemblyFile: System_String /* System.String */, _ typeName: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ args: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Runtime_Remoting_ObjectHandle? /* System.Runtime.Remoting.ObjectHandle */ {
		let assemblyFileC = assemblyFile.__handle
		let typeNameC = typeName.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let argsC = args?.__handle
		let cultureC = culture?.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceFrom_1(self.__handle, assemblyFileC, typeNameC, ignoreCase, bindingAttrC, binderC, argsC, cultureC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Runtime_Remoting_ObjectHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceFrom(_ assemblyFile: System_String /* System.String */, _ typeName: System_String /* System.String */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Runtime_Remoting_ObjectHandle? /* System.Runtime.Remoting.ObjectHandle */ {
		let assemblyFileC = assemblyFile.__handle
		let typeNameC = typeName.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceFrom_2(self.__handle, assemblyFileC, typeNameC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Runtime_Remoting_ObjectHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceFromAndUnwrap(_ assemblyFile: System_String /* System.String */, _ typeName: System_String /* System.String */) throws -> System_Object? /* System.Object */ {
		let assemblyFileC = assemblyFile.__handle
		let typeNameC = typeName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceFromAndUnwrap(self.__handle, assemblyFileC, typeNameC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceFromAndUnwrap(_ assemblyFile: System_String /* System.String */, _ typeName: System_String /* System.String */, _ ignoreCase: Bool /* System.Boolean */, _ bindingAttr: System_Reflection_BindingFlags /* System.Reflection.BindingFlags */, _ binder: System_Reflection_Binder? /* System.Reflection.Binder */, _ args: System_Object_Array? /* System.Object[] */, _ culture: System_Globalization_CultureInfo? /* System.Globalization.CultureInfo */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let assemblyFileC = assemblyFile.__handle
		let typeNameC = typeName.__handle
		let bindingAttrC = bindingAttr.cValue
		let binderC = binder?.__handle
		let argsC = args?.__handle
		let cultureC = culture?.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceFromAndUnwrap_1(self.__handle, assemblyFileC, typeNameC, ignoreCase, bindingAttrC, binderC, argsC, cultureC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createInstanceFromAndUnwrap(_ assemblyFile: System_String /* System.String */, _ typeName: System_String /* System.String */, _ activationAttributes: System_Object_Array? /* System.Object[] */) throws -> System_Object? /* System.Object */ {
		let assemblyFileC = assemblyFile.__handle
		let typeNameC = typeName.__handle
		let activationAttributesC = activationAttributes?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CreateInstanceFromAndUnwrap_2(self.__handle, assemblyFileC, typeNameC, activationAttributesC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var currentDomain: System_AppDomain /* System.AppDomain */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_CurrentDomain_Get(&__exceptionC)
		
		let __returnValue = System_AppDomain(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var baseDirectory: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_BaseDirectory_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var relativeSearchPath: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_RelativeSearchPath_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var setupInformation: System_AppDomainSetup /* System.AppDomainSetup */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_SetupInformation_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_AppDomainSetup(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var permissionSet: System_Security_PermissionSet /* System.Security.PermissionSet */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_PermissionSet_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_PermissionSet(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dynamicDirectory: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_DynamicDirectory_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var friendlyName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_FriendlyName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var id: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_Id_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFullyTrusted: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_IsFullyTrusted_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isHomogenous: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_IsHomogenous_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var monitoringIsEnabled: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_MonitoringIsEnabled_Get(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public class func monitoringIsEnabled_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_AppDomain_MonitoringIsEnabled_Set(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var monitoringSurvivedMemorySize: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_MonitoringSurvivedMemorySize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public class var monitoringSurvivedProcessMemorySize: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_MonitoringSurvivedProcessMemorySize_Get(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var monitoringTotalAllocatedMemorySize: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_MonitoringTotalAllocatedMemorySize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var shadowCopyFiles: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_ShadowCopyFiles_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var monitoringTotalProcessorTime: System_TimeSpan /* System.TimeSpan */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomain_MonitoringTotalProcessorTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_TimeSpan(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public func unhandledException_add(_ value: System_UnhandledExceptionEventHandler? /* System.UnhandledExceptionEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_UnhandledException_Add(self.__handle, valueC)
		
		
	}
	public func unhandledException_remove(_ value: System_UnhandledExceptionEventHandler? /* System.UnhandledExceptionEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_UnhandledException_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func domainUnload_add(_ value: System_EventHandler? /* System.EventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_DomainUnload_Add(self.__handle, valueC)
		
		
	}
	public func domainUnload_remove(_ value: System_EventHandler? /* System.EventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_DomainUnload_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func processExit_add(_ value: System_EventHandler? /* System.EventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_ProcessExit_Add(self.__handle, valueC)
		
		
	}
	public func processExit_remove(_ value: System_EventHandler? /* System.EventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_ProcessExit_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func assemblyLoad_add(_ value: System_AssemblyLoadEventHandler? /* System.AssemblyLoadEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_AssemblyLoad_Add(self.__handle, valueC)
		
		
	}
	public func assemblyLoad_remove(_ value: System_AssemblyLoadEventHandler? /* System.AssemblyLoadEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_AssemblyLoad_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func assemblyResolve_add(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_AssemblyResolve_Add(self.__handle, valueC)
		
		
	}
	public func assemblyResolve_remove(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_AssemblyResolve_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func reflectionOnlyAssemblyResolve_add(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_ReflectionOnlyAssemblyResolve_Add(self.__handle, valueC)
		
		
	}
	public func reflectionOnlyAssemblyResolve_remove(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_ReflectionOnlyAssemblyResolve_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func typeResolve_add(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_TypeResolve_Add(self.__handle, valueC)
		
		
	}
	public func typeResolve_remove(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_TypeResolve_Remove(self.__handle, valueC)
		
		
	}
	
	
	public func resourceResolve_add(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_ResourceResolve_Add(self.__handle, valueC)
		
		
	}
	public func resourceResolve_remove(_ value: System_ResolveEventHandler? /* System.ResolveEventHandler */) {
		let valueC = value?.__handle
		
		
		System_AppDomain_ResourceResolve_Remove(self.__handle, valueC)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AppDomain_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AppDomain_Destroy(self.__handle)
		
	}
	
	
}


public class System_AppDomainSetup /* System.AppDomainSetup */: System_Object {
	public override class var typeName: String { get {
		"AppDomainSetup"
	}}

	public override class var fullTypeName: String { get {
		"System.AppDomainSetup"
	}}

	public var applicationBase: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomainSetup_ApplicationBase_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var targetFrameworkName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AppDomainSetup_TargetFrameworkName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AppDomainSetup_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AppDomainSetup_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_PermissionSet /* System.Security.PermissionSet */: System_Object {
	public override class var typeName: String { get {
		"PermissionSet"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.PermissionSet"
	}}

	public func addPermission(_ perm: System_Security_IPermission? /* System.Security.IPermission */) throws -> System_Security_IPermission? /* System.Security.IPermission */ {
		let permC = perm?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_AddPermission(self.__handle, permC, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func assert() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_Assert(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func containsNonCodeAccessPermissions() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_ContainsNonCodeAccessPermissions(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func convertPermissionSet(_ inFormat: System_String /* System.String */, _ inData: System_Byte_Array /* System.Byte[] */, _ outFormat: System_String /* System.String */) throws -> System_Byte_Array /* System.Byte[] */ {
		let inFormatC = inFormat.__handle
		let inDataC = inData.__handle
		let outFormatC = outFormat.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_ConvertPermissionSet(inFormatC, inDataC, outFormatC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copy() throws -> System_Security_PermissionSet /* System.Security.PermissionSet */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Copy(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_PermissionSet(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyTo(_ array: System_Array /* System.Array */, _ index: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_CopyTo(self.__handle, arrayC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func demand() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_Demand(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func deny() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_Deny(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func equals(_ o: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Equals(self.__handle, oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func fromXml(_ et: System_Security_SecurityElement /* System.Security.SecurityElement */) throws {
		let etC = et.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_FromXml(self.__handle, etC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getEnumerator() throws -> System_Collections_IEnumerator /* System.Collections.IEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getPermission(_ permClass: System_Type? /* System.Type */) throws -> System_Security_IPermission? /* System.Security.IPermission */ {
		let permClassC = permClass?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_GetPermission(self.__handle, permClassC, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func intersect(_ other: System_Security_PermissionSet? /* System.Security.PermissionSet */) throws -> System_Security_PermissionSet? /* System.Security.PermissionSet */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Intersect(self.__handle, otherC, &__exceptionC)
		
		let __returnValue = System_Security_PermissionSet(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isEmpty() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_IsEmpty(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isSubsetOf(_ target: System_Security_PermissionSet? /* System.Security.PermissionSet */) throws -> Bool /* System.Boolean */ {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_IsSubsetOf(self.__handle, targetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isUnrestricted() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_IsUnrestricted(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func permitOnly() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_PermitOnly(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removePermission(_ permClass: System_Type? /* System.Type */) throws -> System_Security_IPermission? /* System.Security.IPermission */ {
		let permClassC = permClass?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_RemovePermission(self.__handle, permClassC, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func revertAssert() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_PermissionSet_RevertAssert(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setPermission(_ perm: System_Security_IPermission? /* System.Security.IPermission */) throws -> System_Security_IPermission? /* System.Security.IPermission */ {
		let permC = perm?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_SetPermission(self.__handle, permC, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toXml() throws -> System_Security_SecurityElement? /* System.Security.SecurityElement */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_ToXml(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_SecurityElement(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func union(_ other: System_Security_PermissionSet? /* System.Security.PermissionSet */) throws -> System_Security_PermissionSet? /* System.Security.PermissionSet */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Union(self.__handle, otherC, &__exceptionC)
		
		let __returnValue = System_Security_PermissionSet(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ state: System_Security_Permissions_PermissionState /* System.Security.Permissions.PermissionState */) throws {
		let stateC = state.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Create(stateC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ permSet: System_Security_PermissionSet? /* System.Security.PermissionSet */) throws {
		let permSetC = permSet?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Create_1(permSetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var count: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_Count_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSynchronized: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_IsSynchronized_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var syncRoot: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_PermissionSet_SyncRoot_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_PermissionSet_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_PermissionSet_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_ISecurityEncodable /* System.Security.ISecurityEncodable */: DNObject {
	public override class var typeName: String { get {
		"ISecurityEncodable"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.ISecurityEncodable"
	}}

	public func fromXml(_ e: System_Security_SecurityElement /* System.Security.SecurityElement */) throws {
		let eC = e.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_ISecurityEncodable_FromXml(self.__handle, eC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func toXml() throws -> System_Security_SecurityElement? /* System.Security.SecurityElement */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_ISecurityEncodable_ToXml(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_SecurityElement(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_ISecurityEncodable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_ISecurityEncodable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_SecurityElement /* System.Security.SecurityElement */: System_Object {
	public override class var typeName: String { get {
		"SecurityElement"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.SecurityElement"
	}}

	public func addAttribute(_ name: System_String /* System.String */, _ value: System_String /* System.String */) throws {
		let nameC = name.__handle
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecurityElement_AddAttribute(self.__handle, nameC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func addChild(_ child: System_Security_SecurityElement /* System.Security.SecurityElement */) throws {
		let childC = child.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecurityElement_AddChild(self.__handle, childC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func equal(_ other: System_Security_SecurityElement? /* System.Security.SecurityElement */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Equal(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copy() throws -> System_Security_SecurityElement /* System.Security.SecurityElement */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Copy(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_SecurityElement(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isValidTag(_ tag: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let tagC = tag?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_IsValidTag(tagC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isValidText(_ text: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let textC = text?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_IsValidText(textC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isValidAttributeName(_ name: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let nameC = name?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_IsValidAttributeName(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isValidAttributeValue(_ value: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_IsValidAttributeValue(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func escape(_ str: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let strC = str?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Escape(strC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func attribute(_ name: System_String /* System.String */) throws -> System_String? /* System.String */ {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Attribute(self.__handle, nameC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func searchForChildByTag(_ tag: System_String /* System.String */) throws -> System_Security_SecurityElement? /* System.Security.SecurityElement */ {
		let tagC = tag.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_SearchForChildByTag(self.__handle, tagC, &__exceptionC)
		
		let __returnValue = System_Security_SecurityElement(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func searchForTextOfTag(_ tag: System_String /* System.String */) throws -> System_String? /* System.String */ {
		let tagC = tag.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_SearchForTextOfTag(self.__handle, tagC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fromString(_ xml: System_String /* System.String */) throws -> System_Security_SecurityElement? /* System.Security.SecurityElement */ {
		let xmlC = xml.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_FromString(xmlC, &__exceptionC)
		
		let __returnValue = System_Security_SecurityElement(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ tag: System_String /* System.String */) throws {
		let tagC = tag.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Create(tagC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ tag: System_String /* System.String */, _ text: System_String? /* System.String */) throws {
		let tagC = tag.__handle
		let textC = text?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Create_1(tagC, textC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var tag: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Tag_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func tag_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecurityElement_Tag_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var attributes: System_Collections_Hashtable? /* System.Collections.Hashtable */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Hashtable(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func attributes_set(_ value: System_Collections_Hashtable? /* System.Collections.Hashtable */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecurityElement_Attributes_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var text: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Text_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func text_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecurityElement_Text_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var children: System_Collections_ArrayList? /* System.Collections.ArrayList */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_SecurityElement_Children_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func children_set(_ value: System_Collections_ArrayList? /* System.Collections.ArrayList */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_SecurityElement_Children_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_SecurityElement_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_SecurityElement_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_Hashtable /* System.Collections.Hashtable */: System_Object {
	public override class var typeName: String { get {
		"Hashtable"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Hashtable"
	}}

	public func add(_ key: System_Object /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let keyC = key.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_Add(self.__handle, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clear() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_Clear(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func contains(_ key: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Contains(self.__handle, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func containsKey(_ key: System_Object /* System.Object */) throws -> Bool /* System.Boolean */ {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_ContainsKey(self.__handle, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func containsValue(_ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_ContainsValue(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copyTo(_ array: System_Array /* System.Array */, _ arrayIndex: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_CopyTo(self.__handle, arrayC, arrayIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getEnumerator() throws -> System_Collections_IDictionaryEnumerator /* System.Collections.IDictionaryEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IDictionaryEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func remove(_ key: System_Object /* System.Object */) throws {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_Remove(self.__handle, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func synchronized(_ table: System_Collections_Hashtable /* System.Collections.Hashtable */) throws -> System_Collections_Hashtable /* System.Collections.Hashtable */ {
		let tableC = table.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Synchronized(tableC, &__exceptionC)
		
		let __returnValue = System_Collections_Hashtable(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func onDeserialization(_ sender: System_Object? /* System.Object */) throws {
		let senderC = sender?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_OnDeserialization(self.__handle, senderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_1(capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */, _ loadFactor: Float /* System.Single */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_2(capacity, loadFactor, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */, _ loadFactor: Float /* System.Single */, _ equalityComparer: System_Collections_IEqualityComparer? /* System.Collections.IEqualityComparer */) throws {
		let equalityComparerC = equalityComparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_3(capacity, loadFactor, equalityComparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ hcp: System_Collections_IHashCodeProvider? /* System.Collections.IHashCodeProvider */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let hcpC = hcp?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_4(hcpC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ equalityComparer: System_Collections_IEqualityComparer? /* System.Collections.IEqualityComparer */) throws {
		let equalityComparerC = equalityComparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_5(equalityComparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */, _ hcp: System_Collections_IHashCodeProvider? /* System.Collections.IHashCodeProvider */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let hcpC = hcp?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_6(capacity, hcpC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */, _ equalityComparer: System_Collections_IEqualityComparer? /* System.Collections.IEqualityComparer */) throws {
		let equalityComparerC = equalityComparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_7(capacity, equalityComparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ d: System_Collections_IDictionary /* System.Collections.IDictionary */) throws {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_8(dC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ d: System_Collections_IDictionary /* System.Collections.IDictionary */, _ loadFactor: Float /* System.Single */) throws {
		let dC = d.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_9(dC, loadFactor, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ d: System_Collections_IDictionary /* System.Collections.IDictionary */, _ hcp: System_Collections_IHashCodeProvider? /* System.Collections.IHashCodeProvider */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let dC = d.__handle
		let hcpC = hcp?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_10(dC, hcpC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ d: System_Collections_IDictionary /* System.Collections.IDictionary */, _ equalityComparer: System_Collections_IEqualityComparer? /* System.Collections.IEqualityComparer */) throws {
		let dC = d.__handle
		let equalityComparerC = equalityComparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_11(dC, equalityComparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */, _ loadFactor: Float /* System.Single */, _ hcp: System_Collections_IHashCodeProvider? /* System.Collections.IHashCodeProvider */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let hcpC = hcp?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_12(capacity, loadFactor, hcpC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ d: System_Collections_IDictionary /* System.Collections.IDictionary */, _ loadFactor: Float /* System.Single */, _ hcp: System_Collections_IHashCodeProvider? /* System.Collections.IHashCodeProvider */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let dC = d.__handle
		let hcpC = hcp?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_13(dC, loadFactor, hcpC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ d: System_Collections_IDictionary /* System.Collections.IDictionary */, _ loadFactor: Float /* System.Single */, _ equalityComparer: System_Collections_IEqualityComparer? /* System.Collections.IEqualityComparer */) throws {
		let dC = d.__handle
		let equalityComparerC = equalityComparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Create_14(dC, loadFactor, equalityComparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item(_ key: System_Object /* System.Object */) throws -> System_Object? /* System.Object */ {
		let keyC = key.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Item_Get(self.__handle, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(_ key: System_Object /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let keyC = key.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Hashtable_Item_Set(self.__handle, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFixedSize: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_IsFixedSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSynchronized: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_IsSynchronized_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var keys: System_Collections_ICollection /* System.Collections.ICollection */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Keys_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_ICollection(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var values: System_Collections_ICollection /* System.Collections.ICollection */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Values_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_ICollection(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var syncRoot: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_SyncRoot_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var count: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Hashtable_Count_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Hashtable_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Hashtable_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_IHashCodeProvider /* System.Collections.IHashCodeProvider */: DNObject {
	public override class var typeName: String { get {
		"IHashCodeProvider"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.IHashCodeProvider"
	}}

	public func getHashCode(_ obj: System_Object /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let objC = obj.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_IHashCodeProvider_GetHashCode(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_IHashCodeProvider_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_IHashCodeProvider_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_ArrayList /* System.Collections.ArrayList */: System_Object {
	public override class var typeName: String { get {
		"ArrayList"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.ArrayList"
	}}

	public class func adapter(_ list: System_Collections_IList /* System.Collections.IList */) throws -> System_Collections_ArrayList /* System.Collections.ArrayList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Adapter(listC, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func add(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Add(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func addRange(_ c: System_Collections_ICollection /* System.Collections.ICollection */) throws {
		let cC = c.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_AddRange(self.__handle, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func binarySearch(_ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_BinarySearch(self.__handle, index, count, valueC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func binarySearch(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_BinarySearch_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func binarySearch(_ value: System_Object? /* System.Object */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_BinarySearch_2(self.__handle, valueC, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func clear() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Clear(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clone() throws -> System_Object /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Clone(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func contains(_ item: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Contains(self.__handle, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copyTo(_ array: System_Array /* System.Array */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_CopyTo(self.__handle, arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyTo(_ array: System_Array /* System.Array */, _ arrayIndex: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_CopyTo_1(self.__handle, arrayC, arrayIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyTo(_ index: Int32 /* System.Int32 */, _ array: System_Array /* System.Array */, _ arrayIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let arrayC = array.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_CopyTo_2(self.__handle, index, arrayC, arrayIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func fixedSize(_ list: System_Collections_IList /* System.Collections.IList */) throws -> System_Collections_IList /* System.Collections.IList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_FixedSize(listC, &__exceptionC)
		
		let __returnValue = System_Collections_IList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fixedSize(_ list: System_Collections_ArrayList /* System.Collections.ArrayList */) throws -> System_Collections_ArrayList /* System.Collections.ArrayList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_FixedSize_1(listC, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEnumerator() throws -> System_Collections_IEnumerator /* System.Collections.IEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_IEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getEnumerator(_ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Collections_IEnumerator /* System.Collections.IEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_GetEnumerator_1(self.__handle, index, count, &__exceptionC)
		
		let __returnValue = System_Collections_IEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func indexOf(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_IndexOf(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_IndexOf_1(self.__handle, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(_ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_IndexOf_2(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Insert(self.__handle, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func insertRange(_ index: Int32 /* System.Int32 */, _ c: System_Collections_ICollection /* System.Collections.ICollection */) throws {
		let cC = c.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_InsertRange(self.__handle, index, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func lastIndexOf(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_LastIndexOf(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_LastIndexOf_1(self.__handle, valueC, startIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(_ value: System_Object? /* System.Object */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_LastIndexOf_2(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readOnly(_ list: System_Collections_IList /* System.Collections.IList */) throws -> System_Collections_IList /* System.Collections.IList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_ReadOnly(listC, &__exceptionC)
		
		let __returnValue = System_Collections_IList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readOnly(_ list: System_Collections_ArrayList /* System.Collections.ArrayList */) throws -> System_Collections_ArrayList /* System.Collections.ArrayList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_ReadOnly_1(listC, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func remove(_ obj: System_Object? /* System.Object */) throws {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Remove(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeAt(_ index: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_RemoveAt(self.__handle, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeRange(_ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_RemoveRange(self.__handle, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func `repeat`(_ value: System_Object? /* System.Object */, _ count: Int32 /* System.Int32 */) throws -> System_Collections_ArrayList /* System.Collections.ArrayList */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Repeat(valueC, count, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func reverse() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Reverse(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func reverse(_ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Reverse_1(self.__handle, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setRange(_ index: Int32 /* System.Int32 */, _ c: System_Collections_ICollection /* System.Collections.ICollection */) throws {
		let cC = c.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_SetRange(self.__handle, index, cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getRange(_ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Collections_ArrayList /* System.Collections.ArrayList */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_GetRange(self.__handle, index, count, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func sort() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Sort(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func sort(_ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Sort_1(self.__handle, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func sort(_ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */, _ comparer: System_Collections_IComparer? /* System.Collections.IComparer */) throws {
		let comparerC = comparer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Sort_2(self.__handle, index, count, comparerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func synchronized(_ list: System_Collections_IList /* System.Collections.IList */) throws -> System_Collections_IList /* System.Collections.IList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Synchronized(listC, &__exceptionC)
		
		let __returnValue = System_Collections_IList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func synchronized(_ list: System_Collections_ArrayList /* System.Collections.ArrayList */) throws -> System_Collections_ArrayList /* System.Collections.ArrayList */ {
		let listC = list.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Synchronized_1(listC, &__exceptionC)
		
		let __returnValue = System_Collections_ArrayList(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toArray() throws -> System_Object_Array /* System.Object[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_ToArray(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toArray(_ type: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let typeC = type.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_ToArray_1(self.__handle, typeC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimToSize() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_TrimToSize(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Create_1(capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ c: System_Collections_ICollection /* System.Collections.ICollection */) throws {
		let cC = c.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Create_2(cC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var capacity: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Capacity_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func capacity_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Capacity_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var count: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Count_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFixedSize: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_IsFixedSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isSynchronized: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_IsSynchronized_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var syncRoot: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_SyncRoot_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public func item(_ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_ArrayList_Item_Get(self.__handle, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(_ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_ArrayList_Item_Set(self.__handle, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_ArrayList_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_ArrayList_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_IStackWalk /* System.Security.IStackWalk */: DNObject {
	public override class var typeName: String { get {
		"IStackWalk"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.IStackWalk"
	}}

	public func assert() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_IStackWalk_Assert(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func demand() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_IStackWalk_Demand(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func deny() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_IStackWalk_Deny(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func permitOnly() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_IStackWalk_PermitOnly(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_IStackWalk_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_IStackWalk_Destroy(self.__handle)
		
	}
	
	
}


public class System_Security_IPermission /* System.Security.IPermission */: DNObject {
	public override class var typeName: String { get {
		"IPermission"
	}}

	public override class var fullTypeName: String { get {
		"System.Security.IPermission"
	}}

	public func copy() throws -> System_Security_IPermission /* System.Security.IPermission */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_IPermission_Copy(self.__handle, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func demand() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Security_IPermission_Demand(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func intersect(_ target: System_Security_IPermission? /* System.Security.IPermission */) throws -> System_Security_IPermission? /* System.Security.IPermission */ {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_IPermission_Intersect(self.__handle, targetC, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isSubsetOf(_ target: System_Security_IPermission? /* System.Security.IPermission */) throws -> Bool /* System.Boolean */ {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_IPermission_IsSubsetOf(self.__handle, targetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func union(_ target: System_Security_IPermission? /* System.Security.IPermission */) throws -> System_Security_IPermission? /* System.Security.IPermission */ {
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Security_IPermission_Union(self.__handle, targetC, &__exceptionC)
		
		let __returnValue = System_Security_IPermission(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Security_IPermission_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Security_IPermission_Destroy(self.__handle)
		
	}
	
	
}


public class System_UnhandledExceptionEventArgs /* System.UnhandledExceptionEventArgs */: System_EventArgs {
	public override class var typeName: String { get {
		"UnhandledExceptionEventArgs"
	}}

	public override class var fullTypeName: String { get {
		"System.UnhandledExceptionEventArgs"
	}}

	public convenience init(_ exception: System_Object /* System.Object */, _ isTerminating: Bool /* System.Boolean */) throws {
		let exceptionC = exception.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UnhandledExceptionEventArgs_Create(exceptionC, isTerminating, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var exceptionObject: System_Object /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UnhandledExceptionEventArgs_ExceptionObject_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isTerminating: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UnhandledExceptionEventArgs_IsTerminating_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UnhandledExceptionEventArgs_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_UnhandledExceptionEventArgs_Destroy(self.__handle)
		
	}
	
	
}


public class System_Reflection_Assembly_Array /* System.Reflection.Assembly[] */: System_Array {
	public override class var typeName: String { get {
		"Assembly[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Reflection.Assembly[]"
	}}

	
}















public class System_AssemblyLoadEventArgs /* System.AssemblyLoadEventArgs */: System_EventArgs {
	public override class var typeName: String { get {
		"AssemblyLoadEventArgs"
	}}

	public override class var fullTypeName: String { get {
		"System.AssemblyLoadEventArgs"
	}}

	public convenience init(_ loadedAssembly: System_Reflection_Assembly /* System.Reflection.Assembly */) throws {
		let loadedAssemblyC = loadedAssembly.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AssemblyLoadEventArgs_Create(loadedAssemblyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var loadedAssembly: System_Reflection_Assembly /* System.Reflection.Assembly */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_AssemblyLoadEventArgs_LoadedAssembly_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AssemblyLoadEventArgs_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AssemblyLoadEventArgs_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_Remoting_ObjectHandle /* System.Runtime.Remoting.ObjectHandle */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"ObjectHandle"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.Remoting.ObjectHandle"
	}}

	public func unwrap() throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Remoting_ObjectHandle_Unwrap(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ o: System_Object? /* System.Object */) throws {
		let oC = o?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_Remoting_ObjectHandle_Create(oC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_Remoting_ObjectHandle_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_Remoting_ObjectHandle_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_Timer /* System.Threading.Timer */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"Timer"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.Timer"
	}}

	public func change(_ dueTime: Int32 /* System.Int32 */, _ period: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Change(self.__handle, dueTime, period, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func change(_ dueTime: System_TimeSpan /* System.TimeSpan */, _ period: System_TimeSpan /* System.TimeSpan */) throws -> Bool /* System.Boolean */ {
		let dueTimeC = dueTime.__handle
		let periodC = period.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Change_1(self.__handle, dueTimeC, periodC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func change(_ dueTime: UInt32 /* System.UInt32 */, _ period: UInt32 /* System.UInt32 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Change_2(self.__handle, dueTime, period, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func change(_ dueTime: Int64 /* System.Int64 */, _ period: Int64 /* System.Int64 */) throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Change_3(self.__handle, dueTime, period, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func dispose(_ notifyObject: System_Threading_WaitHandle /* System.Threading.WaitHandle */) throws -> Bool /* System.Boolean */ {
		let notifyObjectC = notifyObject.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Dispose(self.__handle, notifyObjectC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_Timer_Dispose_1(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ callback: System_Threading_TimerCallback /* System.Threading.TimerCallback */, _ state: System_Object? /* System.Object */, _ dueTime: Int32 /* System.Int32 */, _ period: Int32 /* System.Int32 */) throws {
		let callbackC = callback.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Create(callbackC, stateC, dueTime, period, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ callback: System_Threading_TimerCallback /* System.Threading.TimerCallback */, _ state: System_Object? /* System.Object */, _ dueTime: System_TimeSpan /* System.TimeSpan */, _ period: System_TimeSpan /* System.TimeSpan */) throws {
		let callbackC = callback.__handle
		let stateC = state?.__handle
		let dueTimeC = dueTime.__handle
		let periodC = period.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Create_1(callbackC, stateC, dueTimeC, periodC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ callback: System_Threading_TimerCallback /* System.Threading.TimerCallback */, _ state: System_Object? /* System.Object */, _ dueTime: UInt32 /* System.UInt32 */, _ period: UInt32 /* System.UInt32 */) throws {
		let callbackC = callback.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Create_2(callbackC, stateC, dueTime, period, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ callback: System_Threading_TimerCallback /* System.Threading.TimerCallback */, _ state: System_Object? /* System.Object */, _ dueTime: Int64 /* System.Int64 */, _ period: Int64 /* System.Int64 */) throws {
		let callbackC = callback.__handle
		let stateC = state?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Create_3(callbackC, stateC, dueTime, period, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ callback: System_Threading_TimerCallback /* System.Threading.TimerCallback */) throws {
		let callbackC = callback.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_Create_4(callbackC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var activeCount: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_Timer_ActiveCount_Get(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_Timer_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_Timer_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_CancellationTokenSource /* System.Threading.CancellationTokenSource */: System_Object {
	public override class var typeName: String { get {
		"CancellationTokenSource"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.CancellationTokenSource"
	}}

	public func cancel() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationTokenSource_Cancel(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func cancel(_ throwOnFirstException: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationTokenSource_Cancel_1(self.__handle, throwOnFirstException, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func cancelAsync() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_CancelAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func cancelAfter(_ delay: System_TimeSpan /* System.TimeSpan */) throws {
		let delayC = delay.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationTokenSource_CancelAfter(self.__handle, delayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func cancelAfter(_ millisecondsDelay: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationTokenSource_CancelAfter_1(self.__handle, millisecondsDelay, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func tryReset() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_TryReset(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Threading_CancellationTokenSource_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func createLinkedTokenSource(_ token1: System_Threading_CancellationToken /* System.Threading.CancellationToken */, _ token2: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_CancellationTokenSource /* System.Threading.CancellationTokenSource */ {
		let token1C = token1.__handle
		let token2C = token2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_CreateLinkedTokenSource(token1C, token2C, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationTokenSource(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createLinkedTokenSource(_ token: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_CancellationTokenSource /* System.Threading.CancellationTokenSource */ {
		let tokenC = token.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_CreateLinkedTokenSource_1(tokenC, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationTokenSource(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createLinkedTokenSource(_ tokens: System_Threading_CancellationToken_Array /* System.Threading.CancellationToken[] */) throws -> System_Threading_CancellationTokenSource /* System.Threading.CancellationTokenSource */ {
		let tokensC = tokens.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_CreateLinkedTokenSource_2(tokensC, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationTokenSource(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ delay: System_TimeSpan /* System.TimeSpan */) throws {
		let delayC = delay.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_Create_2(delayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ delay: System_TimeSpan /* System.TimeSpan */, _ timeProvider: System_TimeProvider /* System.TimeProvider */) throws {
		let delayC = delay.__handle
		let timeProviderC = timeProvider.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_Create_3(delayC, timeProviderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ millisecondsDelay: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_Create_4(millisecondsDelay, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var isCancellationRequested: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_IsCancellationRequested_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var token: System_Threading_CancellationToken /* System.Threading.CancellationToken */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Threading_CancellationTokenSource_Token_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_CancellationToken(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_CancellationTokenSource_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_CancellationTokenSource_Destroy(self.__handle)
		
	}
	
	
}


public class System_Threading_CancellationToken_Array /* System.Threading.CancellationToken[] */: System_Array {
	public override class var typeName: String { get {
		"CancellationToken[]"
	}}

	public override class var fullTypeName: String { get {
		"System.Threading.CancellationToken[]"
	}}

	
}















public class System_Random /* System.Random */: System_Object {
	public override class var typeName: String { get {
		"Random"
	}}

	public override class var fullTypeName: String { get {
		"System.Random"
	}}

	public func next() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_Next(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func next(_ maxValue: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_Next_1(self.__handle, maxValue, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func next(_ minValue: Int32 /* System.Int32 */, _ maxValue: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_Next_2(self.__handle, minValue, maxValue, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func nextInt64() throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_NextInt64(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func nextInt64(_ maxValue: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_NextInt64_1(self.__handle, maxValue, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func nextInt64(_ minValue: Int64 /* System.Int64 */, _ maxValue: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_NextInt64_2(self.__handle, minValue, maxValue, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func nextSingle() throws -> Float /* System.Single */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_NextSingle(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func nextDouble() throws -> Double /* System.Double */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_NextDouble(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func nextBytes(_ buffer: System_Byte_Array /* System.Byte[] */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Random_NextBytes(self.__handle, bufferC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getItems(T: System_Type /* System.Type */, _ choices: System_Array? /* System.Array */, _ length: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		let choicesC = choices?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_GetItems_A1(self.__handle, TC, choicesC, length, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func shuffle(T: System_Type /* System.Type */, _ values: System_Array? /* System.Array */) throws {
		let TC = T.__handle
		let valuesC = values?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Random_Shuffle_A1(self.__handle, TC, valuesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ Seed: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_Create_1(Seed, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var shared: System_Random /* System.Random */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Random_Shared_Get(&__exceptionC)
		
		let __returnValue = System_Random(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Random_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Random_Destroy(self.__handle)
		
	}
	
	
}


// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

public class System_Text_StringBuilder /* System.Text.StringBuilder */: System_Object {
	public override class var typeName: String { get {
		"StringBuilder"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.StringBuilder"
	}}

	public func ensureCapacity(_ capacity: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_EnsureCapacity(self.__handle, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_ToString_1(self.__handle, startIndex, length, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func clear() throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Clear(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getChunks() throws -> System_Text_StringBuilder_ChunkEnumerator /* System.Text.StringBuilder.ChunkEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_GetChunks(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder_ChunkEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: DNChar /* System.Char */, _ repeatCount: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append(self.__handle, valueC, repeatCount, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_Char_Array? /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_1(self.__handle, valueC, startIndex, charCount, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_String? /* System.String */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_2(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_String? /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_3(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_Text_StringBuilder? /* System.Text.StringBuilder */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_4(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_Text_StringBuilder? /* System.Text.StringBuilder */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_5(self.__handle, valueC, startIndex, count, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendLine() throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendLine(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendLine(_ value: System_String? /* System.String */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendLine_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyTo(_ sourceIndex: Int32 /* System.Int32 */, _ destination: System_Char_Array /* System.Char[] */, _ destinationIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let destinationC = destination.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_CopyTo(self.__handle, sourceIndex, destinationC, destinationIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_String? /* System.String */, _ count: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert(self.__handle, index, valueC, count, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func remove(_ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Remove(self.__handle, startIndex, length, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Bool /* System.Boolean */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_6(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: DNChar /* System.Char */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_7(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Int8 /* System.SByte */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_8(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: UInt8 /* System.Byte */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_9(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Int16 /* System.Int16 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_10(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_11(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Int64 /* System.Int64 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_12(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Float /* System.Single */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_13(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: Double /* System.Double */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_14(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_Decimal /* System.Decimal */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_15(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: UInt16 /* System.UInt16 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_16(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: UInt32 /* System.UInt32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_17(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: UInt64 /* System.UInt64 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_18(self.__handle, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_19(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ value: System_Char_Array? /* System.Char[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_20(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ handler: inout System_Text_StringBuilder_AppendInterpolatedStringHandler /* System.Text.StringBuilder.AppendInterpolatedStringHandler */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		var handlerC = handler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_21(self.__handle, &handlerC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		handler = System_Text_StringBuilder_AppendInterpolatedStringHandler(handle: handlerC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func append(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ handler: inout System_Text_StringBuilder_AppendInterpolatedStringHandler /* System.Text.StringBuilder.AppendInterpolatedStringHandler */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		var handlerC = handler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Append_22(self.__handle, providerC, &handlerC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		handler = System_Text_StringBuilder_AppendInterpolatedStringHandler(handle: handlerC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendLine(_ handler: inout System_Text_StringBuilder_AppendInterpolatedStringHandler /* System.Text.StringBuilder.AppendInterpolatedStringHandler */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		var handlerC = handler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendLine_2(self.__handle, &handlerC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		handler = System_Text_StringBuilder_AppendInterpolatedStringHandler(handle: handlerC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendLine(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ handler: inout System_Text_StringBuilder_AppendInterpolatedStringHandler /* System.Text.StringBuilder.AppendInterpolatedStringHandler */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		var handlerC = handler.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendLine_3(self.__handle, providerC, &handlerC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		handler = System_Text_StringBuilder_AppendInterpolatedStringHandler(handle: handlerC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendJoin(_ separator: System_String? /* System.String */, _ values: System_Object_Array /* System.Object[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let separatorC = separator?.__handle
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendJoin(self.__handle, separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendJoin(_ separator: System_String? /* System.String */, _ values: System_String_Array /* System.String[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let separatorC = separator?.__handle
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendJoin_1(self.__handle, separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendJoin(_ separator: DNChar /* System.Char */, _ values: System_Object_Array /* System.Object[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let separatorC = separator.cValue
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendJoin_2(self.__handle, separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendJoin(_ separator: DNChar /* System.Char */, _ values: System_String_Array /* System.String[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let separatorC = separator.cValue
		let valuesC = values.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendJoin_3(self.__handle, separatorC, valuesC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_String? /* System.String */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_1(self.__handle, index, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Bool /* System.Boolean */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_2(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Int8 /* System.SByte */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_3(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: UInt8 /* System.Byte */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_4(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Int16 /* System.Int16 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_5(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: DNChar /* System.Char */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_6(self.__handle, index, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_Char_Array? /* System.Char[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_7(self.__handle, index, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_Char_Array? /* System.Char[] */, _ startIndex: Int32 /* System.Int32 */, _ charCount: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_8(self.__handle, index, valueC, startIndex, charCount, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_9(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Int64 /* System.Int64 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_10(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Float /* System.Single */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_11(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: Double /* System.Double */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_12(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_Decimal /* System.Decimal */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_13(self.__handle, index, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: UInt16 /* System.UInt16 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_14(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: UInt32 /* System.UInt32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_15(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: UInt64 /* System.UInt64 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_16(self.__handle, index, value, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func insert(_ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Insert_17(self.__handle, index, valueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat(self.__handle, formatC, arg0C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_1(self.__handle, formatC, arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_2(self.__handle, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ format: System_String /* System.String */, _ args: System_Object_Array /* System.Object[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let formatC = format.__handle
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_3(self.__handle, formatC, argsC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_4(self.__handle, providerC, formatC, arg0C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_5(self.__handle, providerC, formatC, arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_6(self.__handle, providerC, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_String /* System.String */, _ args: System_Object_Array /* System.Object[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_7(self.__handle, providerC, formatC, argsC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(TArg0: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat? /* System.Text.CompositeFormat */, _ arg0: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let TArg0C = TArg0.__handle
		let providerC = provider?.__handle
		let formatC = format?.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_A1(self.__handle, TArg0C, providerC, formatC, arg0C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(TArg0: System_Type /* System.Type */, TArg1: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat? /* System.Text.CompositeFormat */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let TArg0C = TArg0.__handle
		let TArg1C = TArg1.__handle
		let providerC = provider?.__handle
		let formatC = format?.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_A2(self.__handle, TArg0C, TArg1C, providerC, formatC, arg0C, arg1C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(TArg0: System_Type /* System.Type */, TArg1: System_Type /* System.Type */, TArg2: System_Type /* System.Type */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat? /* System.Text.CompositeFormat */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let TArg0C = TArg0.__handle
		let TArg1C = TArg1.__handle
		let TArg2C = TArg2.__handle
		let providerC = provider?.__handle
		let formatC = format?.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_A3(self.__handle, TArg0C, TArg1C, TArg2C, providerC, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendFormat(_ provider: System_IFormatProvider? /* System.IFormatProvider */, _ format: System_Text_CompositeFormat /* System.Text.CompositeFormat */, _ args: System_Object_Array /* System.Object[] */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let providerC = provider?.__handle
		let formatC = format.__handle
		let argsC = args.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendFormat_8(self.__handle, providerC, formatC, argsC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldValue: System_String /* System.String */, _ newValue: System_String? /* System.String */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let oldValueC = oldValue.__handle
		let newValueC = newValue?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Replace(self.__handle, oldValueC, newValueC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func equals(_ sb: System_Text_StringBuilder? /* System.Text.StringBuilder */) throws -> Bool /* System.Boolean */ {
		let sbC = sb?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Equals(self.__handle, sbC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func replace(_ oldValue: System_String /* System.String */, _ newValue: System_String? /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let oldValueC = oldValue.__handle
		let newValueC = newValue?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Replace_1(self.__handle, oldValueC, newValueC, startIndex, count, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldChar: DNChar /* System.Char */, _ newChar: DNChar /* System.Char */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let oldCharC = oldChar.cValue
		let newCharC = newChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Replace_2(self.__handle, oldCharC, newCharC, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ oldChar: DNChar /* System.Char */, _ newChar: DNChar /* System.Char */, _ startIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Text_StringBuilder /* System.Text.StringBuilder */ {
		let oldCharC = oldChar.cValue
		let newCharC = newChar.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Replace_3(self.__handle, oldCharC, newCharC, startIndex, count, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Create_1(capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Create_2(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: System_String? /* System.String */, _ capacity: Int32 /* System.Int32 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Create_3(valueC, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ value: System_String? /* System.String */, _ startIndex: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */, _ capacity: Int32 /* System.Int32 */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Create_4(valueC, startIndex, length, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ capacity: Int32 /* System.Int32 */, _ maxCapacity: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Create_5(capacity, maxCapacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var capacity: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Capacity_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func capacity_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_Capacity_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var maxCapacity: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_MaxCapacity_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var length: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func length_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_Length_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public func chars(_ index: Int32 /* System.Int32 */) throws -> DNChar /* System.Char */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_Chars_Get(self.__handle, index, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func chars_set(_ index: Int32 /* System.Int32 */, _ value: DNChar /* System.Char */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_Chars_Set(self.__handle, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_StringBuilder_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_StringBuilder_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_StringBuilder_ChunkEnumerator /* System.Text.StringBuilder.ChunkEnumerator */: System_ValueType {
	public override class var typeName: String { get {
		"ChunkEnumerator"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.StringBuilder.ChunkEnumerator"
	}}

	public func getEnumerator() throws -> System_Text_StringBuilder_ChunkEnumerator /* System.Text.StringBuilder.ChunkEnumerator */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_ChunkEnumerator_GetEnumerator(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_StringBuilder_ChunkEnumerator(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func moveNext() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_ChunkEnumerator_MoveNext(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_ChunkEnumerator_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_StringBuilder_ChunkEnumerator_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_StringBuilder_ChunkEnumerator_Destroy(self.__handle)
		
	}
	
	
}


public class System_Text_StringBuilder_AppendInterpolatedStringHandler /* System.Text.StringBuilder.AppendInterpolatedStringHandler */: System_ValueType {
	public override class var typeName: String { get {
		"AppendInterpolatedStringHandler"
	}}

	public override class var fullTypeName: String { get {
		"System.Text.StringBuilder.AppendInterpolatedStringHandler"
	}}

	public func appendLiteral(_ value: System_String /* System.String */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendLiteral(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_A1(self.__handle, TC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */, _ format: System_String? /* System.String */) throws {
		let TC = T.__handle
		let valueC = value?.__handle
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_A1_1(self.__handle, TC, valueC, formatC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */, _ alignment: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_A1_2(self.__handle, TC, valueC, alignment, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */, _ alignment: Int32 /* System.Int32 */, _ format: System_String? /* System.String */) throws {
		let TC = T.__handle
		let valueC = value?.__handle
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_A1_3(self.__handle, TC, valueC, alignment, formatC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(_ value: System_String? /* System.String */, _ alignment: Int32 /* System.Int32 */, _ format: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_2(self.__handle, valueC, alignment, formatC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func appendFormatted(_ value: System_Object? /* System.Object */, _ alignment: Int32 /* System.Int32 */, _ format: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Text_StringBuilder_AppendInterpolatedStringHandler_AppendFormatted_3(self.__handle, valueC, alignment, formatC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ literalLength: Int32 /* System.Int32 */, _ formattedCount: Int32 /* System.Int32 */, _ stringBuilder: System_Text_StringBuilder /* System.Text.StringBuilder */) throws {
		let stringBuilderC = stringBuilder.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendInterpolatedStringHandler_Create(literalLength, formattedCount, stringBuilderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ literalLength: Int32 /* System.Int32 */, _ formattedCount: Int32 /* System.Int32 */, _ stringBuilder: System_Text_StringBuilder /* System.Text.StringBuilder */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws {
		let stringBuilderC = stringBuilder.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendInterpolatedStringHandler_Create_1(literalLength, formattedCount, stringBuilderC, providerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Text_StringBuilder_AppendInterpolatedStringHandler_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Text_StringBuilder_AppendInterpolatedStringHandler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Text_StringBuilder_AppendInterpolatedStringHandler_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "TArg0" was skipped. Reason: It has no full name.
// Type "TArg0" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg0" was skipped. Reason: It has no full name.
// Type "TArg1" was skipped. Reason: It has no full name.
// Type "TArg2" was skipped. Reason: It has no full name.
public class System_IO_Path /* System.IO.Path */: System_Object {
	public override class var typeName: String { get {
		"Path"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.Path"
	}}

	public class func changeExtension(_ path: System_String? /* System.String */, _ `extension`: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let pathC = path?.__handle
		let extensionC = `extension`?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_ChangeExtension(pathC, extensionC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exists(_ path: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Exists(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getDirectoryName(_ path: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetDirectoryName(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getExtension(_ path: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetExtension(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFileName(_ path: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetFileName(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFileNameWithoutExtension(_ path: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetFileNameWithoutExtension(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getRandomFileName() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetRandomFileName(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isPathFullyQualified(_ path: System_String /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_IsPathFullyQualified(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func hasExtension(_ path: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_HasExtension(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func combine(_ path1: System_String /* System.String */, _ path2: System_String /* System.String */) throws -> System_String /* System.String */ {
		let path1C = path1.__handle
		let path2C = path2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Combine(path1C, path2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func combine(_ path1: System_String /* System.String */, _ path2: System_String /* System.String */, _ path3: System_String /* System.String */) throws -> System_String /* System.String */ {
		let path1C = path1.__handle
		let path2C = path2.__handle
		let path3C = path3.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Combine_1(path1C, path2C, path3C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func combine(_ path1: System_String /* System.String */, _ path2: System_String /* System.String */, _ path3: System_String /* System.String */, _ path4: System_String /* System.String */) throws -> System_String /* System.String */ {
		let path1C = path1.__handle
		let path2C = path2.__handle
		let path3C = path3.__handle
		let path4C = path4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Combine_2(path1C, path2C, path3C, path4C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func combine(_ paths: System_String_Array /* System.String[] */) throws -> System_String /* System.String */ {
		let pathsC = paths.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Combine_3(pathsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ path1: System_String? /* System.String */, _ path2: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let path1C = path1?.__handle
		let path2C = path2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Join(path1C, path2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ path1: System_String? /* System.String */, _ path2: System_String? /* System.String */, _ path3: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let path1C = path1?.__handle
		let path2C = path2?.__handle
		let path3C = path3?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Join_1(path1C, path2C, path3C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ path1: System_String? /* System.String */, _ path2: System_String? /* System.String */, _ path3: System_String? /* System.String */, _ path4: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let path1C = path1?.__handle
		let path2C = path2?.__handle
		let path3C = path3?.__handle
		let path4C = path4?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Join_2(path1C, path2C, path3C, path4C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func join(_ paths: System_String_Array /* System.String[] */) throws -> System_String /* System.String */ {
		let pathsC = paths.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_Join_3(pathsC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getRelativePath(_ relativeTo: System_String /* System.String */, _ path: System_String /* System.String */) throws -> System_String /* System.String */ {
		let relativeToC = relativeTo.__handle
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetRelativePath(relativeToC, pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func trimEndingDirectorySeparator(_ path: System_String /* System.String */) throws -> System_String /* System.String */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_TrimEndingDirectorySeparator(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func endsInDirectorySeparator(_ path: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_EndsInDirectorySeparator(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getInvalidFileNameChars() throws -> System_Char_Array /* System.Char[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetInvalidFileNameChars(&__exceptionC)
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getInvalidPathChars() throws -> System_Char_Array /* System.Char[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetInvalidPathChars(&__exceptionC)
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFullPath(_ path: System_String /* System.String */) throws -> System_String /* System.String */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetFullPath(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFullPath(_ path: System_String /* System.String */, _ basePath: System_String /* System.String */) throws -> System_String /* System.String */ {
		let pathC = path.__handle
		let basePathC = basePath.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetFullPath_1(pathC, basePathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTempPath() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetTempPath(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getTempFileName() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetTempFileName(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isPathRooted(_ path: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_IsPathRooted(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getPathRoot(_ path: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Path_GetPathRoot(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var directorySeparatorChar: DNChar /* System.Char */ { get {
		
		
		let __returnValueC = System_IO_Path_DirectorySeparatorChar_Get()
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var altDirectorySeparatorChar: DNChar /* System.Char */ { get {
		
		
		let __returnValueC = System_IO_Path_AltDirectorySeparatorChar_Get()
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var volumeSeparatorChar: DNChar /* System.Char */ { get {
		
		
		let __returnValueC = System_IO_Path_VolumeSeparatorChar_Get()
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var pathSeparator: DNChar /* System.Char */ { get {
		
		
		let __returnValueC = System_IO_Path_PathSeparator_Get()
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var invalidPathChars: System_Char_Array /* System.Char[] */ { get {
		
		
		let __returnValueC = System_IO_Path_InvalidPathChars_Get()
		
		let __returnValue = System_Char_Array(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_Path_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_Path_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_File /* System.IO.File */: System_Object {
	public override class var typeName: String { get {
		"File"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.File"
	}}

	public class func openText(_ path: System_String /* System.String */) throws -> System_IO_StreamReader /* System.IO.StreamReader */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_OpenText(pathC, &__exceptionC)
		
		let __returnValue = System_IO_StreamReader(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createText(_ path: System_String /* System.String */) throws -> System_IO_StreamWriter /* System.IO.StreamWriter */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_CreateText(pathC, &__exceptionC)
		
		let __returnValue = System_IO_StreamWriter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func appendText(_ path: System_String /* System.String */) throws -> System_IO_StreamWriter /* System.IO.StreamWriter */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_AppendText(pathC, &__exceptionC)
		
		let __returnValue = System_IO_StreamWriter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copy(_ sourceFileName: System_String /* System.String */, _ destFileName: System_String /* System.String */) throws {
		let sourceFileNameC = sourceFileName.__handle
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Copy(sourceFileNameC, destFileNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func copy(_ sourceFileName: System_String /* System.String */, _ destFileName: System_String /* System.String */, _ overwrite: Bool /* System.Boolean */) throws {
		let sourceFileNameC = sourceFileName.__handle
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Copy_1(sourceFileNameC, destFileNameC, overwrite, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func create(_ path: System_String /* System.String */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Create_1(pathC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func create(_ path: System_String /* System.String */, _ bufferSize: Int32 /* System.Int32 */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Create_2(pathC, bufferSize, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func create(_ path: System_String /* System.String */, _ bufferSize: Int32 /* System.Int32 */, _ options: System_IO_FileOptions /* System.IO.FileOptions */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Create_3(pathC, bufferSize, optionsC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func delete(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Delete(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func exists(_ path: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Exists(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func `open`(_ path: System_String /* System.String */, _ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Open_1(pathC, optionsC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func `open`(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Open_2(pathC, modeC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func `open`(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Open_3(pathC, modeC, accessC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func `open`(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_Open_4(pathC, modeC, accessC, shareC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func openHandle(_ path: System_String /* System.String */, _ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */, _ options: System_IO_FileOptions /* System.IO.FileOptions */, _ preallocationSize: Int64 /* System.Int64 */) throws -> Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */ {
		let pathC = path.__handle
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		let optionsC = options.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_OpenHandle(pathC, modeC, accessC, shareC, optionsC, preallocationSize, &__exceptionC)
		
		let __returnValue = Microsoft_Win32_SafeHandles_SafeFileHandle(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setCreationTime(_ path: System_String /* System.String */, _ creationTime: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let creationTimeC = creationTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetCreationTime(pathC, creationTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setCreationTime(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ creationTime: System_DateTime /* System.DateTime */) throws {
		let fileHandleC = fileHandle.__handle
		let creationTimeC = creationTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetCreationTime_1(fileHandleC, creationTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setCreationTimeUtc(_ path: System_String /* System.String */, _ creationTimeUtc: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let creationTimeUtcC = creationTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetCreationTimeUtc(pathC, creationTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setCreationTimeUtc(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ creationTimeUtc: System_DateTime /* System.DateTime */) throws {
		let fileHandleC = fileHandle.__handle
		let creationTimeUtcC = creationTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetCreationTimeUtc_1(fileHandleC, creationTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getCreationTime(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetCreationTime(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCreationTime(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_DateTime /* System.DateTime */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetCreationTime_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCreationTimeUtc(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetCreationTimeUtc(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCreationTimeUtc(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_DateTime /* System.DateTime */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetCreationTimeUtc_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setLastAccessTime(_ path: System_String /* System.String */, _ lastAccessTime: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastAccessTimeC = lastAccessTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastAccessTime(pathC, lastAccessTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastAccessTime(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ lastAccessTime: System_DateTime /* System.DateTime */) throws {
		let fileHandleC = fileHandle.__handle
		let lastAccessTimeC = lastAccessTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastAccessTime_1(fileHandleC, lastAccessTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastAccessTimeUtc(_ path: System_String /* System.String */, _ lastAccessTimeUtc: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastAccessTimeUtcC = lastAccessTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastAccessTimeUtc(pathC, lastAccessTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastAccessTimeUtc(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ lastAccessTimeUtc: System_DateTime /* System.DateTime */) throws {
		let fileHandleC = fileHandle.__handle
		let lastAccessTimeUtcC = lastAccessTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastAccessTimeUtc_1(fileHandleC, lastAccessTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastAccessTime(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastAccessTime(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastAccessTime(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_DateTime /* System.DateTime */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastAccessTime_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastAccessTimeUtc(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastAccessTimeUtc(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastAccessTimeUtc(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_DateTime /* System.DateTime */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastAccessTimeUtc_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setLastWriteTime(_ path: System_String /* System.String */, _ lastWriteTime: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastWriteTimeC = lastWriteTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastWriteTime(pathC, lastWriteTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastWriteTime(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ lastWriteTime: System_DateTime /* System.DateTime */) throws {
		let fileHandleC = fileHandle.__handle
		let lastWriteTimeC = lastWriteTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastWriteTime_1(fileHandleC, lastWriteTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastWriteTimeUtc(_ path: System_String /* System.String */, _ lastWriteTimeUtc: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastWriteTimeUtcC = lastWriteTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastWriteTimeUtc(pathC, lastWriteTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastWriteTimeUtc(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ lastWriteTimeUtc: System_DateTime /* System.DateTime */) throws {
		let fileHandleC = fileHandle.__handle
		let lastWriteTimeUtcC = lastWriteTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetLastWriteTimeUtc_1(fileHandleC, lastWriteTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastWriteTime(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastWriteTime(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastWriteTime(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_DateTime /* System.DateTime */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastWriteTime_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastWriteTimeUtc(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastWriteTimeUtc(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastWriteTimeUtc(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_DateTime /* System.DateTime */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetLastWriteTimeUtc_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getAttributes(_ path: System_String /* System.String */) throws -> System_IO_FileAttributes /* System.IO.FileAttributes */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetAttributes(pathC, &__exceptionC)
		
		let __returnValue = System_IO_FileAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getAttributes(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_IO_FileAttributes /* System.IO.FileAttributes */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetAttributes_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_IO_FileAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setAttributes(_ path: System_String /* System.String */, _ fileAttributes: System_IO_FileAttributes /* System.IO.FileAttributes */) throws {
		let pathC = path.__handle
		let fileAttributesC = fileAttributes.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetAttributes(pathC, fileAttributesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setAttributes(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ fileAttributes: System_IO_FileAttributes /* System.IO.FileAttributes */) throws {
		let fileHandleC = fileHandle.__handle
		let fileAttributesC = fileAttributes.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetAttributes_1(fileHandleC, fileAttributesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getUnixFileMode(_ path: System_String /* System.String */) throws -> System_IO_UnixFileMode /* System.IO.UnixFileMode */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetUnixFileMode(pathC, &__exceptionC)
		
		let __returnValue = System_IO_UnixFileMode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getUnixFileMode(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */) throws -> System_IO_UnixFileMode /* System.IO.UnixFileMode */ {
		let fileHandleC = fileHandle.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_GetUnixFileMode_1(fileHandleC, &__exceptionC)
		
		let __returnValue = System_IO_UnixFileMode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setUnixFileMode(_ path: System_String /* System.String */, _ mode: System_IO_UnixFileMode /* System.IO.UnixFileMode */) throws {
		let pathC = path.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetUnixFileMode(pathC, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setUnixFileMode(_ fileHandle: Microsoft_Win32_SafeHandles_SafeFileHandle /* Microsoft.Win32.SafeHandles.SafeFileHandle */, _ mode: System_IO_UnixFileMode /* System.IO.UnixFileMode */) throws {
		let fileHandleC = fileHandle.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_SetUnixFileMode_1(fileHandleC, modeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func openRead(_ path: System_String /* System.String */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_OpenRead(pathC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func openWrite(_ path: System_String /* System.String */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_OpenWrite(pathC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllText(_ path: System_String /* System.String */) throws -> System_String /* System.String */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllText(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllText(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws -> System_String /* System.String */ {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllText_1(pathC, encodingC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllText(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */) throws {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllText(pathC, contentsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeAllText(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllText_1(pathC, contentsC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func readAllBytes(_ path: System_String /* System.String */) throws -> System_Byte_Array /* System.Byte[] */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllBytes(pathC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllBytes(_ path: System_String /* System.String */, _ bytes: System_Byte_Array /* System.Byte[] */) throws {
		let pathC = path.__handle
		let bytesC = bytes.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllBytes(pathC, bytesC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func readAllLines(_ path: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllLines(pathC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllLines(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllLines_1(pathC, encodingC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readLines(_ path: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadLines(pathC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readLines(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadLines_1(pathC, encodingC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readLinesAsync(_ path: System_String /* System.String */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Collections_Generic_IAsyncEnumerable_A1 /* System.Collections.Generic.IAsyncEnumerable<System.String> */ {
		let pathC = path.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadLinesAsync(pathC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IAsyncEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readLinesAsync(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Collections_Generic_IAsyncEnumerable_A1 /* System.Collections.Generic.IAsyncEnumerable<System.String> */ {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadLinesAsync_1(pathC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IAsyncEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllLines(_ path: System_String /* System.String */, _ contents: System_String_Array /* System.String[] */) throws {
		let pathC = path.__handle
		let contentsC = contents.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllLines(pathC, contentsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeAllLines(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */) throws {
		let pathC = path.__handle
		let contentsC = contents.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllLines_1(pathC, contentsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeAllLines(_ path: System_String /* System.String */, _ contents: System_String_Array /* System.String[] */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllLines_2(pathC, contentsC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func writeAllLines(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_WriteAllLines_3(pathC, contentsC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func appendAllText(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */) throws {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_AppendAllText(pathC, contentsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func appendAllText(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_AppendAllText_1(pathC, contentsC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func appendAllLines(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */) throws {
		let pathC = path.__handle
		let contentsC = contents.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_AppendAllLines(pathC, contentsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func appendAllLines(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_AppendAllLines_1(pathC, contentsC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func replace(_ sourceFileName: System_String /* System.String */, _ destinationFileName: System_String /* System.String */, _ destinationBackupFileName: System_String? /* System.String */) throws {
		let sourceFileNameC = sourceFileName.__handle
		let destinationFileNameC = destinationFileName.__handle
		let destinationBackupFileNameC = destinationBackupFileName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Replace(sourceFileNameC, destinationFileNameC, destinationBackupFileNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func replace(_ sourceFileName: System_String /* System.String */, _ destinationFileName: System_String /* System.String */, _ destinationBackupFileName: System_String? /* System.String */, _ ignoreMetadataErrors: Bool /* System.Boolean */) throws {
		let sourceFileNameC = sourceFileName.__handle
		let destinationFileNameC = destinationFileName.__handle
		let destinationBackupFileNameC = destinationBackupFileName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Replace_1(sourceFileNameC, destinationFileNameC, destinationBackupFileNameC, ignoreMetadataErrors, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func move(_ sourceFileName: System_String /* System.String */, _ destFileName: System_String /* System.String */) throws {
		let sourceFileNameC = sourceFileName.__handle
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Move(sourceFileNameC, destFileNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func move(_ sourceFileName: System_String /* System.String */, _ destFileName: System_String /* System.String */, _ overwrite: Bool /* System.Boolean */) throws {
		let sourceFileNameC = sourceFileName.__handle
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Move_1(sourceFileNameC, destFileNameC, overwrite, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func encrypt(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Encrypt(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func decrypt(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_File_Decrypt(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func readAllTextAsync(_ path: System_String /* System.String */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		let pathC = path.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllTextAsync(pathC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllTextAsync(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllTextAsync_1(pathC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllTextAsync(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_WriteAllTextAsync(pathC, contentsC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllTextAsync(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_WriteAllTextAsync_1(pathC, contentsC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllBytesAsync(_ path: System_String /* System.String */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Byte[]> */ {
		let pathC = path.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllBytesAsync(pathC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllBytesAsync(_ path: System_String /* System.String */, _ bytes: System_Byte_Array /* System.Byte[] */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let bytesC = bytes.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_WriteAllBytesAsync(pathC, bytesC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllLinesAsync(_ path: System_String /* System.String */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String[]> */ {
		let pathC = path.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllLinesAsync(pathC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readAllLinesAsync(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String[]> */ {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ReadAllLinesAsync_1(pathC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllLinesAsync(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_WriteAllLinesAsync(pathC, contentsC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func writeAllLinesAsync(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_WriteAllLinesAsync_1(pathC, contentsC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func appendAllTextAsync(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_AppendAllTextAsync(pathC, contentsC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func appendAllTextAsync(_ path: System_String /* System.String */, _ contents: System_String? /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents?.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_AppendAllTextAsync_1(pathC, contentsC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func appendAllLinesAsync(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_AppendAllLinesAsync(pathC, contentsC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func appendAllLinesAsync(_ path: System_String /* System.String */, _ contents: System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let pathC = path.__handle
		let contentsC = contents.__handle
		let encodingC = encoding.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_AppendAllLinesAsync_1(pathC, contentsC, encodingC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createSymbolicLink(_ path: System_String /* System.String */, _ pathToTarget: System_String /* System.String */) throws -> System_IO_FileSystemInfo /* System.IO.FileSystemInfo */ {
		let pathC = path.__handle
		let pathToTargetC = pathToTarget.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_CreateSymbolicLink(pathC, pathToTargetC, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func resolveLinkTarget(_ linkPath: System_String /* System.String */, _ returnFinalTarget: Bool /* System.Boolean */) throws -> System_IO_FileSystemInfo? /* System.IO.FileSystemInfo */ {
		let linkPathC = linkPath.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_File_ResolveLinkTarget(linkPathC, returnFinalTarget, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_File_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_File_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_StreamReader /* System.IO.StreamReader */: System_IO_TextReader {
	public override class var typeName: String { get {
		"StreamReader"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.StreamReader"
	}}

	public override func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamReader_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func discardBufferedData() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamReader_DiscardBufferedData(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func peek() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Peek(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func read() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Read(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func read(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Read_1(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func readToEnd() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadToEnd(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func readBlock(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadBlock(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func readLine() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadLine(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func readLineAsync() throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadLineAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func readToEndAsync() throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadToEndAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func readToEndAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadToEndAsync_1(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func readAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadAsync(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func readBlockAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_ReadBlockAsync(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */) throws {
		let streamC = stream.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create(streamC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */) throws {
		let streamC = stream.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_1(streamC, detectEncodingFromByteOrderMarks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let streamC = stream.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_2(streamC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */) throws {
		let streamC = stream.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_3(streamC, encodingC, detectEncodingFromByteOrderMarks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let streamC = stream.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_4(streamC, encodingC, detectEncodingFromByteOrderMarks, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding? /* System.Text.Encoding */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */, _ bufferSize: Int32 /* System.Int32 */, _ leaveOpen: Bool /* System.Boolean */) throws {
		let streamC = stream.__handle
		let encodingC = encoding?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_5(streamC, encodingC, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_6(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_7(pathC, detectEncodingFromByteOrderMarks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_8(pathC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_9(pathC, encodingC, detectEncodingFromByteOrderMarks, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_10(pathC, encodingC, detectEncodingFromByteOrderMarks, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws {
		let pathC = path.__handle
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_11(pathC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ detectEncodingFromByteOrderMarks: Bool /* System.Boolean */, _ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_Create_12(pathC, encodingC, detectEncodingFromByteOrderMarks, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var currentEncoding: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_CurrentEncoding_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var baseStream: System_IO_Stream /* System.IO.Stream */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_BaseStream_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var endOfStream: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamReader_EndOfStream_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var null: System_IO_StreamReader /* System.IO.StreamReader */ { get {
		
		
		let __returnValueC = System_IO_StreamReader_Null_Get()
		
		let __returnValue = System_IO_StreamReader(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_StreamReader_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_StreamReader_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_TextReader /* System.IO.TextReader */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"TextReader"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.TextReader"
	}}

	public func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextReader_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextReader_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func peek() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_Peek(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func read() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_Read(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func read(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_Read_1(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func readToEnd() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadToEnd(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readBlock(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadBlock(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func readLine() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadLine(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readLineAsync() throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadLineAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readToEndAsync() throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadToEndAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readToEndAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.String> */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadToEndAsync_1(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadAsync(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func readBlockAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_ReadBlockAsync(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func synchronized(_ reader: System_IO_TextReader /* System.IO.TextReader */) throws -> System_IO_TextReader /* System.IO.TextReader */ {
		let readerC = reader.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextReader_Synchronized(readerC, &__exceptionC)
		
		let __returnValue = System_IO_TextReader(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var null: System_IO_TextReader /* System.IO.TextReader */ { get {
		
		
		let __returnValueC = System_IO_TextReader_Null_Get()
		
		let __returnValue = System_IO_TextReader(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_TextReader_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_TextReader_Destroy(self.__handle)
		
	}
	
	
}










public class System_IO_StreamWriter /* System.IO.StreamWriter */: System_IO_TextWriter {
	public override class var typeName: String { get {
		"StreamWriter"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.StreamWriter"
	}}

	public override func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func flush() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Flush(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ value: DNChar /* System.Char */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ buffer: System_Char_Array? /* System.Char[] */) throws {
		let bufferC = buffer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_1(self.__handle, bufferC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_2(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_3(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeLine(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_WriteLine(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_4(self.__handle, formatC, arg0C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_5(self.__handle, formatC, arg0C, arg1C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_6(self.__handle, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func write(_ format: System_String /* System.String */, _ arg: System_Object_Array /* System.Object[] */) throws {
		let formatC = format.__handle
		let argC = arg.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_Write_7(self.__handle, formatC, argC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeLine(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_WriteLine_1(self.__handle, formatC, arg0C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeLine(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_WriteLine_2(self.__handle, formatC, arg0C, arg1C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeLine(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_WriteLine_3(self.__handle, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeLine(_ format: System_String /* System.String */, _ arg: System_Object_Array /* System.Object[] */) throws {
		let formatC = format.__handle
		let argC = arg.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_WriteLine_4(self.__handle, formatC, argC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func writeAsync(_ value: DNChar /* System.Char */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteAsync(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func writeAsync(_ value: System_String? /* System.String */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteAsync_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func writeAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteAsync_2(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func writeLineAsync() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteLineAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func writeLineAsync(_ value: DNChar /* System.Char */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteLineAsync_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func writeLineAsync(_ value: System_String? /* System.String */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteLineAsync_2(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func writeLineAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_WriteLineAsync_3(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func flushAsync() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_FlushAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func flushAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_FlushAsync_1(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */) throws {
		let streamC = stream.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create(streamC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let streamC = stream.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_1(streamC, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let streamC = stream.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_2(streamC, encodingC, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ stream: System_IO_Stream /* System.IO.Stream */, _ encoding: System_Text_Encoding? /* System.Text.Encoding */, _ bufferSize: Int32 /* System.Int32 */, _ leaveOpen: Bool /* System.Boolean */) throws {
		let streamC = stream.__handle
		let encodingC = encoding?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_3(streamC, encodingC, bufferSize, leaveOpen, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_4(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ append: Bool /* System.Boolean */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_5(pathC, append, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ append: Bool /* System.Boolean */, _ encoding: System_Text_Encoding /* System.Text.Encoding */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_6(pathC, append, encodingC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ append: Bool /* System.Boolean */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ bufferSize: Int32 /* System.Int32 */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_7(pathC, append, encodingC, bufferSize, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws {
		let pathC = path.__handle
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_8(pathC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ path: System_String /* System.String */, _ encoding: System_Text_Encoding /* System.Text.Encoding */, _ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws {
		let pathC = path.__handle
		let encodingC = encoding.__handle
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Create_9(pathC, encodingC, optionsC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var autoFlush: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_AutoFlush_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func autoFlush_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_StreamWriter_AutoFlush_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var baseStream: System_IO_Stream /* System.IO.Stream */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_BaseStream_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_Stream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override var encoding: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_StreamWriter_Encoding_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var null: System_IO_StreamWriter /* System.IO.StreamWriter */ { get {
		
		
		let __returnValueC = System_IO_StreamWriter_Null_Get()
		
		let __returnValue = System_IO_StreamWriter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_StreamWriter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_StreamWriter_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_TextWriter /* System.IO.TextWriter */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"TextWriter"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.TextWriter"
	}}

	public func close() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Close(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func dispose() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Dispose(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func disposeAsync() throws -> System_Threading_Tasks_ValueTask /* System.Threading.Tasks.ValueTask */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_DisposeAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_ValueTask(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func flush() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Flush(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: DNChar /* System.Char */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ buffer: System_Char_Array? /* System.Char[] */) throws {
		let bufferC = buffer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_1(self.__handle, bufferC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_2(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_3(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_4(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: UInt32 /* System.UInt32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_5(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_6(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: UInt64 /* System.UInt64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_7(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: Float /* System.Single */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_8(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: Double /* System.Double */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_9(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: System_Decimal /* System.Decimal */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_10(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_11(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_12(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ value: System_Text_StringBuilder? /* System.Text.StringBuilder */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_13(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_14(self.__handle, formatC, arg0C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_15(self.__handle, formatC, arg0C, arg1C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_16(self.__handle, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func write(_ format: System_String /* System.String */, _ arg: System_Object_Array /* System.Object[] */) throws {
		let formatC = format.__handle
		let argC = arg.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_Write_17(self.__handle, formatC, argC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: DNChar /* System.Char */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ buffer: System_Char_Array? /* System.Char[] */) throws {
		let bufferC = buffer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_2(self.__handle, bufferC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_3(self.__handle, bufferC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_4(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_5(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: UInt32 /* System.UInt32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_6(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: Int64 /* System.Int64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_7(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: UInt64 /* System.UInt64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_8(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: Float /* System.Single */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_9(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: Double /* System.Double */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_10(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: System_Decimal /* System.Decimal */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_11(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_12(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: System_Text_StringBuilder? /* System.Text.StringBuilder */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_13(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ value: System_Object? /* System.Object */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_14(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_15(self.__handle, formatC, arg0C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_16(self.__handle, formatC, arg0C, arg1C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ format: System_String /* System.String */, _ arg0: System_Object? /* System.Object */, _ arg1: System_Object? /* System.Object */, _ arg2: System_Object? /* System.Object */) throws {
		let formatC = format.__handle
		let arg0C = arg0?.__handle
		let arg1C = arg1?.__handle
		let arg2C = arg2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_17(self.__handle, formatC, arg0C, arg1C, arg2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeLine(_ format: System_String /* System.String */, _ arg: System_Object_Array /* System.Object[] */) throws {
		let formatC = format.__handle
		let argC = arg.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_WriteLine_18(self.__handle, formatC, argC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func writeAsync(_ value: DNChar /* System.Char */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteAsync(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeAsync(_ value: System_String? /* System.String */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteAsync_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeAsync(_ value: System_Text_StringBuilder? /* System.Text.StringBuilder */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value?.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteAsync_2(self.__handle, valueC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeAsync(_ buffer: System_Char_Array? /* System.Char[] */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteAsync_3(self.__handle, bufferC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteAsync_4(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeLineAsync(_ value: DNChar /* System.Char */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteLineAsync(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeLineAsync(_ value: System_String? /* System.String */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteLineAsync_1(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeLineAsync(_ value: System_Text_StringBuilder? /* System.Text.StringBuilder */, _ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let valueC = value?.__handle
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteLineAsync_2(self.__handle, valueC, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeLineAsync(_ buffer: System_Char_Array? /* System.Char[] */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteLineAsync_3(self.__handle, bufferC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeLineAsync(_ buffer: System_Char_Array /* System.Char[] */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let bufferC = buffer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteLineAsync_4(self.__handle, bufferC, index, count, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func writeLineAsync() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_WriteLineAsync_5(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func flushAsync() throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_FlushAsync(self.__handle, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func flushAsync(_ cancellationToken: System_Threading_CancellationToken /* System.Threading.CancellationToken */) throws -> System_Threading_Tasks_Task /* System.Threading.Tasks.Task */ {
		let cancellationTokenC = cancellationToken.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_FlushAsync_1(self.__handle, cancellationTokenC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func synchronized(_ writer: System_IO_TextWriter /* System.IO.TextWriter */) throws -> System_IO_TextWriter /* System.IO.TextWriter */ {
		let writerC = writer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_Synchronized(writerC, &__exceptionC)
		
		let __returnValue = System_IO_TextWriter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var formatProvider: System_IFormatProvider /* System.IFormatProvider */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_FormatProvider_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IFormatProvider(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var encoding: System_Text_Encoding /* System.Text.Encoding */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_Encoding_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Text_Encoding(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var newLine: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_TextWriter_NewLine_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func newLine_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_TextWriter_NewLine_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var null: System_IO_TextWriter /* System.IO.TextWriter */ { get {
		
		
		let __returnValueC = System_IO_TextWriter_Null_Get()
		
		let __returnValue = System_IO_TextWriter(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_TextWriter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_TextWriter_Destroy(self.__handle)
		
	}
	
	
}


public class System_Collections_Generic_IAsyncEnumerable_A1 /* System.Collections.Generic.IAsyncEnumerable<> */: DNObject {
	public override class var typeName: String { get {
		"IAsyncEnumerable`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IAsyncEnumerable<>"
	}}

	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IAsyncEnumerable_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IAsyncEnumerable_A1_Destroy(self.__handle)
		
	}
	
	
}




public class System_Collections_Generic_IAsyncEnumerator_A1 /* System.Collections.Generic.IAsyncEnumerator<> */: DNObject {
	public override class var typeName: String { get {
		"IAsyncEnumerator`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IAsyncEnumerator<>"
	}}

	public func current(T: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IAsyncEnumerator_A1_Current_Get(self.__handle, TC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IAsyncEnumerator_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IAsyncEnumerator_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


















public class System_IO_FileSystemInfo /* System.IO.FileSystemInfo */: System_MarshalByRefObject {
	public override class var typeName: String { get {
		"FileSystemInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileSystemInfo"
	}}

	public func getObjectData(_ info: System_Runtime_Serialization_SerializationInfo /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let infoC = info.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_GetObjectData(self.__handle, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func delete() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_Delete(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func createAsSymbolicLink(_ pathToTarget: System_String /* System.String */) throws {
		let pathToTargetC = pathToTarget.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_CreateAsSymbolicLink(self.__handle, pathToTargetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func resolveLinkTarget(_ returnFinalTarget: Bool /* System.Boolean */) throws -> System_IO_FileSystemInfo? /* System.IO.FileSystemInfo */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_ResolveLinkTarget(self.__handle, returnFinalTarget, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func refresh() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_Refresh(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var fullName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_FullName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var `extension`: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_Extension_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var exists: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_Exists_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var creationTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_CreationTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func creationTime_set(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_CreationTime_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var creationTimeUtc: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_CreationTimeUtc_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func creationTimeUtc_set(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_CreationTimeUtc_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var lastAccessTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_LastAccessTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func lastAccessTime_set(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_LastAccessTime_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var lastAccessTimeUtc: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_LastAccessTimeUtc_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func lastAccessTimeUtc_set(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_LastAccessTimeUtc_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var lastWriteTime: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_LastWriteTime_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func lastWriteTime_set(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_LastWriteTime_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var lastWriteTimeUtc: System_DateTime /* System.DateTime */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_LastWriteTimeUtc_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func lastWriteTimeUtc_set(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_LastWriteTimeUtc_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var linkTarget: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_LinkTarget_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var unixFileMode: System_IO_UnixFileMode /* System.IO.UnixFileMode */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_UnixFileMode_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_UnixFileMode(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func unixFileMode_set(_ value: System_IO_UnixFileMode /* System.IO.UnixFileMode */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_UnixFileMode_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var attributes: System_IO_FileAttributes /* System.IO.FileAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileSystemInfo_Attributes_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func attributes_set(_ value: System_IO_FileAttributes /* System.IO.FileAttributes */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileSystemInfo_Attributes_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileSystemInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_FileSystemInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_FileInfo /* System.IO.FileInfo */: System_IO_FileSystemInfo {
	public override class var typeName: String { get {
		"FileInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileInfo"
	}}

	public func `open`(_ options: System_IO_FileStreamOptions /* System.IO.FileStreamOptions */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let optionsC = options.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Open(self.__handle, optionsC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func openText() throws -> System_IO_StreamReader /* System.IO.StreamReader */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_OpenText(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_StreamReader(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func createText() throws -> System_IO_StreamWriter /* System.IO.StreamWriter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_CreateText(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_StreamWriter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func appendText() throws -> System_IO_StreamWriter /* System.IO.StreamWriter */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_AppendText(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_StreamWriter(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyTo(_ destFileName: System_String /* System.String */) throws -> System_IO_FileInfo /* System.IO.FileInfo */ {
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_CopyTo(self.__handle, destFileNameC, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func copyTo(_ destFileName: System_String /* System.String */, _ overwrite: Bool /* System.Boolean */) throws -> System_IO_FileInfo /* System.IO.FileInfo */ {
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_CopyTo_1(self.__handle, destFileNameC, overwrite, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func create() throws -> System_IO_FileStream /* System.IO.FileStream */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Create_1(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func delete() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileInfo_Delete(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func `open`(_ mode: System_IO_FileMode /* System.IO.FileMode */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Open_1(self.__handle, modeC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func `open`(_ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let modeC = mode.cValue
		let accessC = access.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Open_2(self.__handle, modeC, accessC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func `open`(_ mode: System_IO_FileMode /* System.IO.FileMode */, _ access: System_IO_FileAccess /* System.IO.FileAccess */, _ share: System_IO_FileShare /* System.IO.FileShare */) throws -> System_IO_FileStream /* System.IO.FileStream */ {
		let modeC = mode.cValue
		let accessC = access.cValue
		let shareC = share.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Open_3(self.__handle, modeC, accessC, shareC, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func openRead() throws -> System_IO_FileStream /* System.IO.FileStream */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_OpenRead(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func openWrite() throws -> System_IO_FileStream /* System.IO.FileStream */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_OpenWrite(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileStream(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func moveTo(_ destFileName: System_String /* System.String */) throws {
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileInfo_MoveTo(self.__handle, destFileNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func moveTo(_ destFileName: System_String /* System.String */, _ overwrite: Bool /* System.Boolean */) throws {
		let destFileNameC = destFileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileInfo_MoveTo_1(self.__handle, destFileNameC, overwrite, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func replace(_ destinationFileName: System_String /* System.String */, _ destinationBackupFileName: System_String? /* System.String */) throws -> System_IO_FileInfo /* System.IO.FileInfo */ {
		let destinationFileNameC = destinationFileName.__handle
		let destinationBackupFileNameC = destinationBackupFileName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Replace(self.__handle, destinationFileNameC, destinationBackupFileNameC, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func replace(_ destinationFileName: System_String /* System.String */, _ destinationBackupFileName: System_String? /* System.String */, _ ignoreMetadataErrors: Bool /* System.Boolean */) throws -> System_IO_FileInfo /* System.IO.FileInfo */ {
		let destinationFileNameC = destinationFileName.__handle
		let destinationBackupFileNameC = destinationBackupFileName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Replace_1(self.__handle, destinationFileNameC, destinationBackupFileNameC, ignoreMetadataErrors, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func decrypt() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileInfo_Decrypt(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func encrypt() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileInfo_Encrypt(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ fileName: System_String /* System.String */) throws {
		let fileNameC = fileName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Create_2(fileNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var length: Int64 /* System.Int64 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var directoryName: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_DirectoryName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var directory: System_IO_DirectoryInfo? /* System.IO.DirectoryInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Directory_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isReadOnly: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_IsReadOnly_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func isReadOnly_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_FileInfo_IsReadOnly_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override var exists: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_FileInfo_Exists_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_FileInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_FileInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_DirectoryInfo /* System.IO.DirectoryInfo */: System_IO_FileSystemInfo {
	public override class var typeName: String { get {
		"DirectoryInfo"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.DirectoryInfo"
	}}

	public func createSubdirectory(_ path: System_String /* System.String */) throws -> System_IO_DirectoryInfo /* System.IO.DirectoryInfo */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_CreateSubdirectory(self.__handle, pathC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func create() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_DirectoryInfo_Create_1(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getFiles() throws -> System_IO_FileInfo_Array /* System.IO.FileInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFiles(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFiles(_ searchPattern: System_String /* System.String */) throws -> System_IO_FileInfo_Array /* System.IO.FileInfo[] */ {
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFiles_1(self.__handle, searchPatternC, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFiles(_ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_IO_FileInfo_Array /* System.IO.FileInfo[] */ {
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFiles_2(self.__handle, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFiles(_ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_IO_FileInfo_Array /* System.IO.FileInfo[] */ {
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFiles_3(self.__handle, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_IO_FileInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFileSystemInfos() throws -> System_IO_FileSystemInfo_Array /* System.IO.FileSystemInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFileSystemInfos(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFileSystemInfos(_ searchPattern: System_String /* System.String */) throws -> System_IO_FileSystemInfo_Array /* System.IO.FileSystemInfo[] */ {
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFileSystemInfos_1(self.__handle, searchPatternC, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFileSystemInfos(_ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_IO_FileSystemInfo_Array /* System.IO.FileSystemInfo[] */ {
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFileSystemInfos_2(self.__handle, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getFileSystemInfos(_ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_IO_FileSystemInfo_Array /* System.IO.FileSystemInfo[] */ {
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetFileSystemInfos_3(self.__handle, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDirectories() throws -> System_IO_DirectoryInfo_Array /* System.IO.DirectoryInfo[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetDirectories(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDirectories(_ searchPattern: System_String /* System.String */) throws -> System_IO_DirectoryInfo_Array /* System.IO.DirectoryInfo[] */ {
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetDirectories_1(self.__handle, searchPatternC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDirectories(_ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_IO_DirectoryInfo_Array /* System.IO.DirectoryInfo[] */ {
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetDirectories_2(self.__handle, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDirectories(_ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_IO_DirectoryInfo_Array /* System.IO.DirectoryInfo[] */ {
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_GetDirectories_3(self.__handle, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateDirectories() throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateDirectories(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateDirectories(_ searchPattern: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> */ {
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateDirectories_1(self.__handle, searchPatternC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateDirectories(_ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> */ {
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateDirectories_2(self.__handle, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateDirectories(_ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> */ {
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateDirectories_3(self.__handle, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFiles() throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileInfo> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFiles(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFiles(_ searchPattern: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileInfo> */ {
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFiles_1(self.__handle, searchPatternC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFiles(_ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileInfo> */ {
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFiles_2(self.__handle, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFiles(_ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileInfo> */ {
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFiles_3(self.__handle, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFileSystemInfos() throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFileSystemInfos(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFileSystemInfos(_ searchPattern: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> */ {
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFileSystemInfos_1(self.__handle, searchPatternC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFileSystemInfos(_ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> */ {
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFileSystemInfos_2(self.__handle, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func enumerateFileSystemInfos(_ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> */ {
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_EnumerateFileSystemInfos_3(self.__handle, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func moveTo(_ destDirName: System_String /* System.String */) throws {
		let destDirNameC = destDirName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_DirectoryInfo_MoveTo(self.__handle, destDirNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func delete() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_DirectoryInfo_Delete(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func delete(_ recursive: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_DirectoryInfo_Delete_1(self.__handle, recursive, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_Create_2(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var parent: System_IO_DirectoryInfo? /* System.IO.DirectoryInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_Parent_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var root: System_IO_DirectoryInfo /* System.IO.DirectoryInfo */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_Root_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override var exists: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_DirectoryInfo_Exists_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_DirectoryInfo_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_DirectoryInfo_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_FileInfo_Array /* System.IO.FileInfo[] */: System_Array {
	public override class var typeName: String { get {
		"FileInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileInfo[]"
	}}

	
}















public class System_IO_EnumerationOptions /* System.IO.EnumerationOptions */: System_Object {
	public override class var typeName: String { get {
		"EnumerationOptions"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.EnumerationOptions"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var recurseSubdirectories: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_RecurseSubdirectories_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func recurseSubdirectories_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_RecurseSubdirectories_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var ignoreInaccessible: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_IgnoreInaccessible_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func ignoreInaccessible_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_IgnoreInaccessible_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var bufferSize: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_BufferSize_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func bufferSize_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_BufferSize_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var attributesToSkip: System_IO_FileAttributes /* System.IO.FileAttributes */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_AttributesToSkip_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_FileAttributes(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func attributesToSkip_set(_ value: System_IO_FileAttributes /* System.IO.FileAttributes */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_AttributesToSkip_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var matchType: System_IO_MatchType /* System.IO.MatchType */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_MatchType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_MatchType(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func matchType_set(_ value: System_IO_MatchType /* System.IO.MatchType */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_MatchType_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var matchCasing: System_IO_MatchCasing /* System.IO.MatchCasing */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_MatchCasing_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_IO_MatchCasing(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func matchCasing_set(_ value: System_IO_MatchCasing /* System.IO.MatchCasing */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_MatchCasing_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var maxRecursionDepth: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_MaxRecursionDepth_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func maxRecursionDepth_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_MaxRecursionDepth_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var returnSpecialDirectories: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_EnumerationOptions_ReturnSpecialDirectories_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func returnSpecialDirectories_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_EnumerationOptions_ReturnSpecialDirectories_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_EnumerationOptions_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_EnumerationOptions_Destroy(self.__handle)
		
	}
	
	
}


public class System_IO_FileSystemInfo_Array /* System.IO.FileSystemInfo[] */: System_Array {
	public override class var typeName: String { get {
		"FileSystemInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.FileSystemInfo[]"
	}}

	
}















public class System_IO_DirectoryInfo_Array /* System.IO.DirectoryInfo[] */: System_Array {
	public override class var typeName: String { get {
		"DirectoryInfo[]"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.DirectoryInfo[]"
	}}

	
}















public class System_IO_Directory /* System.IO.Directory */: System_Object {
	public override class var typeName: String { get {
		"Directory"
	}}

	public override class var fullTypeName: String { get {
		"System.IO.Directory"
	}}

	public class func getParent(_ path: System_String /* System.String */) throws -> System_IO_DirectoryInfo? /* System.IO.DirectoryInfo */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetParent(pathC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createDirectory(_ path: System_String /* System.String */) throws -> System_IO_DirectoryInfo /* System.IO.DirectoryInfo */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_CreateDirectory(pathC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createDirectory(_ path: System_String /* System.String */, _ unixCreateMode: System_IO_UnixFileMode /* System.IO.UnixFileMode */) throws -> System_IO_DirectoryInfo /* System.IO.DirectoryInfo */ {
		let pathC = path.__handle
		let unixCreateModeC = unixCreateMode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_CreateDirectory_1(pathC, unixCreateModeC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createTempSubdirectory(_ prefix: System_String? /* System.String */) throws -> System_IO_DirectoryInfo /* System.IO.DirectoryInfo */ {
		let prefixC = prefix?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_CreateTempSubdirectory(prefixC, &__exceptionC)
		
		let __returnValue = System_IO_DirectoryInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exists(_ path: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let pathC = path?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_Exists(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func setCreationTime(_ path: System_String /* System.String */, _ creationTime: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let creationTimeC = creationTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetCreationTime(pathC, creationTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setCreationTimeUtc(_ path: System_String /* System.String */, _ creationTimeUtc: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let creationTimeUtcC = creationTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetCreationTimeUtc(pathC, creationTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getCreationTime(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetCreationTime(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCreationTimeUtc(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetCreationTimeUtc(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setLastWriteTime(_ path: System_String /* System.String */, _ lastWriteTime: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastWriteTimeC = lastWriteTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetLastWriteTime(pathC, lastWriteTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastWriteTimeUtc(_ path: System_String /* System.String */, _ lastWriteTimeUtc: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastWriteTimeUtcC = lastWriteTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetLastWriteTimeUtc(pathC, lastWriteTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastWriteTime(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetLastWriteTime(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastWriteTimeUtc(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetLastWriteTimeUtc(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setLastAccessTime(_ path: System_String /* System.String */, _ lastAccessTime: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastAccessTimeC = lastAccessTime.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetLastAccessTime(pathC, lastAccessTimeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func setLastAccessTimeUtc(_ path: System_String /* System.String */, _ lastAccessTimeUtc: System_DateTime /* System.DateTime */) throws {
		let pathC = path.__handle
		let lastAccessTimeUtcC = lastAccessTimeUtc.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetLastAccessTimeUtc(pathC, lastAccessTimeUtcC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLastAccessTime(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetLastAccessTime(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getLastAccessTimeUtc(_ path: System_String /* System.String */) throws -> System_DateTime /* System.DateTime */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetLastAccessTimeUtc(pathC, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFiles(_ path: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFiles(pathC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFiles(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFiles_1(pathC, searchPatternC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFiles(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFiles_2(pathC, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFiles(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFiles_3(pathC, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDirectories(_ path: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetDirectories(pathC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDirectories(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetDirectories_1(pathC, searchPatternC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDirectories(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetDirectories_2(pathC, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDirectories(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetDirectories_3(pathC, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFileSystemEntries(_ path: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFileSystemEntries(pathC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFileSystemEntries(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFileSystemEntries_1(pathC, searchPatternC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFileSystemEntries(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFileSystemEntries_2(pathC, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getFileSystemEntries(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_String_Array /* System.String[] */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetFileSystemEntries_3(pathC, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateDirectories(_ path: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateDirectories(pathC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateDirectories(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateDirectories_1(pathC, searchPatternC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateDirectories(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateDirectories_2(pathC, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateDirectories(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateDirectories_3(pathC, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFiles(_ path: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFiles(pathC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFiles(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFiles_1(pathC, searchPatternC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFiles(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFiles_2(pathC, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFiles(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFiles_3(pathC, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFileSystemEntries(_ path: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFileSystemEntries(pathC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFileSystemEntries(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFileSystemEntries_1(pathC, searchPatternC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFileSystemEntries(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ searchOption: System_IO_SearchOption /* System.IO.SearchOption */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let searchOptionC = searchOption.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFileSystemEntries_2(pathC, searchPatternC, searchOptionC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func enumerateFileSystemEntries(_ path: System_String /* System.String */, _ searchPattern: System_String /* System.String */, _ enumerationOptions: System_IO_EnumerationOptions /* System.IO.EnumerationOptions */) throws -> System_Collections_Generic_IEnumerable_A1 /* System.Collections.Generic.IEnumerable<System.String> */ {
		let pathC = path.__handle
		let searchPatternC = searchPattern.__handle
		let enumerationOptionsC = enumerationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_EnumerateFileSystemEntries_3(pathC, searchPatternC, enumerationOptionsC, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_IEnumerable_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getDirectoryRoot(_ path: System_String /* System.String */) throws -> System_String /* System.String */ {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetDirectoryRoot(pathC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getCurrentDirectory() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetCurrentDirectory(&__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func setCurrentDirectory(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_SetCurrentDirectory(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func move(_ sourceDirName: System_String /* System.String */, _ destDirName: System_String /* System.String */) throws {
		let sourceDirNameC = sourceDirName.__handle
		let destDirNameC = destDirName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_Move(sourceDirNameC, destDirNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func delete(_ path: System_String /* System.String */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_Delete(pathC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func delete(_ path: System_String /* System.String */, _ recursive: Bool /* System.Boolean */) throws {
		let pathC = path.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_IO_Directory_Delete_1(pathC, recursive, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getLogicalDrives() throws -> System_String_Array /* System.String[] */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_GetLogicalDrives(&__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createSymbolicLink(_ path: System_String /* System.String */, _ pathToTarget: System_String /* System.String */) throws -> System_IO_FileSystemInfo /* System.IO.FileSystemInfo */ {
		let pathC = path.__handle
		let pathToTargetC = pathToTarget.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_CreateSymbolicLink(pathC, pathToTargetC, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func resolveLinkTarget(_ linkPath: System_String /* System.String */, _ returnFinalTarget: Bool /* System.Boolean */) throws -> System_IO_FileSystemInfo? /* System.IO.FileSystemInfo */ {
		let linkPathC = linkPath.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_IO_Directory_ResolveLinkTarget(linkPathC, returnFinalTarget, &__exceptionC)
		
		let __returnValue = System_IO_FileSystemInfo(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_IO_Directory_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_IO_Directory_Destroy(self.__handle)
		
	}
	
	
}


public class System_Buffers_Binary_BinaryPrimitives /* System.Buffers.Binary.BinaryPrimitives */: System_Object {
	public override class var typeName: String { get {
		"BinaryPrimitives"
	}}

	public override class var fullTypeName: String { get {
		"System.Buffers.Binary.BinaryPrimitives"
	}}

	public class func readDoubleBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Double /* System.Double */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadDoubleBigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readHalfBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_Half /* System.Half */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadHalfBigEndian(sourceC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readInt16BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int16 /* System.Int16 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt16BigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt32BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt32BigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt64BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int64 /* System.Int64 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt64BigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt128BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_Int128 /* System.Int128 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt128BigEndian(sourceC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readIntPtrBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadIntPtrBigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readSingleBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Float /* System.Single */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadSingleBigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt16BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt16 /* System.UInt16 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt16BigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt32BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt32 /* System.UInt32 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt32BigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt64BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt64 /* System.UInt64 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt64BigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt128BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_UInt128 /* System.UInt128 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt128BigEndian(sourceC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readUIntPtrBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt /* System.UIntPtr */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUIntPtrBigEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadDoubleBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Double /* System.Double */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadDoubleBigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadHalfBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadHalfBigEndian(sourceC, &valueC, &__exceptionC)
		
		value = System_Half(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt16BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Int16 /* System.Int16 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt16BigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt32BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt32BigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt64BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Int64 /* System.Int64 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt64BigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt128BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt128BigEndian(sourceC, &valueC, &__exceptionC)
		
		value = System_Int128(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadIntPtrBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadIntPtrBigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadSingleBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Float /* System.Single */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadSingleBigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt16BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt16 /* System.UInt16 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt16BigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt32BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt32 /* System.UInt32 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt32BigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt64BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt64 /* System.UInt64 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt64BigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt128BigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt128BigEndian(sourceC, &valueC, &__exceptionC)
		
		value = System_UInt128(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUIntPtrBigEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt /* System.UIntPtr */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUIntPtrBigEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readDoubleLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Double /* System.Double */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadDoubleLittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readHalfLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_Half /* System.Half */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadHalfLittleEndian(sourceC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readInt16LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int16 /* System.Int16 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt16LittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt32LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int32 /* System.Int32 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt32LittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt64LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Int64 /* System.Int64 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt64LittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readInt128LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_Int128 /* System.Int128 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadInt128LittleEndian(sourceC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readIntPtrLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadIntPtrLittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readSingleLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Float /* System.Single */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadSingleLittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt16LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt16 /* System.UInt16 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt16LittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt32LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt32 /* System.UInt32 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt32LittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt64LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt64 /* System.UInt64 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt64LittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func readUInt128LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_UInt128 /* System.UInt128 */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUInt128LittleEndian(sourceC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func readUIntPtrLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> UInt /* System.UIntPtr */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReadUIntPtrLittleEndian(sourceC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadDoubleLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Double /* System.Double */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadDoubleLittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadHalfLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadHalfLittleEndian(sourceC, &valueC, &__exceptionC)
		
		value = System_Half(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt16LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Int16 /* System.Int16 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt16LittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt32LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt32LittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt64LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Int64 /* System.Int64 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt64LittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadInt128LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadInt128LittleEndian(sourceC, &valueC, &__exceptionC)
		
		value = System_Int128(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadIntPtrLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UnsafeMutableRawPointer? /* System.IntPtr */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadIntPtrLittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadSingleLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout Float /* System.Single */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadSingleLittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt16LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt16 /* System.UInt16 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt16LittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt32LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt32 /* System.UInt32 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt32LittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt64LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt64 /* System.UInt64 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt64LittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUInt128LittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		var valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUInt128LittleEndian(sourceC, &valueC, &__exceptionC)
		
		value = System_UInt128(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryReadUIntPtrLittleEndian(_ source: Data? /* System.ReadOnlySpan<System.Byte> */, _ value: inout UInt /* System.UIntPtr */) throws -> Bool /* System.Boolean */ {
		let sourceC = source.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_TryReadUIntPtrLittleEndian(sourceC, &value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: Int8 /* System.SByte */) throws -> Int8 /* System.SByte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: Int16 /* System.Int16 */) throws -> Int16 /* System.Int16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_1(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_2(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: Int64 /* System.Int64 */) throws -> Int64 /* System.Int64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_3(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: UnsafeMutableRawPointer? /* System.IntPtr */) throws -> UnsafeMutableRawPointer? /* System.IntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_4(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_5(valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reverseEndianness(_ value: UInt8 /* System.Byte */) throws -> UInt8 /* System.Byte */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_6(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: UInt16 /* System.UInt16 */) throws -> UInt16 /* System.UInt16 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_7(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: UInt32 /* System.UInt32 */) throws -> UInt32 /* System.UInt32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_8(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: UInt64 /* System.UInt64 */) throws -> UInt64 /* System.UInt64 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_9(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: UInt /* System.UIntPtr */) throws -> UInt /* System.UIntPtr */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_10(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func reverseEndianness(_ value: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Buffers_Binary_BinaryPrimitives_ReverseEndianness_11(valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Buffers_Binary_BinaryPrimitives_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Buffers_Binary_BinaryPrimitives_Destroy(self.__handle)
		
	}
	
	
}


public class System_Half /* System.Half */: System_ValueType {
	public override class var typeName: String { get {
		"Half"
	}}

	public override class var fullTypeName: String { get {
		"System.Half"
	}}

	public class func isFinite(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsFinite(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isInfinity(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsInfinity(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNaN(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsNaN(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNegative(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsNegative(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNegativeInfinity(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsNegativeInfinity(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNormal(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsNormal(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isPositiveInfinity(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsPositiveInfinity(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isSubnormal(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsSubnormal(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_Half /* System.Half */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Parse(sC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */) throws -> System_Half /* System.Half */ {
		let sC = s.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Parse_1(sC, styleC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Half /* System.Half */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Parse_2(sC, providerC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Half /* System.Half */ {
		let sC = s.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Parse_3(sC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_Half(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ result: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TryParse_1(utf8TextC, &resultC, &__exceptionC)
		
		result = System_Half(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TryParse_2(sC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_Half(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ obj: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CompareTo(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ other: System_Half /* System.Half */) throws -> Int32 /* System.Int32 */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CompareTo_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ToString_1(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ToString_2(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isPow2(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsPow2(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log2(_ value: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Log2(valueC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Exp(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func expM1(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ExpM1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp2(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Exp2(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp2M1(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Exp2M1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp10(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Exp10(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func exp10M1(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Exp10M1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ceiling(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Ceiling(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func floor(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Floor(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Round(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ x: System_Half /* System.Half */, _ digits: Int32 /* System.Int32 */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Round_1(xC, digits, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ x: System_Half /* System.Half */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Round_2(xC, modeC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func round(_ x: System_Half /* System.Half */, _ digits: Int32 /* System.Int32 */, _ mode: System_MidpointRounding /* System.MidpointRounding */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let modeC = mode.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Round_3(xC, digits, modeC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func truncate(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Truncate(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atan2(_ y: System_Half /* System.Half */, _ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let yC = y.__handle
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Atan2(yC, xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atan2Pi(_ y: System_Half /* System.Half */, _ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let yC = y.__handle
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Atan2Pi(yC, xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func bitDecrement(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_BitDecrement(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func bitIncrement(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_BitIncrement(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func fusedMultiplyAdd(_ left: System_Half /* System.Half */, _ right: System_Half /* System.Half */, _ addend: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let leftC = left.__handle
		let rightC = right.__handle
		let addendC = addend.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_FusedMultiplyAdd(leftC, rightC, addendC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func ieee754Remainder(_ left: System_Half /* System.Half */, _ right: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let leftC = left.__handle
		let rightC = right.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Ieee754Remainder(leftC, rightC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func iLogB(_ x: System_Half /* System.Half */) throws -> Int32 /* System.Int32 */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ILogB(xC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func lerp(_ value1: System_Half /* System.Half */, _ value2: System_Half /* System.Half */, _ amount: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let value1C = value1.__handle
		let value2C = value2.__handle
		let amountC = amount.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Lerp(value1C, value2C, amountC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reciprocalEstimate(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ReciprocalEstimate(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func reciprocalSqrtEstimate(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ReciprocalSqrtEstimate(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func scaleB(_ x: System_Half /* System.Half */, _ n: Int32 /* System.Int32 */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_ScaleB(xC, n, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func acosh(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Acosh(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func asinh(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Asinh(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atanh(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Atanh(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cosh(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Cosh(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sinh(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Sinh(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tanh(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Tanh(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Log_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log(_ x: System_Half /* System.Half */, _ newBase: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let newBaseC = newBase.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Log_2(xC, newBaseC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log10(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Log10(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func logP1(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_LogP1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log2P1(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Log2P1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func log10P1(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Log10P1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func clamp(_ value: System_Half /* System.Half */, _ min: System_Half /* System.Half */, _ max: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let valueC = value.__handle
		let minC = min.__handle
		let maxC = max.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Clamp(valueC, minC, maxC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copySign(_ value: System_Half /* System.Half */, _ sign: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let valueC = value.__handle
		let signC = sign.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CopySign(valueC, signC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func max(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Max(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func maxNumber(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MaxNumber(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func min(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Min(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func minNumber(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MinNumber(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sign(_ value: System_Half /* System.Half */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Sign(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Abs(valueC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createChecked(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Half /* System.Half */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CreateChecked_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createSaturating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Half /* System.Half */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CreateSaturating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createTruncating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Half /* System.Half */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CreateTruncating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isEvenInteger(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsEvenInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isInteger(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isOddInteger(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsOddInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isPositive(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsPositive_1(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isRealNumber(_ value: System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_IsRealNumber(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func maxMagnitude(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MaxMagnitude(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func maxMagnitudeNumber(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MaxMagnitudeNumber(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func minMagnitude(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MinMagnitude(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func minMagnitudeNumber(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MinMagnitudeNumber(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TryParse_3(sC, providerC, &resultC, &__exceptionC)
		
		result = System_Half(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func pow(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Pow(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cbrt(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Cbrt(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func hypot(_ x: System_Half /* System.Half */, _ y: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Hypot(xC, yC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func rootN(_ x: System_Half /* System.Half */, _ n: Int32 /* System.Int32 */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_RootN(xC, n, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sqrt(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Sqrt(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func acos(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Acos_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func acosPi(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_AcosPi(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func asin(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Asin_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func asinPi(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_AsinPi(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atan(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Atan_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func atanPi(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_AtanPi(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cos(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Cos_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func cosPi(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_CosPi(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func degreesToRadians(_ degrees: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let degreesC = degrees.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_DegreesToRadians(degreesC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func radiansToDegrees(_ radians: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let radiansC = radians.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_RadiansToDegrees(radiansC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sin(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Sin_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sinPi(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_SinPi(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tan(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Tan_1(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tanPi(_ x: System_Half /* System.Half */) throws -> System_Half /* System.Half */ {
		let xC = x.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TanPi(xC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Half /* System.Half */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Parse_4(utf8TextC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TryParse_4(utf8TextC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_Half(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Half /* System.Half */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Parse_5(utf8TextC, providerC, &__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Half /* System.Half */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_TryParse_5(utf8TextC, providerC, &resultC, &__exceptionC)
		
		result = System_Half(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class var epsilon: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Epsilon_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var positiveInfinity: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_PositiveInfinity_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var negativeInfinity: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_NegativeInfinity_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var naN: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_NaN_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var minValue: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MinValue_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MaxValue_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var e: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_E_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var pi: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Pi_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var tau: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Tau_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var negativeZero: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_NegativeZero_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var multiplicativeIdentity: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_MultiplicativeIdentity_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var one: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_One_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var zero: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Zero_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var negativeOne: System_Half /* System.Half */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_NegativeOne_Get(&__exceptionC)
		
		let __returnValue = System_Half(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Half_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Half_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Half_Destroy(self.__handle)
		
	}
	
	
}



































































public class System_Int128 /* System.Int128 */: System_ValueType {
	public override class var typeName: String { get {
		"Int128"
	}}

	public override class var fullTypeName: String { get {
		"System.Int128"
	}}

	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_Int128 /* System.Int128 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_ToString_1(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_ToString_2(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_Int128 /* System.Int128 */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Parse(sC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */) throws -> System_Int128 /* System.Int128 */ {
		let sC = s.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Parse_1(sC, styleC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Int128 /* System.Int128 */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Parse_2(sC, providerC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Int128 /* System.Int128 */ {
		let sC = s.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Parse_3(sC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_Int128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ result: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TryParse_1(utf8TextC, &resultC, &__exceptionC)
		
		result = System_Int128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TryParse_2(sC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_Int128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func leadingZeroCount(_ value: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_LeadingZeroCount(valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func popCount(_ value: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_PopCount(valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func rotateLeft(_ value: System_Int128 /* System.Int128 */, _ rotateAmount: Int32 /* System.Int32 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_RotateLeft(valueC, rotateAmount, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func rotateRight(_ value: System_Int128 /* System.Int128 */, _ rotateAmount: Int32 /* System.Int32 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_RotateRight(valueC, rotateAmount, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func trailingZeroCount(_ value: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TrailingZeroCount(valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isPow2(_ value: System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_IsPow2(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log2(_ value: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Log2(valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func clamp(_ value: System_Int128 /* System.Int128 */, _ min: System_Int128 /* System.Int128 */, _ max: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		let minC = min.__handle
		let maxC = max.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Clamp(valueC, minC, maxC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func copySign(_ value: System_Int128 /* System.Int128 */, _ sign: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		let signC = sign.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_CopySign(valueC, signC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func max(_ x: System_Int128 /* System.Int128 */, _ y: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Max(xC, yC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func min(_ x: System_Int128 /* System.Int128 */, _ y: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Min(xC, yC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sign(_ value: System_Int128 /* System.Int128 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Sign(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func abs(_ value: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Abs(valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createChecked(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Int128 /* System.Int128 */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_CreateChecked_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createSaturating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Int128 /* System.Int128 */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_CreateSaturating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createTruncating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_Int128 /* System.Int128 */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_CreateTruncating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isEvenInteger(_ value: System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_IsEvenInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isNegative(_ value: System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_IsNegative(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isOddInteger(_ value: System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_IsOddInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isPositive(_ value: System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_IsPositive(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func maxMagnitude(_ x: System_Int128 /* System.Int128 */, _ y: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_MaxMagnitude(xC, yC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func minMagnitude(_ x: System_Int128 /* System.Int128 */, _ y: System_Int128 /* System.Int128 */) throws -> System_Int128 /* System.Int128 */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_MinMagnitude(xC, yC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TryParse_3(sC, providerC, &resultC, &__exceptionC)
		
		result = System_Int128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Int128 /* System.Int128 */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Parse_4(utf8TextC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TryParse_4(utf8TextC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_Int128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_Int128 /* System.Int128 */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Parse_5(utf8TextC, providerC, &__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_Int128 /* System.Int128 */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_TryParse_5(utf8TextC, providerC, &resultC, &__exceptionC)
		
		result = System_Int128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ upper: UInt64 /* System.UInt64 */, _ lower: UInt64 /* System.UInt64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Create_1(upper, lower, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var minValue: System_Int128 /* System.Int128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_MinValue_Get(&__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_Int128 /* System.Int128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_MaxValue_Get(&__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var one: System_Int128 /* System.Int128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_One_Get(&__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var zero: System_Int128 /* System.Int128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Zero_Get(&__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var negativeOne: System_Int128 /* System.Int128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_NegativeOne_Get(&__exceptionC)
		
		let __returnValue = System_Int128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Int128_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Int128_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Int128_Destroy(self.__handle)
		
	}
	
	
}

















































public class System_UInt128 /* System.UInt128 */: System_ValueType {
	public override class var typeName: String { get {
		"UInt128"
	}}

	public override class var fullTypeName: String { get {
		"System.UInt128"
	}}

	public func compareTo(_ value: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_CompareTo(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func compareTo(_ value: System_UInt128 /* System.UInt128 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_CompareTo_1(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_ToString_1(self.__handle, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_ToString_2(self.__handle, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func toString(_ format: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_String /* System.String */ {
		let formatC = format?.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_ToString_3(self.__handle, formatC, providerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */) throws -> System_UInt128 /* System.UInt128 */ {
		let sC = s.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Parse(sC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */) throws -> System_UInt128 /* System.UInt128 */ {
		let sC = s.__handle
		let styleC = style.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Parse_1(sC, styleC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_UInt128 /* System.UInt128 */ {
		let sC = s.__handle
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Parse_2(sC, providerC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func parse(_ s: System_String /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_UInt128 /* System.UInt128 */ {
		let sC = s.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Parse_3(sC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ result: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TryParse(sC, &resultC, &__exceptionC)
		
		result = System_UInt128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ result: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TryParse_1(utf8TextC, &resultC, &__exceptionC)
		
		result = System_UInt128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TryParse_2(sC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_UInt128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func leadingZeroCount(_ value: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_LeadingZeroCount(valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func popCount(_ value: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_PopCount(valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func rotateLeft(_ value: System_UInt128 /* System.UInt128 */, _ rotateAmount: Int32 /* System.Int32 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_RotateLeft(valueC, rotateAmount, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func rotateRight(_ value: System_UInt128 /* System.UInt128 */, _ rotateAmount: Int32 /* System.Int32 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_RotateRight(valueC, rotateAmount, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func trailingZeroCount(_ value: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TrailingZeroCount(valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isPow2(_ value: System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_IsPow2(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func log2(_ value: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Log2(valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func clamp(_ value: System_UInt128 /* System.UInt128 */, _ min: System_UInt128 /* System.UInt128 */, _ max: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let valueC = value.__handle
		let minC = min.__handle
		let maxC = max.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Clamp(valueC, minC, maxC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func max(_ x: System_UInt128 /* System.UInt128 */, _ y: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Max(xC, yC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func min(_ x: System_UInt128 /* System.UInt128 */, _ y: System_UInt128 /* System.UInt128 */) throws -> System_UInt128 /* System.UInt128 */ {
		let xC = x.__handle
		let yC = y.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Min(xC, yC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func sign(_ value: System_UInt128 /* System.UInt128 */) throws -> Int32 /* System.Int32 */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Sign(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func createChecked(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_UInt128 /* System.UInt128 */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_CreateChecked_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createSaturating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_UInt128 /* System.UInt128 */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_CreateSaturating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createTruncating(TOther: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> System_UInt128 /* System.UInt128 */ {
		let TOtherC = TOther.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_CreateTruncating_A1(TOtherC, valueC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isEvenInteger(_ value: System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_IsEvenInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isOddInteger(_ value: System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_IsOddInteger(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryParse(_ s: System_String? /* System.String */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let sC = s?.__handle
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TryParse_3(sC, providerC, &resultC, &__exceptionC)
		
		result = System_UInt128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_UInt128 /* System.UInt128 */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Parse_4(utf8TextC, styleC, providerC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ style: System_Globalization_NumberStyles /* System.Globalization.NumberStyles */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let styleC = style.cValue
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TryParse_4(utf8TextC, styleC, providerC, &resultC, &__exceptionC)
		
		result = System_UInt128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func parse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */) throws -> System_UInt128 /* System.UInt128 */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Parse_5(utf8TextC, providerC, &__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryParse(_ utf8Text: Data? /* System.ReadOnlySpan<System.Byte> */, _ provider: System_IFormatProvider? /* System.IFormatProvider */, _ result: inout System_UInt128 /* System.UInt128 */) throws -> Bool /* System.Boolean */ {
		let utf8TextC = utf8Text.readOnlySpanOfByte()
		let providerC = provider?.__handle
		var resultC = result.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_TryParse_5(utf8TextC, providerC, &resultC, &__exceptionC)
		
		result = System_UInt128(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ upper: UInt64 /* System.UInt64 */, _ lower: UInt64 /* System.UInt64 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Create_1(upper, lower, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public class var minValue: System_UInt128 /* System.UInt128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_MinValue_Get(&__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var maxValue: System_UInt128 /* System.UInt128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_MaxValue_Get(&__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var one: System_UInt128 /* System.UInt128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_One_Get(&__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var zero: System_UInt128 /* System.UInt128 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Zero_Get(&__exceptionC)
		
		let __returnValue = System_UInt128(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UInt128_Create_2(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UInt128_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_UInt128_Destroy(self.__handle)
		
	}
	
	
}

















































// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
// Type "TOther" was skipped. Reason: It has no full name.
public class System_WeakReference_A1 /* System.WeakReference<> */: System_Object {
	public override class var typeName: String { get {
		"WeakReference`1"
	}}

	public override class var fullTypeName: String { get {
		"System.WeakReference<>"
	}}

	public func tryGetTarget(T: System_Type /* System.Type */, _ target: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		var targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_A1_TryGetTarget(self.__handle, TC, &targetC, &__exceptionC)
		
		target = System_Object(handle: targetC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getObjectData(T: System_Type /* System.Type */, _ info: System_Runtime_Serialization_SerializationInfo? /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let TC = T.__handle
		let infoC = info?.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_WeakReference_A1_GetObjectData(self.__handle, TC, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func setTarget(T: System_Type /* System.Type */, _ target: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_WeakReference_A1_SetTarget(self.__handle, TC, targetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(T: System_Type /* System.Type */, _ target: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_A1_Create(TC, targetC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(T: System_Type /* System.Type */, _ target: System_Object? /* System.Object */, _ trackResurrection: Bool /* System.Boolean */) throws {
		let TC = T.__handle
		let targetC = target?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_WeakReference_A1_Create_1(TC, targetC, trackResurrection, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_WeakReference_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_WeakReference_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.

public class System_Runtime_CompilerServices_ConditionalWeakTable_A2 /* System.Runtime.CompilerServices.ConditionalWeakTable<,> */: System_Object {
	public override class var typeName: String { get {
		"ConditionalWeakTable`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ConditionalWeakTable<,>"
	}}

	public func tryGetValue(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConditionalWeakTable_A2_TryGetValue(self.__handle, TKeyC, TValueC, keyC, &valueC, &__exceptionC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func add(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConditionalWeakTable_A2_Add(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func tryAdd(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConditionalWeakTable_A2_TryAdd(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func addOrUpdate(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConditionalWeakTable_A2_AddOrUpdate(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func remove(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConditionalWeakTable_A2_Remove(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func clear(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Runtime_CompilerServices_ConditionalWeakTable_A2_Clear(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getOrCreateValue(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConditionalWeakTable_A2_GetOrCreateValue(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ConditionalWeakTable_A2_Create(TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ConditionalWeakTable_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ConditionalWeakTable_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TKey" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.

public class System_Collections_Generic_List_A1 /* System.Collections.Generic.List<> */: System_Object {
	public override class var typeName: String { get {
		"List`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.List<>"
	}}

	public func add(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Add(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func binarySearch(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_BinarySearch(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func clear(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Clear(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func contains(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Contains(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func copyTo(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_CopyTo(self.__handle, TC, arrayC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyTo(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ array: System_Array? /* System.Array */, _ arrayIndex: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_CopyTo_1(self.__handle, TC, index, arrayC, arrayIndex, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func copyTo(T: System_Type /* System.Type */, _ array: System_Array? /* System.Array */, _ arrayIndex: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		let arrayC = array?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_CopyTo_2(self.__handle, TC, arrayC, arrayIndex, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func ensureCapacity(T: System_Type /* System.Type */, _ capacity: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_EnsureCapacity(self.__handle, TC, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getRange(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> System_Object /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_GetRange(self.__handle, TC, index, count, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func slice(T: System_Type /* System.Type */, _ start: Int32 /* System.Int32 */, _ length: Int32 /* System.Int32 */) throws -> System_Object /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Slice(self.__handle, TC, start, length, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func indexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_IndexOf(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */, _ index: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_IndexOf_1(self.__handle, TC, itemC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func indexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_IndexOf_2(self.__handle, TC, itemC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func insert(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ item: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Insert(self.__handle, TC, index, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func lastIndexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_LastIndexOf(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */, _ index: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_LastIndexOf_1(self.__handle, TC, itemC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func lastIndexOf(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_LastIndexOf_2(self.__handle, TC, itemC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func remove(T: System_Type /* System.Type */, _ item: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let itemC = item?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Remove(self.__handle, TC, itemC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func removeAt(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_RemoveAt(self.__handle, TC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeRange(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_RemoveRange(self.__handle, TC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func reverse(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Reverse(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func reverse(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ count: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Reverse_1(self.__handle, TC, index, count, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func sort(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Sort(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func toArray(T: System_Type /* System.Type */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_ToArray(self.__handle, TC, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func trimExcess(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_TrimExcess(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Create(TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(T: System_Type /* System.Type */, _ capacity: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Create_1(TC, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func capacity(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Capacity_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	public func capacity_set(T: System_Type /* System.Type */, _ value: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Capacity_Set(self.__handle, TC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public func count(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Count_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public func item(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_List_A1_Item_Get(self.__handle, TC, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(T: System_Type /* System.Type */, _ index: Int32 /* System.Int32 */, _ value: System_Object? /* System.Object */) throws {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_List_A1_Item_Set(self.__handle, TC, index, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_List_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_List_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.

public class System_Collections_Generic_Dictionary_A2 /* System.Collections.Generic.Dictionary<,> */: System_Object {
	public override class var typeName: String { get {
		"Dictionary`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.Dictionary<,>"
	}}

	public func add(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_Add(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func clear(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_Clear(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func containsKey(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_ContainsKey(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func containsValue(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_ContainsValue(self.__handle, TKeyC, TValueC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getObjectData(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ info: System_Runtime_Serialization_SerializationInfo? /* System.Runtime.Serialization.SerializationInfo */, _ context: System_Runtime_Serialization_StreamingContext /* System.Runtime.Serialization.StreamingContext */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let infoC = info?.__handle
		let contextC = context.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_GetObjectData(self.__handle, TKeyC, TValueC, infoC, contextC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func onDeserialization(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ sender: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let senderC = sender?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_OnDeserialization(self.__handle, TKeyC, TValueC, senderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func remove(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_Remove(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func remove(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_Remove_1(self.__handle, TKeyC, TValueC, keyC, &valueC, &__exceptionC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func tryGetValue(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_TryGetValue(self.__handle, TKeyC, TValueC, keyC, &valueC, &__exceptionC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func tryAdd(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_TryAdd(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func ensureCapacity(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ capacity: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_EnsureCapacity(self.__handle, TKeyC, TValueC, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func trimExcess(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_TrimExcess(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func trimExcess(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ capacity: Int32 /* System.Int32 */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_TrimExcess_1(self.__handle, TKeyC, TValueC, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_Create(TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ capacity: Int32 /* System.Int32 */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_Create_1(TKeyC, TValueC, capacity, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func count(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_Count_Get(self.__handle, TKeyC, TValueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	
	public func item(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_Dictionary_A2_Item_Get(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_Dictionary_A2_Item_Set(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_Dictionary_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_Dictionary_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TValue" was skipped. Reason: It has no full name.
// Type "TKey" was skipped. Reason: It has no full name.

public class System_Collections_Generic_IDictionary_A2 /* System.Collections.Generic.IDictionary<,> */: DNObject {
	public override class var typeName: String { get {
		"IDictionary`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IDictionary<,>"
	}}

	public func containsKey(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IDictionary_A2_ContainsKey(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func add(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_IDictionary_A2_Add(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func remove(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IDictionary_A2_Remove(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func tryGetValue(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: inout System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		var valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IDictionary_A2_TryGetValue(self.__handle, TKeyC, TValueC, keyC, &valueC, &__exceptionC)
		
		value = System_Object(handle: valueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func item(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IDictionary_A2_Item_Get(self.__handle, TKeyC, TValueC, keyC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		System_Collections_Generic_IDictionary_A2_Item_Set(self.__handle, TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IDictionary_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IDictionary_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "TValue" was skipped. Reason: It has no full name.
// Type "TKey" was skipped. Reason: It has no full name.

public class System_Tuple_A1 /* System.Tuple<> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<>"
	}}

	public func equals(T1: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A1_Equals(self.__handle, T1C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A1_GetHashCode(self.__handle, T1C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A1_ToString(self.__handle, T1C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let item1C = item1?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A1_Create(T1C, item1C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A1_Item1_Get(self.__handle, T1C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A1_Destroy(self.__handle)
		
	}
	
	
}


public class System_Runtime_CompilerServices_ITuple /* System.Runtime.CompilerServices.ITuple */: DNObject {
	public override class var typeName: String { get {
		"ITuple"
	}}

	public override class var fullTypeName: String { get {
		"System.Runtime.CompilerServices.ITuple"
	}}

	public var length: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ITuple_Length_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public func item(_ index: Int32 /* System.Int32 */) throws -> System_Object? /* System.Object */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Runtime_CompilerServices_ITuple_Item_Get(self.__handle, index, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Runtime_CompilerServices_ITuple_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Runtime_CompilerServices_ITuple_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
public class System_Tuple_A2 /* System.Tuple<,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`2"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A2_Equals(self.__handle, T1C, T2C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A2_GetHashCode(self.__handle, T1C, T2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A2_ToString(self.__handle, T1C, T2C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A2_Create(T1C, T2C, item1C, item2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A2_Item1_Get(self.__handle, T1C, T2C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A2_Item2_Get(self.__handle, T1C, T2C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A2_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
public class System_Tuple_A3 /* System.Tuple<,,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`3"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_Equals(self.__handle, T1C, T2C, T3C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_GetHashCode(self.__handle, T1C, T2C, T3C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_ToString(self.__handle, T1C, T2C, T3C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */, _ item3: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		let item3C = item3?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_Create(T1C, T2C, T3C, item1C, item2C, item3C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_Item1_Get(self.__handle, T1C, T2C, T3C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_Item2_Get(self.__handle, T1C, T2C, T3C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item3(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A3_Item3_Get(self.__handle, T1C, T2C, T3C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A3_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A3_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
// Type "T3" was skipped. Reason: It has no full name.
public class System_Tuple_A4 /* System.Tuple<,,,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`4"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,,,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_Equals(self.__handle, T1C, T2C, T3C, T4C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_GetHashCode(self.__handle, T1C, T2C, T3C, T4C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_ToString(self.__handle, T1C, T2C, T3C, T4C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */, _ item3: System_Object? /* System.Object */, _ item4: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		let item3C = item3?.__handle
		let item4C = item4?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_Create(T1C, T2C, T3C, T4C, item1C, item2C, item3C, item4C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_Item1_Get(self.__handle, T1C, T2C, T3C, T4C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_Item2_Get(self.__handle, T1C, T2C, T3C, T4C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item3(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_Item3_Get(self.__handle, T1C, T2C, T3C, T4C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item4(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A4_Item4_Get(self.__handle, T1C, T2C, T3C, T4C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A4_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A4_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
// Type "T3" was skipped. Reason: It has no full name.
// Type "T4" was skipped. Reason: It has no full name.
public class System_Tuple_A5 /* System.Tuple<,,,,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`5"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,,,,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Equals(self.__handle, T1C, T2C, T3C, T4C, T5C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_GetHashCode(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_ToString(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */, _ item3: System_Object? /* System.Object */, _ item4: System_Object? /* System.Object */, _ item5: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		let item3C = item3?.__handle
		let item4C = item4?.__handle
		let item5C = item5?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Create(T1C, T2C, T3C, T4C, T5C, item1C, item2C, item3C, item4C, item5C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Item1_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Item2_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item3(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Item3_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item4(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Item4_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item5(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A5_Item5_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A5_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A5_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
// Type "T3" was skipped. Reason: It has no full name.
// Type "T4" was skipped. Reason: It has no full name.
// Type "T5" was skipped. Reason: It has no full name.
public class System_Tuple_A6 /* System.Tuple<,,,,,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`6"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,,,,,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Equals(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_GetHashCode(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_ToString(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */, _ item3: System_Object? /* System.Object */, _ item4: System_Object? /* System.Object */, _ item5: System_Object? /* System.Object */, _ item6: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		let item3C = item3?.__handle
		let item4C = item4?.__handle
		let item5C = item5?.__handle
		let item6C = item6?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Create(T1C, T2C, T3C, T4C, T5C, T6C, item1C, item2C, item3C, item4C, item5C, item6C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Item1_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Item2_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item3(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Item3_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item4(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Item4_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item5(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Item5_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item6(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A6_Item6_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A6_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A6_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
// Type "T3" was skipped. Reason: It has no full name.
// Type "T4" was skipped. Reason: It has no full name.
// Type "T5" was skipped. Reason: It has no full name.
// Type "T6" was skipped. Reason: It has no full name.
public class System_Tuple_A7 /* System.Tuple<,,,,,,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`7"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,,,,,,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Equals(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_GetHashCode(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_ToString(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */, _ item3: System_Object? /* System.Object */, _ item4: System_Object? /* System.Object */, _ item5: System_Object? /* System.Object */, _ item6: System_Object? /* System.Object */, _ item7: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		let item3C = item3?.__handle
		let item4C = item4?.__handle
		let item5C = item5?.__handle
		let item6C = item6?.__handle
		let item7C = item7?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Create(T1C, T2C, T3C, T4C, T5C, T6C, T7C, item1C, item2C, item3C, item4C, item5C, item6C, item7C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item1_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item2_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item3(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item3_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item4(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item4_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item5(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item5_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item6(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item6_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item7(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A7_Item7_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A7_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A7_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
// Type "T3" was skipped. Reason: It has no full name.
// Type "T4" was skipped. Reason: It has no full name.
// Type "T5" was skipped. Reason: It has no full name.
// Type "T6" was skipped. Reason: It has no full name.
// Type "T7" was skipped. Reason: It has no full name.
public class System_Tuple_A8 /* System.Tuple<,,,,,,,> */: System_Object {
	public override class var typeName: String { get {
		"Tuple`8"
	}}

	public override class var fullTypeName: String { get {
		"System.Tuple<,,,,,,,>"
	}}

	public func equals(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Equals(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_GetHashCode(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func toString(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_String /* System.String */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_ToString(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */, _ item1: System_Object? /* System.Object */, _ item2: System_Object? /* System.Object */, _ item3: System_Object? /* System.Object */, _ item4: System_Object? /* System.Object */, _ item5: System_Object? /* System.Object */, _ item6: System_Object? /* System.Object */, _ item7: System_Object? /* System.Object */, _ rest: System_Object? /* System.Object */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		let item1C = item1?.__handle
		let item2C = item2?.__handle
		let item3C = item3?.__handle
		let item4C = item4?.__handle
		let item5C = item5?.__handle
		let item6C = item6?.__handle
		let item7C = item7?.__handle
		let restC = rest?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Create(T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, item1C, item2C, item3C, item4C, item5C, item6C, item7C, restC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func item1(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item1_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item2(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item2_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item3(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item3_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item4(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item4_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item5(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item5_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item6(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item6_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func item7(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Item7_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public func rest(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, T3: System_Type /* System.Type */, T4: System_Type /* System.Type */, T5: System_Type /* System.Type */, T6: System_Type /* System.Type */, T7: System_Type /* System.Type */, TRest: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let T3C = T3.__handle
		let T4C = T4.__handle
		let T5C = T5.__handle
		let T6C = T6.__handle
		let T7C = T7.__handle
		let TRestC = TRest.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Tuple_A8_Rest_Get(self.__handle, T1C, T2C, T3C, T4C, T5C, T6C, T7C, TRestC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Tuple_A8_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Tuple_A8_Destroy(self.__handle)
		
	}
	
	
}


// Type "T1" was skipped. Reason: It has no full name.
// Type "T2" was skipped. Reason: It has no full name.
// Type "T3" was skipped. Reason: It has no full name.
// Type "T4" was skipped. Reason: It has no full name.
// Type "T5" was skipped. Reason: It has no full name.
// Type "T6" was skipped. Reason: It has no full name.
// Type "T7" was skipped. Reason: It has no full name.
// Type "TRest" was skipped. Reason: It has no full name.
public class Beyond_NET_Sample_Address /* Beyond.NET.Sample.Address */: System_Object {
	public override class var typeName: String { get {
		"Address"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Address"
	}}

	public func move(_ mover: Beyond_NET_Sample_MoveDelegate /* Beyond.NET.Sample.MoveDelegate */, _ newStreet: System_String /* System.String */, _ newCity: System_String /* System.String */) throws -> Beyond_NET_Sample_Address /* Beyond.NET.Sample.Address */ {
		let moverC = mover.__handle
		let newStreetC = newStreet.__handle
		let newCityC = newCity.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Address_Move(self.__handle, moverC, newStreetC, newCityC, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_Address(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ street: System_String /* System.String */, _ city: System_String /* System.String */) throws {
		let streetC = street.__handle
		let cityC = city.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Address_Create(streetC, cityC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var street: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Address_Street_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var city: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Address_City_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Address_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Address_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_IAnimal /* Beyond.NET.Sample.IAnimal */: DNObject {
	public override class var typeName: String { get {
		"IAnimal"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.IAnimal"
	}}

	public func eat(_ food: System_String /* System.String */) throws -> System_String /* System.String */ {
		let foodC = food.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IAnimal_Eat(self.__handle, foodC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IAnimal_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_IAnimal_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_IAnimal_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_AnimalFactory /* Beyond.NET.Sample.AnimalFactory */: System_Object {
	public override class var typeName: String { get {
		"AnimalFactory"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.AnimalFactory"
	}}

	public class func createAnimal(_ animalName: System_String /* System.String */) throws -> Beyond_NET_Sample_IAnimal? /* Beyond.NET.Sample.IAnimal */ {
		let animalNameC = animalName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_AnimalFactory_CreateAnimal(animalNameC, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_IAnimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createAnimal(_ animalName: System_String /* System.String */, _ creator: Beyond_NET_Sample_AnimalCreatorDelegate /* Beyond.NET.Sample.AnimalCreatorDelegate */) throws -> Beyond_NET_Sample_IAnimal? /* Beyond.NET.Sample.IAnimal */ {
		let animalNameC = animalName.__handle
		let creatorC = creator.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_AnimalFactory_CreateAnimal_1(animalNameC, creatorC, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_IAnimal(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func createAnimal(T: System_Type /* System.Type */) throws -> System_Object /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_AnimalFactory_CreateAnimal_A1(TC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class var dEFAULT_CREATOR: Beyond_NET_Sample_AnimalCreatorDelegate /* Beyond.NET.Sample.AnimalCreatorDelegate */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_AnimalFactory_DEFAULT_CREATOR_Get()
		
		let __returnValue = Beyond_NET_Sample_AnimalCreatorDelegate(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_AnimalFactory_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_AnimalFactory_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.
public class Beyond_NET_Sample_BaseAnimal /* Beyond.NET.Sample.BaseAnimal */: System_Object {
	public override class var typeName: String { get {
		"BaseAnimal"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.BaseAnimal"
	}}

	public func eat(_ food: System_String /* System.String */) throws -> System_String /* System.String */ {
		let foodC = food.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_BaseAnimal_Eat(self.__handle, foodC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_BaseAnimal_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_BaseAnimal_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_BaseAnimal_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_Cat /* Beyond.NET.Sample.Cat */: Beyond_NET_Sample_BaseAnimal {
	public override class var typeName: String { get {
		"Cat"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Cat"
	}}

	public override var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Cat_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var catName: System_String /* System.String */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Cat_CatName_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Cat_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Cat_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_Dog /* Beyond.NET.Sample.Dog */: Beyond_NET_Sample_BaseAnimal {
	public override class var typeName: String { get {
		"Dog"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Dog"
	}}

	public override var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Dog_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var dogName: System_String /* System.String */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Dog_DogName_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Dog_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Dog_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_GenericAnimal /* Beyond.NET.Sample.GenericAnimal */: Beyond_NET_Sample_BaseAnimal {
	public override class var typeName: String { get {
		"GenericAnimal"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.GenericAnimal"
	}}

	public convenience init(_ name: System_String /* System.String */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericAnimal_Create(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericAnimal_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_GenericAnimal_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_GenericAnimal_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_Labrador /* Beyond.NET.Sample.Labrador */: Beyond_NET_Sample_Dog {
	public override class var typeName: String { get {
		"Labrador"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Labrador"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Labrador_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Labrador_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var labradorName: System_String /* System.String */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Labrador_LabradorName_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Labrador_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Labrador_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_AsyncTests /* Beyond.NET.Sample.AsyncTests */: System_Object {
	public override class var typeName: String { get {
		"AsyncTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.AsyncTests"
	}}

	public func addAsync(_ number1: Int32 /* System.Int32 */, _ number2: Int32 /* System.Int32 */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_AsyncTests_AddAsync(self.__handle, number1, number2, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func transformNumbersAsync(_ number1: Int32 /* System.Int32 */, _ number2: Int32 /* System.Int32 */, _ transformerDelegate: Beyond_NET_Sample_AsyncTests_TransformerDelegate /* Beyond.NET.Sample.AsyncTests.TransformerDelegate */) throws -> System_Threading_Tasks_Task_A1 /* System.Threading.Tasks.Task<System.Int32> */ {
		let transformerDelegateC = transformerDelegate.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_AsyncTests_TransformNumbersAsync(self.__handle, number1, number2, transformerDelegateC, &__exceptionC)
		
		let __returnValue = System_Threading_Tasks_Task_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_AsyncTests_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_AsyncTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_AsyncTests_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_Point /* Beyond.NET.Sample.Point */: System_ValueType {
	public override class var typeName: String { get {
		"Point"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Point"
	}}

	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Point_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ x: Double /* System.Double */, _ y: Double /* System.Double */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Point_Create(x, y, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var x: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Point_X_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var y: Double /* System.Double */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Point_Y_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Point_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Point_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Point_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_DelegatesTest /* Beyond.NET.Sample.DelegatesTest */: System_Object {
	public override class var typeName: String { get {
		"DelegatesTest"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.DelegatesTest"
	}}

	public class func transformInt(_ i: Int32 /* System.Int32 */, _ intTransformer: Beyond_NET_Sample_DelegatesTest_TransformIntDelegate /* Beyond.NET.Sample.DelegatesTest.TransformIntDelegate */) throws -> Int32 /* System.Int32 */ {
		let intTransformerC = intTransformer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_DelegatesTest_TransformInt(i, intTransformerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func transformPoint(_ point: Beyond_NET_Sample_Point /* Beyond.NET.Sample.Point */, _ pointTransformer: Beyond_NET_Sample_DelegatesTest_PointTransformDelegate /* Beyond.NET.Sample.DelegatesTest.PointTransformDelegate */) throws -> Beyond_NET_Sample_Point /* Beyond.NET.Sample.Point */ {
		let pointC = point.__handle
		let pointTransformerC = pointTransformer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_DelegatesTest_TransformPoint(pointC, pointTransformerC, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_Point(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_DelegatesTest_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_DelegatesTest_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_EventTests /* Beyond.NET.Sample.EventTests */: System_Object {
	public override class var typeName: String { get {
		"EventTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.EventTests"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_EventTests_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var value: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_EventTests_Value_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func value_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_EventTests_Value_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public func valueChanged_add(_ value: Beyond_NET_Sample_EventTests_ValueChangedDelegate? /* Beyond.NET.Sample.EventTests.ValueChangedDelegate */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_EventTests_ValueChanged_Add(self.__handle, valueC)
		
		
	}
	public func valueChanged_remove(_ value: Beyond_NET_Sample_EventTests_ValueChangedDelegate? /* Beyond.NET.Sample.EventTests.ValueChangedDelegate */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_EventTests_ValueChanged_Remove(self.__handle, valueC)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_EventTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_EventTests_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_GenericTestClass_A1 /* Beyond.NET.Sample.GenericTestClass<> */: System_Object {
	public override class var typeName: String { get {
		"GenericTestClass`1"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.GenericTestClass<>"
	}}

	public func returnGenericClassType(T: System_Type /* System.Type */) throws -> System_Type /* System.Type */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A1_ReturnGenericClassType(self.__handle, TC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnGenericClassTypeAndGenericMethodType(T: System_Type /* System.Type */, TM: System_Type /* System.Type */) throws -> System_Type_Array /* System.Type[] */ {
		let TC = T.__handle
		let TMC = TM.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A1_ReturnGenericClassTypeAndGenericMethodType_A1(TC, TMC, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func extreme(T: System_Type /* System.Type */, TM: System_Type /* System.Type */, _ countIn: Int32 /* System.Int32 */, _ countOut: inout Int32 /* System.Int32 */, _ typeGenericInput: System_Object? /* System.Object */, _ typeGenericOutput: inout System_Object? /* System.Object */, _ methodGenericInputThatIsToBeReplacedWithDefault: inout System_Object? /* System.Object */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		let TMC = TM.__handle
		let typeGenericInputC = typeGenericInput?.__handle
		var typeGenericOutputC = typeGenericOutput?.__handle
		var methodGenericInputThatIsToBeReplacedWithDefaultC = methodGenericInputThatIsToBeReplacedWithDefault?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A1_Extreme_A1(self.__handle, TC, TMC, countIn, &countOut, typeGenericInputC, &typeGenericOutputC, &methodGenericInputThatIsToBeReplacedWithDefaultC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		typeGenericOutput = System_Object(handle: typeGenericOutputC)
		
		methodGenericInputThatIsToBeReplacedWithDefault = System_Object(handle: methodGenericInputThatIsToBeReplacedWithDefaultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T: System_Type /* System.Type */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A1_Create(TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func aProperty(T: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A1_AProperty_Get(self.__handle, TC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	public func aProperty_set(T: System_Type /* System.Type */, _ value: Int32 /* System.Int32 */) throws {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_GenericTestClass_A1_AProperty_Set(self.__handle, TC, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public func aField(T: System_Type /* System.Type */) -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A1_AField_Get(self.__handle, TC)
		
		return __returnValueC
		
	}
	public func aField_set(T: System_Type /* System.Type */, _ value: Int32 /* System.Int32 */) {
		let TC = T.__handle
		
		
		Beyond_NET_Sample_GenericTestClass_A1_AField_Set(self.__handle, TC, value)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_GenericTestClass_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_GenericTestClass_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.

// Type "TM" was skipped. Reason: It has no full name.

public class Beyond_NET_Sample_GenericTestClass_A2 /* Beyond.NET.Sample.GenericTestClass<,> */: System_Object {
	public override class var typeName: String { get {
		"GenericTestClass`2"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.GenericTestClass<,>"
	}}

	public func returnGenericClassTypes(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> System_Type_Array /* System.Type[] */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A2_ReturnGenericClassTypes(self.__handle, T1C, T2C, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnGenericClassTypeAndGenericMethodType(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, TM: System_Type /* System.Type */) throws -> System_Type_Array /* System.Type[] */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		let TMC = TM.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A2_ReturnGenericClassTypeAndGenericMethodType_A1(T1C, T2C, TMC, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A2_Create(T1C, T2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public func aProperty(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A2_AProperty_Get(self.__handle, T1C, T2C, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	public func aProperty_set(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, _ value: Int32 /* System.Int32 */) throws {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_GenericTestClass_A2_AProperty_Set(self.__handle, T1C, T2C, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public func aField(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) -> Int32 /* System.Int32 */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		let __returnValueC = Beyond_NET_Sample_GenericTestClass_A2_AField_Get(self.__handle, T1C, T2C)
		
		return __returnValueC
		
	}
	public func aField_set(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */, _ value: Int32 /* System.Int32 */) {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		Beyond_NET_Sample_GenericTestClass_A2_AField_Set(self.__handle, T1C, T2C, value)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_GenericTestClass_A2_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_GenericTestClass_A2_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_GenericTests /* Beyond.NET.Sample.GenericTests */: System_Object {
	public override class var typeName: String { get {
		"GenericTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.GenericTests"
	}}

	public func joinListOfStrings(_ listOfString: System_Collections_Generic_List_A1 /* System.Collections.Generic.List<System.String> */, _ separator: System_String /* System.String */) throws -> System_String /* System.String */ {
		let listOfStringC = listOfString.__handle
		let separatorC = separator.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_JoinListOfStrings(self.__handle, listOfStringC, separatorC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnGenericType(T: System_Type /* System.Type */) throws -> System_Type /* System.Type */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnGenericType_A1(TC, &__exceptionC)
		
		let __returnValue = System_Type(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnGenericTypeAsOutParameter(T: System_Type /* System.Type */, _ typeOfT: inout System_Type? /* System.Type */) throws {
		let TC = T.__handle
		var typeOfTC = typeOfT?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_GenericTests_ReturnGenericTypeAsOutParameter_A1(TC, &typeOfTC, &__exceptionC)
		
		typeOfT = System_Type(handle: typeOfTC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func returnGenericTypeAsRefParameter(T: System_Type /* System.Type */, _ typeOfT: inout System_Type? /* System.Type */) throws {
		let TC = T.__handle
		var typeOfTC = typeOfT?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_GenericTests_ReturnGenericTypeAsRefParameter_A1(TC, &typeOfTC, &__exceptionC)
		
		typeOfT = System_Type(handle: typeOfTC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func returnGenericTypes(T1: System_Type /* System.Type */, T2: System_Type /* System.Type */) throws -> System_Type_Array /* System.Type[] */ {
		let T1C = T1.__handle
		let T2C = T2.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnGenericTypes_A2(T1C, T2C, &__exceptionC)
		
		let __returnValue = System_Type_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnSimpleKeyValuePair(TKey: System_Type /* System.Type */, TValue: System_Type /* System.Type */, _ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws -> Beyond_NET_Sample_GenericTests_SimpleKeyValuePair /* Beyond.NET.Sample.GenericTests.SimpleKeyValuePair */ {
		let TKeyC = TKey.__handle
		let TValueC = TValue.__handle
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnSimpleKeyValuePair_A2(TKeyC, TValueC, keyC, valueC, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_GenericTests_SimpleKeyValuePair(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnDefaultValueOfGenericType(T: System_Type /* System.Type */) throws -> System_Object? /* System.Object */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnDefaultValueOfGenericType_A1(TC, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnArrayOfDefaultValuesOfGenericType(T: System_Type /* System.Type */, _ numberOfElements: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnArrayOfDefaultValuesOfGenericType_A1(TC, numberOfElements, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func returnArrayOfRepeatedValues(T: System_Type /* System.Type */, _ value: System_Object? /* System.Object */, _ numberOfElements: Int32 /* System.Int32 */) throws -> System_Array /* System.Array */ {
		let TC = T.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnArrayOfRepeatedValues_A1(self.__handle, TC, valueC, numberOfElements, &__exceptionC)
		
		let __returnValue = System_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func returnStringOfJoinedArray(T: System_Type /* System.Type */, _ values: System_Array? /* System.Array */, _ separator: System_String? /* System.String */) throws -> System_String /* System.String */ {
		let TC = T.__handle
		let valuesC = values?.__handle
		let separatorC = separator?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ReturnStringOfJoinedArray_A1(TC, valuesC, separatorC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var listOfStrings: System_Collections_Generic_List_A1 /* System.Collections.Generic.List<System.String> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_ListOfStrings_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_List_A1(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func listOfStrings_set(_ value: System_Collections_Generic_List_A1? /* System.Collections.Generic.List<System.String> */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_GenericTests_ListOfStrings_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var dictionaryOfStringKeysAndExceptionValues: System_Collections_Generic_Dictionary_A2 /* System.Collections.Generic.Dictionary<System.String,System.Exception> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_DictionaryOfStringKeysAndExceptionValues_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Collections_Generic_Dictionary_A2(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func dictionaryOfStringKeysAndExceptionValues_set(_ value: System_Collections_Generic_Dictionary_A2? /* System.Collections.Generic.Dictionary<System.String,System.Exception> */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_GenericTests_DictionaryOfStringKeysAndExceptionValues_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_GenericTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_GenericTests_Destroy(self.__handle)
		
	}
	
	
}






public class System_Collections_Generic_IComparer_A1 /* System.Collections.Generic.IComparer<> */: DNObject {
	public override class var typeName: String { get {
		"IComparer`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IComparer<>"
	}}

	public func compare(T: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IComparer_A1_Compare(self.__handle, TC, xC, yC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IComparer_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IComparer_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


















public class System_Collections_Generic_IEqualityComparer_A1 /* System.Collections.Generic.IEqualityComparer<> */: DNObject {
	public override class var typeName: String { get {
		"IEqualityComparer`1"
	}}

	public override class var fullTypeName: String { get {
		"System.Collections.Generic.IEqualityComparer<>"
	}}

	public func equals(T: System_Type /* System.Type */, _ x: System_Object? /* System.Object */, _ y: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let TC = T.__handle
		let xC = x?.__handle
		let yC = y?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IEqualityComparer_A1_Equals(self.__handle, TC, xC, yC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getHashCode(T: System_Type /* System.Type */, _ obj: System_Object? /* System.Object */) throws -> Int32 /* System.Int32 */ {
		let TC = T.__handle
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Collections_Generic_IEqualityComparer_A1_GetHashCode(self.__handle, TC, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Collections_Generic_IEqualityComparer_A1_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Collections_Generic_IEqualityComparer_A1_Destroy(self.__handle)
		
	}
	
	
}


// Type "T" was skipped. Reason: It has no full name.


public class Beyond_NET_Sample_GenericTests_SimpleKeyValuePair /* Beyond.NET.Sample.GenericTests.SimpleKeyValuePair */: System_ValueType {
	public override class var typeName: String { get {
		"SimpleKeyValuePair"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.GenericTests.SimpleKeyValuePair"
	}}

	public convenience init(_ key: System_Object? /* System.Object */, _ value: System_Object? /* System.Object */) throws {
		let keyC = key?.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_SimpleKeyValuePair_Create(keyC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var key: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_SimpleKeyValuePair_Key_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var value: System_Object? /* System.Object */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_SimpleKeyValuePair_Value_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_GenericTests_SimpleKeyValuePair_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_GenericTests_SimpleKeyValuePair_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_GenericTests_SimpleKeyValuePair_Destroy(self.__handle)
		
	}
	
	
}


// Type "TKey" was skipped. Reason: It has no full name.
// Type "TValue" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

// Type "T[]" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.

public class Beyond_NET_Sample_IndexerTests /* Beyond.NET.Sample.IndexerTests */: System_Object {
	public override class var typeName: String { get {
		"IndexerTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.IndexerTests"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IndexerTests_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var storedString: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IndexerTests_StoredString_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var storedNumber: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IndexerTests_StoredNumber_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var storedGuid: System_Guid /* System.Guid */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IndexerTests_StoredGuid_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Guid(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var storedValue: System_Object_Array /* System.Object[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IndexerTests_StoredValue_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public func item(_ aString: System_String /* System.String */, _ aNumber: Int32 /* System.Int32 */, _ aGuid: System_Guid /* System.Guid */) throws -> System_Object_Array /* System.Object[] */ {
		let aStringC = aString.__handle
		let aGuidC = aGuid.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_IndexerTests_Item_Get(self.__handle, aStringC, aNumber, aGuidC, &__exceptionC)
		
		let __returnValue = System_Object_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	public func item_set(_ aString: System_String /* System.String */, _ aNumber: Int32 /* System.Int32 */, _ aGuid: System_Guid /* System.Guid */, _ value: System_Object_Array? /* System.Object[] */) throws {
		let aStringC = aString.__handle
		let aGuidC = aGuid.__handle
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_IndexerTests_Item_Set(self.__handle, aStringC, aNumber, aGuidC, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_IndexerTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_IndexerTests_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_NullabilityTests /* Beyond.NET.Sample.NullabilityTests */: System_Object {
	public override class var typeName: String { get {
		"NullabilityTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.NullabilityTests"
	}}

	public func methodWithNonNullableStringReturnValue() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_MethodWithNonNullableStringReturnValue(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func methodWithNullableStringReturnValue() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_MethodWithNullableStringReturnValue(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func methodWithNonNullableStringParameter(_ value: System_String /* System.String */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_MethodWithNonNullableStringParameter(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func methodWithNonNullableStringParameterThatThrows(_ value: System_String /* System.String */) throws -> System_String /* System.String */ {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_MethodWithNonNullableStringParameterThatThrows(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func methodWithNullableStringParameter(_ value: System_String? /* System.String */) throws -> System_String? /* System.String */ {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_MethodWithNullableStringParameter(self.__handle, valueC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ throwAnException: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_Create_1(throwAnException, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var nonNullableStringProperty: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_NonNullableStringProperty_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func nonNullableStringProperty_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_NullabilityTests_NonNullableStringProperty_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var nullableStringProperty: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_NullableStringProperty_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func nullableStringProperty_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_NullabilityTests_NullableStringProperty_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var nonNullableStringField: System_String /* System.String */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_NonNullableStringField_Get(self.__handle)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func nonNullableStringField_set(_ value: System_String? /* System.String */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_NullabilityTests_NonNullableStringField_Set(self.__handle, valueC)
		
		
	}
	
	
	public var nullableStringField: System_String? /* System.String */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_NullabilityTests_NullableStringField_Get(self.__handle)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func nullableStringField_set(_ value: System_String? /* System.String */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_NullabilityTests_NullableStringField_Set(self.__handle, valueC)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_NullabilityTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_NullabilityTests_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_OverloadTests /* Beyond.NET.Sample.OverloadTests */: System_Object {
	public override class var typeName: String { get {
		"OverloadTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.OverloadTests"
	}}

	public class func print(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_OverloadTests_Print(value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func print(_ value: System_DateTime /* System.DateTime */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_OverloadTests_Print_1(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func print(_ value: System_String /* System.String */) throws {
		let valueC = value.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_OverloadTests_Print_2(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_OverloadTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_OverloadTests_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_Person /* Beyond.NET.Sample.Person */: System_Object {
	public override class var typeName: String { get {
		"Person"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Person"
	}}

	public func getNiceLevelString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_GetNiceLevelString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getWelcomeMessage() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_GetWelcomeMessage(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func addChild(_ child: Beyond_NET_Sample_Person /* Beyond.NET.Sample.Person */) throws {
		let childC = child.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_AddChild(self.__handle, childC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeChild(_ child: Beyond_NET_Sample_Person /* Beyond.NET.Sample.Person */) throws {
		let childC = child.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_RemoveChild(self.__handle, childC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func removeChildAt(_ index: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_RemoveChildAt(self.__handle, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func childAt(_ index: Int32 /* System.Int32 */) throws -> Beyond_NET_Sample_Person /* Beyond.NET.Sample.Person */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_ChildAt(self.__handle, index, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_Person(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func changeAge(_ newAgeProvider: Beyond_NET_Sample_Person_NewAgeProviderDelegate? /* Beyond.NET.Sample.Person.NewAgeProviderDelegate */) throws {
		let newAgeProviderC = newAgeProvider?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_ChangeAge(self.__handle, newAgeProviderC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ firstName: System_String /* System.String */, _ lastName: System_String /* System.String */, _ age: Int32 /* System.Int32 */) throws {
		let firstNameC = firstName.__handle
		let lastNameC = lastName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Create(firstNameC, lastNameC, age, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ firstName: System_String /* System.String */, _ lastName: System_String /* System.String */) throws {
		let firstNameC = firstName.__handle
		let lastNameC = lastName.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Create_1(firstNameC, lastNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var firstName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_FirstName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func firstName_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_FirstName_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var lastName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_LastName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func lastName_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_LastName_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var age: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Age_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func age_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_Age_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var address: Beyond_NET_Sample_Address? /* Beyond.NET.Sample.Address */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Address_Get(self.__handle, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_Address(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func address_set(_ value: Beyond_NET_Sample_Address? /* Beyond.NET.Sample.Address */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_Address_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var website: System_Uri? /* System.Uri */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Website_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Uri(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func website_set(_ value: System_Uri? /* System.Uri */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_Website_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var children: Beyond_NET_Sample_Person_Array /* Beyond.NET.Sample.Person[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Children_Get(self.__handle, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_Person_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func children_set(_ value: Beyond_NET_Sample_Person_Array? /* Beyond.NET.Sample.Person[] */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_Children_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var niceLevel: Beyond_NET_Sample_NiceLevels /* Beyond.NET.Sample.NiceLevels */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_NiceLevel_Get(self.__handle, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_NiceLevels(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func niceLevel_set(_ value: Beyond_NET_Sample_NiceLevels /* Beyond.NET.Sample.NiceLevels */) throws {
		let valueC = value.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_NiceLevel_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var fullName: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_FullName_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var numberOfChildren: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_NumberOfChildren_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public func numberOfChildrenChanged_add(_ value: Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate? /* Beyond.NET.Sample.Person.NumberOfChildrenChangedDelegate */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_Person_NumberOfChildrenChanged_Add(self.__handle, valueC)
		
		
	}
	public func numberOfChildrenChanged_remove(_ value: Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate? /* Beyond.NET.Sample.Person.NumberOfChildrenChangedDelegate */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_Person_NumberOfChildrenChanged_Remove(self.__handle, valueC)
		
		
	}
	
	
	public class var aGE_WHEN_BORN: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Person_AGE_WHEN_BORN_Get()
		
		return __returnValueC
		
	}}
	
	
	public class var dEFAULT_AGE: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Person_DEFAULT_AGE_Get()
		
		return __returnValueC
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Person_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Person_Destroy(self.__handle)
		
	}
	
	
}


public class System_Uri /* System.Uri */: System_Object {
	public override class var typeName: String { get {
		"Uri"
	}}

	public override class var fullTypeName: String { get {
		"System.Uri"
	}}

	public class func checkHostName(_ name: System_String? /* System.String */) throws -> System_UriHostNameType /* System.UriHostNameType */ {
		let nameC = name?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_CheckHostName(nameC, &__exceptionC)
		
		let __returnValue = System_UriHostNameType(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getLeftPart(_ part: System_UriPartial /* System.UriPartial */) throws -> System_String /* System.String */ {
		let partC = part.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_GetLeftPart(self.__handle, partC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func hexEscape(_ character: DNChar /* System.Char */) throws -> System_String /* System.String */ {
		let characterC = character.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_HexEscape(characterC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func hexUnescape(_ pattern: System_String /* System.String */, _ index: inout Int32 /* System.Int32 */) throws -> DNChar /* System.Char */ {
		let patternC = pattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_HexUnescape(patternC, &index, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func isHexEncoding(_ pattern: System_String /* System.String */, _ index: Int32 /* System.Int32 */) throws -> Bool /* System.Boolean */ {
		let patternC = pattern.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsHexEncoding(patternC, index, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func checkSchemeName(_ schemeName: System_String? /* System.String */) throws -> Bool /* System.Boolean */ {
		let schemeNameC = schemeName?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_CheckSchemeName(schemeNameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isHexDigit(_ character: DNChar /* System.Char */) throws -> Bool /* System.Boolean */ {
		let characterC = character.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsHexDigit(characterC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func fromHex(_ digit: DNChar /* System.Char */) throws -> Int32 /* System.Int32 */ {
		let digitC = digit.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_FromHex(digitC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func equals(_ comparand: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let comparandC = comparand?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Equals(self.__handle, comparandC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func makeRelativeUri(_ uri: System_Uri /* System.Uri */) throws -> System_Uri /* System.Uri */ {
		let uriC = uri.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_MakeRelativeUri(self.__handle, uriC, &__exceptionC)
		
		let __returnValue = System_Uri(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func makeRelative(_ toUri: System_Uri /* System.Uri */) throws -> System_String /* System.String */ {
		let toUriC = toUri.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_MakeRelative_1(self.__handle, toUriC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func tryCreate(_ uriString: System_String? /* System.String */, _ uriKind: System_UriKind /* System.UriKind */, _ result: inout System_Uri? /* System.Uri */) throws -> Bool /* System.Boolean */ {
		let uriStringC = uriString?.__handle
		let uriKindC = uriKind.cValue
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_TryCreate(uriStringC, uriKindC, &resultC, &__exceptionC)
		
		result = System_Uri(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryCreate(_ uriString: System_String? /* System.String */, _ creationOptions: inout System_UriCreationOptions /* System.UriCreationOptions */, _ result: inout System_Uri? /* System.Uri */) throws -> Bool /* System.Boolean */ {
		let uriStringC = uriString?.__handle
		var creationOptionsC = creationOptions.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_TryCreate_1(uriStringC, &creationOptionsC, &resultC, &__exceptionC)
		
		creationOptions = System_UriCreationOptions(handle: creationOptionsC)
		
		result = System_Uri(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryCreate(_ baseUri: System_Uri? /* System.Uri */, _ relativeUri: System_String? /* System.String */, _ result: inout System_Uri? /* System.Uri */) throws -> Bool /* System.Boolean */ {
		let baseUriC = baseUri?.__handle
		let relativeUriC = relativeUri?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_TryCreate_2(baseUriC, relativeUriC, &resultC, &__exceptionC)
		
		result = System_Uri(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func tryCreate(_ baseUri: System_Uri? /* System.Uri */, _ relativeUri: System_Uri? /* System.Uri */, _ result: inout System_Uri? /* System.Uri */) throws -> Bool /* System.Boolean */ {
		let baseUriC = baseUri?.__handle
		let relativeUriC = relativeUri?.__handle
		var resultC = result?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_TryCreate_3(baseUriC, relativeUriC, &resultC, &__exceptionC)
		
		result = System_Uri(handle: resultC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func getComponents(_ components: System_UriComponents /* System.UriComponents */, _ format: System_UriFormat /* System.UriFormat */) throws -> System_String /* System.String */ {
		let componentsC = components.cValue
		let formatC = format.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_GetComponents(self.__handle, componentsC, formatC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func compare(_ uri1: System_Uri? /* System.Uri */, _ uri2: System_Uri? /* System.Uri */, _ partsToCompare: System_UriComponents /* System.UriComponents */, _ compareFormat: System_UriFormat /* System.UriFormat */, _ comparisonType: System_StringComparison /* System.StringComparison */) throws -> Int32 /* System.Int32 */ {
		let uri1C = uri1?.__handle
		let uri2C = uri2?.__handle
		let partsToCompareC = partsToCompare.cValue
		let compareFormatC = compareFormat.cValue
		let comparisonTypeC = comparisonType.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Compare(uri1C, uri2C, partsToCompareC, compareFormatC, comparisonTypeC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func isWellFormedOriginalString() throws -> Bool /* System.Boolean */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsWellFormedOriginalString(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func isWellFormedUriString(_ uriString: System_String? /* System.String */, _ uriKind: System_UriKind /* System.UriKind */) throws -> Bool /* System.Boolean */ {
		let uriStringC = uriString?.__handle
		let uriKindC = uriKind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsWellFormedUriString(uriStringC, uriKindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func unescapeDataString(_ stringToUnescape: System_String /* System.String */) throws -> System_String /* System.String */ {
		let stringToUnescapeC = stringToUnescape.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_UnescapeDataString(stringToUnescapeC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func escapeUriString(_ stringToEscape: System_String /* System.String */) throws -> System_String /* System.String */ {
		let stringToEscapeC = stringToEscape.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_EscapeUriString(stringToEscapeC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func escapeDataString(_ stringToEscape: System_String /* System.String */) throws -> System_String /* System.String */ {
		let stringToEscapeC = stringToEscape.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_EscapeDataString(stringToEscapeC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func isBaseOf(_ uri: System_Uri /* System.Uri */) throws -> Bool /* System.Boolean */ {
		let uriC = uri.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsBaseOf(self.__handle, uriC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public convenience init(_ uriString: System_String /* System.String */) throws {
		let uriStringC = uriString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create(uriStringC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ uriString: System_String /* System.String */, _ dontEscape: Bool /* System.Boolean */) throws {
		let uriStringC = uriString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create_1(uriStringC, dontEscape, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ baseUri: System_Uri /* System.Uri */, _ relativeUri: System_String? /* System.String */, _ dontEscape: Bool /* System.Boolean */) throws {
		let baseUriC = baseUri.__handle
		let relativeUriC = relativeUri?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create_2(baseUriC, relativeUriC, dontEscape, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ uriString: System_String /* System.String */, _ uriKind: System_UriKind /* System.UriKind */) throws {
		let uriStringC = uriString.__handle
		let uriKindC = uriKind.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create_3(uriStringC, uriKindC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ uriString: System_String /* System.String */, _ creationOptions: inout System_UriCreationOptions /* System.UriCreationOptions */) throws {
		let uriStringC = uriString.__handle
		var creationOptionsC = creationOptions.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create_4(uriStringC, &creationOptionsC, &__exceptionC)
		
		creationOptions = System_UriCreationOptions(handle: creationOptionsC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ baseUri: System_Uri /* System.Uri */, _ relativeUri: System_String? /* System.String */) throws {
		let baseUriC = baseUri.__handle
		let relativeUriC = relativeUri?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create_5(baseUriC, relativeUriC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ baseUri: System_Uri /* System.Uri */, _ relativeUri: System_Uri /* System.Uri */) throws {
		let baseUriC = baseUri.__handle
		let relativeUriC = relativeUri.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Create_6(baseUriC, relativeUriC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var absolutePath: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_AbsolutePath_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var absoluteUri: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_AbsoluteUri_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var localPath: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_LocalPath_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var authority: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Authority_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var hostNameType: System_UriHostNameType /* System.UriHostNameType */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_HostNameType_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_UriHostNameType(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isDefaultPort: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsDefaultPort_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isFile: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsFile_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var isLoopback: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsLoopback_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var pathAndQuery: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_PathAndQuery_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var segments: System_String_Array /* System.String[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Segments_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isUnc: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsUnc_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var host: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Host_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var port: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Port_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var query: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Query_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var fragment: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Fragment_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var scheme: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_Scheme_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var originalString: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_OriginalString_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dnsSafeHost: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_DnsSafeHost_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var idnHost: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IdnHost_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var isAbsoluteUri: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_IsAbsoluteUri_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var userEscaped: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_UserEscaped_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public var userInfo: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_Uri_UserInfo_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeFile: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeFile_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeFtp: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeFtp_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeSftp: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeSftp_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeFtps: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeFtps_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeGopher: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeGopher_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeHttp: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeHttp_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeHttps: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeHttps_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeWs: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeWs_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeWss: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeWss_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeMailto: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeMailto_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeNews: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeNews_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeNntp: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeNntp_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeSsh: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeSsh_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeTelnet: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeTelnet_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeNetTcp: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeNetTcp_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var uriSchemeNetPipe: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_UriSchemeNetPipe_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var schemeDelimiter: System_String /* System.String */ { get {
		
		
		let __returnValueC = System_Uri_SchemeDelimiter_Get()
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Uri_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Uri_Destroy(self.__handle)
		
	}
	
	
}



public class System_UriCreationOptions /* System.UriCreationOptions */: System_ValueType {
	public override class var typeName: String { get {
		"UriCreationOptions"
	}}

	public override class var fullTypeName: String { get {
		"System.UriCreationOptions"
	}}

	public var dangerousDisablePathAndQueryCanonicalization: Bool /* System.Boolean */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UriCreationOptions_DangerousDisablePathAndQueryCanonicalization_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func dangerousDisablePathAndQueryCanonicalization_set(_ value: Bool /* System.Boolean */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		System_UriCreationOptions_DangerousDisablePathAndQueryCanonicalization_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = System_UriCreationOptions_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UriCreationOptions_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_UriCreationOptions_Destroy(self.__handle)
		
	}
	
	
}



public class Beyond_NET_Sample_Person_Array /* Beyond.NET.Sample.Person[] */: System_Array {
	public override class var typeName: String { get {
		"Person[]"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Person[]"
	}}

	
}















public class Beyond_NET_Sample_Person_Extensions /* Beyond.NET.Sample.Person_Extensions */: System_Object {
	public override class var typeName: String { get {
		"Person_Extensions"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Person_Extensions"
	}}

	public class func increaseAge(_ person: Beyond_NET_Sample_Person /* Beyond.NET.Sample.Person */, _ byYears: Int32 /* System.Int32 */) throws {
		let personC = person.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Person_Extensions_IncreaseAge(personC, byYears, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func tryGetAddress(_ person: Beyond_NET_Sample_Person /* Beyond.NET.Sample.Person */, _ address: inout Beyond_NET_Sample_Address? /* Beyond.NET.Sample.Address */) throws -> Bool /* System.Boolean */ {
		let personC = person.__handle
		var addressC = address?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Person_Extensions_TryGetAddress(personC, &addressC, &__exceptionC)
		
		address = Beyond_NET_Sample_Address(handle: addressC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Person_Extensions_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Person_Extensions_Destroy(self.__handle)
		
	}
	
	
}



public class Beyond_NET_Sample_PropertyTests /* Beyond.NET.Sample.PropertyTests */: System_Object {
	public override class var typeName: String { get {
		"PropertyTests"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.PropertyTests"
	}}

	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_PropertyTests_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var favoriteNumber: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_PropertyTests_FavoriteNumber_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func favoriteNumber_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_PropertyTests_FavoriteNumber_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_PropertyTests_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_PropertyTests_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_SpanTest /* Beyond.NET.Sample.SpanTest */: System_Object {
	public override class var typeName: String { get {
		"SpanTest"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.SpanTest"
	}}

	public func getDataAsReadOnlySpan() throws -> Data? /* System.ReadOnlySpan<System.Byte> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_GetDataAsReadOnlySpan(self.__handle, &__exceptionC)
		
		let __returnValue = __returnValueC.data()
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func setDataAsReadOnlySpan(_ span: Data? /* System.ReadOnlySpan<System.Byte> */) throws {
		let spanC = span.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_SpanTest_SetDataAsReadOnlySpan(self.__handle, spanC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func tryGetDataAsReadOnlySpan(_ dataAsReadOnlySpan: inout Data? /* System.ReadOnlySpan<System.Byte> */) throws -> Bool /* System.Boolean */ {
		var dataAsReadOnlySpanC = dataAsReadOnlySpan.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_TryGetDataAsReadOnlySpan(self.__handle, &dataAsReadOnlySpanC, &__exceptionC)
		
		dataAsReadOnlySpan = dataAsReadOnlySpanC.data()
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func convertByteArrayToSpan(_ bytes: System_Byte_Array /* System.Byte[] */, _ converter: Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate /* Beyond.NET.Sample.SpanTest.ByteArrayToSpanDelegate */) throws -> Data? /* System.ReadOnlySpan<System.Byte> */ {
		let bytesC = bytes.__handle
		let converterC = converter.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_ConvertByteArrayToSpan(self.__handle, bytesC, converterC, &__exceptionC)
		
		let __returnValue = __returnValueC.data()
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func convertSpanToByteArray(_ span: Data? /* System.ReadOnlySpan<System.Byte> */, _ converter: Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate /* Beyond.NET.Sample.SpanTest.SpanToByteArrayDelegate */) throws -> System_Byte_Array /* System.Byte[] */ {
		let spanC = span.readOnlySpanOfByte()
		let converterC = converter.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_ConvertSpanToByteArray(self.__handle, spanC, converterC, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ data: System_Byte_Array /* System.Byte[] */) throws {
		let dataC = data.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_Create(dataC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public convenience init(_ dataAsReadOnlySpan: Data? /* System.ReadOnlySpan<System.Byte> */) throws {
		let dataAsReadOnlySpanC = dataAsReadOnlySpan.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_Create_1(dataAsReadOnlySpanC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var data: System_Byte_Array /* System.Byte[] */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_Data_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_Byte_Array(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var dataAsReadOnlySpan: Data? /* System.ReadOnlySpan<System.Byte> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_DataAsReadOnlySpan_Get(self.__handle, &__exceptionC)
		
		let __returnValue = __returnValueC.data()
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func dataAsReadOnlySpan_set(_ value: Data? /* System.ReadOnlySpan<System.Byte> */) throws {
		let valueC = value.readOnlySpanOfByte()
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_SpanTest_DataAsReadOnlySpan_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_SpanTest_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_SpanTest_Destroy(self.__handle)
		
	}
	
	
}



public class Beyond_NET_Sample_StructTest /* Beyond.NET.Sample.StructTest */: System_ValueType {
	public override class var typeName: String { get {
		"StructTest"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.StructTest"
	}}

	public class func getNullableStructReturnValue(_ returnNull: Bool /* System.Boolean */) throws -> Beyond_NET_Sample_StructTest? /* System.Nullable<Beyond.NET.Sample.StructTest> */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_GetNullableStructReturnValue(returnNull, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_StructTest(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func getNullableStructReturnValueInOutParameter(_ returnNull: Bool /* System.Boolean */, _ returnValue: inout Beyond_NET_Sample_StructTest? /* System.Nullable<Beyond.NET.Sample.StructTest> */) throws {
		var returnValueC = returnValue?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_StructTest_GetNullableStructReturnValueInOutParameter(returnNull, &returnValueC, &__exceptionC)
		
		returnValue = Beyond_NET_Sample_StructTest(handle: returnValueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public class func getNullableStructReturnValueOfRefParameter(_ returnValue: inout Beyond_NET_Sample_StructTest? /* System.Nullable<Beyond.NET.Sample.StructTest> */) throws -> Beyond_NET_Sample_StructTest? /* System.Nullable<Beyond.NET.Sample.StructTest> */ {
		var returnValueC = returnValue?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_GetNullableStructReturnValueOfRefParameter(&returnValueC, &__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_StructTest(handle: __returnValueC)
		
		returnValue = Beyond_NET_Sample_StructTest(handle: returnValueC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public convenience init(_ name: System_String? /* System.String */) throws {
		let nameC = name?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_Create(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var name: System_String? /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public func name_set(_ value: System_String? /* System.String */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_StructTest_Name_Set(self.__handle, valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public class var nullInstanceProperty: Beyond_NET_Sample_StructTest? /* System.Nullable<Beyond.NET.Sample.StructTest> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_NullInstanceProperty_Get(&__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_StructTest(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var nonNullInstanceProperty: Beyond_NET_Sample_StructTest? /* System.Nullable<Beyond.NET.Sample.StructTest> */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_NonNullInstanceProperty_Get(&__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_StructTest(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_StructTest_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_StructTest_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_StructTest_Destroy(self.__handle)
		
	}
	
	
}





public class Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */: System_Object {
	public override class var typeName: String { get {
		"Book"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Book"
	}}

	public convenience init(_ name: System_String /* System.String */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Book_Create(nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var name: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Book_Name_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public class var donQuixote: Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Book_DonQuixote_Get()
		
		let __returnValue = Beyond_NET_Sample_Book(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var aTaleOfTwoCities: Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Book_ATaleOfTwoCities_Get()
		
		let __returnValue = Beyond_NET_Sample_Book(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public class var theLordOfTheRings: Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_Book_TheLordOfTheRings_Get()
		
		let __returnValue = Beyond_NET_Sample_Book(handle: __returnValueC)
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Book_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Book_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_TestClass /* Beyond.NET.Sample.TestClass */: System_Object {
	public override class var typeName: String { get {
		"TestClass"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.TestClass"
	}}

	public func getChar(_ charReturnerDelegate: Beyond_NET_Sample_CharReturnerDelegate /* Beyond.NET.Sample.CharReturnerDelegate */) throws -> DNChar /* System.Char */ {
		let charReturnerDelegateC = charReturnerDelegate.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_GetChar(self.__handle, charReturnerDelegateC, &__exceptionC)
		
		let __returnValue = DNChar(cValue: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func sayHello() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestClass_SayHello(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func sayHello(_ name: System_String /* System.String */) throws {
		let nameC = name.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestClass_SayHello_1(self.__handle, nameC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func getHello() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_GetHello(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func getDate() throws -> System_DateTime /* System.DateTime */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_GetDate(self.__handle, &__exceptionC)
		
		let __returnValue = System_DateTime(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func add(_ number1: Int32 /* System.Int32 */, _ number2: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_Add(self.__handle, number1, number2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func divide(_ number1: Int32 /* System.Int32 */, _ number2: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_Divide(self.__handle, number1, number2, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getTestEnumName(_ testEnum: Beyond_NET_Sample_TestEnum /* Beyond.NET.Sample.TestEnum */) throws -> System_String /* System.String */ {
		let testEnumC = testEnum.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_GetTestEnumName(testEnumC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public func modifyByRefValueAndReturnOriginalValue(_ valueToModify: inout Int32 /* System.Int32 */, _ targetValue: Int32 /* System.Int32 */) throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_ModifyByRefValueAndReturnOriginalValue(self.__handle, &valueToModify, targetValue, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func modifyByRefEnum(_ enumToModify: inout Beyond_NET_Sample_TestEnum /* Beyond.NET.Sample.TestEnum */) throws {
		var enumToModifyC = enumToModify.cValue
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestClass_ModifyByRefEnum(self.__handle, &enumToModifyC, &__exceptionC)
		
		enumToModify = Beyond_NET_Sample_TestEnum(cValue: enumToModifyC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public func modifyByRefBookAndReturnOriginalBookAsOutParameter(_ bookToModify: inout Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */, _ targetBook: Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */, _ originalBook: inout Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */) throws {
		var bookToModifyC = bookToModify.__handle
		let targetBookC = targetBook.__handle
		var originalBookC = originalBook.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestClass_ModifyByRefBookAndReturnOriginalBookAsOutParameter(self.__handle, &bookToModifyC, targetBookC, &originalBookC, &__exceptionC)
		
		bookToModify = Beyond_NET_Sample_Book(handle: bookToModifyC)
		
		originalBook = Beyond_NET_Sample_Book(handle: originalBookC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	// TODO: Method with by ref return or setter or event handler type (Beyond_NET_Sample_TestClass_GetCurrentBookByRef)
	
	// TODO: Method with by ref return or setter or event handler type (Beyond_NET_Sample_TestClass_IncreaseAndGetCurrentIntValueByRef)
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestClass_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var currentBook: Beyond_NET_Sample_Book /* Beyond.NET.Sample.Book */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_TestClass_CurrentBook_Get(self.__handle)
		
		let __returnValue = Beyond_NET_Sample_Book(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func currentBook_set(_ value: Beyond_NET_Sample_Book? /* Beyond.NET.Sample.Book */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_TestClass_CurrentBook_Set(self.__handle, valueC)
		
		
	}
	
	
	public var currentIntValue: Int32 /* System.Int32 */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_TestClass_CurrentIntValue_Get(self.__handle)
		
		return __returnValueC
		
	}}
	public func currentIntValue_set(_ value: Int32 /* System.Int32 */) {
		
		
		Beyond_NET_Sample_TestClass_CurrentIntValue_Set(self.__handle, value)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_TestClass_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_TestClass_Destroy(self.__handle)
		
	}
	
	
}




public class Beyond_NET_Sample_TestRecord /* Beyond.NET.Sample.TestRecord */: System_Object {
	public override class var typeName: String { get {
		"TestRecord"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.TestRecord"
	}}

	public func test() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestRecord_Test(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public override func toString() throws -> System_String /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecord_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecord_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecord_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: Beyond_NET_Sample_TestRecord? /* Beyond.NET.Sample.TestRecord */) throws -> Bool /* System.Boolean */ {
		let otherC = other?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecord_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func deconstruct(_ AString: inout System_String /* System.String */) throws {
		var AStringC = AString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestRecord_Deconstruct(self.__handle, &AStringC, &__exceptionC)
		
		AString = System_String(handle: AStringC)
		
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ AString: System_String /* System.String */) throws {
		let AStringC = AString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecord_Create(AStringC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var aString: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecord_AString_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_TestRecord_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_TestRecord_Destroy(self.__handle)
		
	}
	
	
}




public class Beyond_NET_Sample_TestRecordStruct /* Beyond.NET.Sample.TestRecordStruct */: System_ValueType {
	public override class var typeName: String { get {
		"TestRecordStruct"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.TestRecordStruct"
	}}

	public override func toString() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: Beyond_NET_Sample_TestRecordStruct /* Beyond.NET.Sample.TestRecordStruct */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func deconstruct(_ anInt: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestRecordStruct_Deconstruct(self.__handle, &anInt, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public var anInt: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_anInt_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	public func anInt_set(_ value: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestRecordStruct_anInt_Set(self.__handle, value, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public var aString: System_String /* System.String */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_AString_Get(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	
	
	public var aStringField: System_String /* System.String */ { get {
		
		
		let __returnValueC = Beyond_NET_Sample_TestRecordStruct_AStringField_Get(self.__handle)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		return __returnValue
		
	}}
	public func aStringField_set(_ value: System_String? /* System.String */) {
		let valueC = value?.__handle
		
		
		Beyond_NET_Sample_TestRecordStruct_AStringField_Set(self.__handle, valueC)
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_TestRecordStruct_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_TestRecordStruct_Destroy(self.__handle)
		
	}
	
	
}




public class Beyond_NET_Sample_TestReadOnlyRecordStruct /* Beyond.NET.Sample.TestReadOnlyRecordStruct */: System_ValueType {
	public override class var typeName: String { get {
		"TestReadOnlyRecordStruct"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.TestReadOnlyRecordStruct"
	}}

	public override func toString() throws -> System_String? /* System.String */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_ToString(self.__handle, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override func getHashCode() throws -> Int32 /* System.Int32 */ {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_GetHashCode(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public override func equals(_ obj: System_Object? /* System.Object */) throws -> Bool /* System.Boolean */ {
		let objC = obj?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_Equals(self.__handle, objC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func equals(_ other: Beyond_NET_Sample_TestReadOnlyRecordStruct /* Beyond.NET.Sample.TestReadOnlyRecordStruct */) throws -> Bool /* System.Boolean */ {
		let otherC = other.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_Equals_1(self.__handle, otherC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public func deconstruct(_ anInt: inout Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_TestReadOnlyRecordStruct_Deconstruct(self.__handle, &anInt, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init(_ anInt: Int32 /* System.Int32 */) throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_Create(anInt, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public var anInt: Int32 /* System.Int32 */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_anInt_Get(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}}
	
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_TestReadOnlyRecordStruct_Create_1(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_TestReadOnlyRecordStruct_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_TestReadOnlyRecordStruct_Destroy(self.__handle)
		
	}
	
	
}




public class Beyond_NET_Sample_Transformer /* Beyond.NET.Sample.Transformer */: System_Object {
	public override class var typeName: String { get {
		"Transformer"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Transformer"
	}}

	public class func transformString(_ inputString: System_String /* System.String */, _ stringTransformer: Beyond_NET_Sample_Transformer_StringTransformerDelegate /* Beyond.NET.Sample.Transformer.StringTransformerDelegate */) throws -> System_String /* System.String */ {
		let inputStringC = inputString.__handle
		let stringTransformerC = stringTransformer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Transformer_TransformString(inputStringC, stringTransformerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func transformDoubles(_ number1: Double /* System.Double */, _ number2: Double /* System.Double */, _ doublesTransformer: Beyond_NET_Sample_Transformer_DoublesTransformerDelegate /* Beyond.NET.Sample.Transformer.DoublesTransformerDelegate */) throws -> Double /* System.Double */ {
		let doublesTransformerC = doublesTransformer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Transformer_TransformDoubles(number1, number2, doublesTransformerC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValueC
		
	}
	
	public class func getAndTransformString(_ stringGetter: Beyond_NET_Sample_Transformer_StringGetterDelegate /* Beyond.NET.Sample.Transformer.StringGetterDelegate */, _ stringTransformer: Beyond_NET_Sample_Transformer_StringTransformerDelegate /* Beyond.NET.Sample.Transformer.StringTransformerDelegate */) throws -> System_String /* System.String */ {
		let stringGetterC = stringGetter.__handle
		let stringTransformerC = stringTransformer.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Transformer_GetAndTransformString(stringGetterC, stringTransformerC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public class func uppercaseString(_ inputString: System_String /* System.String */) throws -> System_String /* System.String */ {
		let inputStringC = inputString.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Transformer_UppercaseString(inputStringC, &__exceptionC)
		
		let __returnValue = System_String(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Transformer_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Transformer_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_SubclassingTests_MyBaseClass /* Beyond.NET.Sample.SubclassingTests.MyBaseClass */: System_Object {
	public override class var typeName: String { get {
		"MyBaseClass"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.SubclassingTests.MyBaseClass"
	}}

	public func `do`() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_SubclassingTests_MyBaseClass_Do(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SubclassingTests_MyBaseClass_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_SubclassingTests_MyBaseClass_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_SubclassingTests_MyBaseClass_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_SubclassingTests_MySubClass /* Beyond.NET.Sample.SubclassingTests.MySubClass */: Beyond_NET_Sample_SubclassingTests_MyBaseClass {
	public override class var typeName: String { get {
		"MySubClass"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.SubclassingTests.MySubClass"
	}}

	public override func `do`() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_SubclassingTests_MySubClass_Do(self.__handle, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	public convenience init() throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_SubclassingTests_MySubClass_Create(&__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		self.init(handle: __returnValueC)
		
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_SubclassingTests_MySubClass_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_SubclassingTests_MySubClass_Destroy(self.__handle)
		
	}
	
	
}


public class Beyond_NET_Sample_Transformer_BuiltInTransformers /* Beyond.NET.Sample.Transformer.BuiltInTransformers */: System_Object {
	public override class var typeName: String { get {
		"BuiltInTransformers"
	}}

	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Transformer.BuiltInTransformers"
	}}

	public class var uppercaseStringTransformer: Beyond_NET_Sample_Transformer_StringTransformerDelegate /* Beyond.NET.Sample.Transformer.StringTransformerDelegate */ { get throws {
		
		
		var __exceptionC: System_Exception_t?
		
		let __returnValueC = Beyond_NET_Sample_Transformer_BuiltInTransformers_UppercaseStringTransformer_Get(&__exceptionC)
		
		let __returnValue = Beyond_NET_Sample_Transformer_StringTransformerDelegate(handle: __returnValueC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		return __returnValue
		
	}}
	public class func uppercaseStringTransformer_set(_ value: Beyond_NET_Sample_Transformer_StringTransformerDelegate? /* Beyond.NET.Sample.Transformer.StringTransformerDelegate */) throws {
		let valueC = value?.__handle
		
		
		var __exceptionC: System_Exception_t?
		
		Beyond_NET_Sample_Transformer_BuiltInTransformers_UppercaseStringTransformer_Set(valueC, &__exceptionC)
		
		if let __exceptionC {
		    let __exception = System_Exception(handle: __exceptionC)
		    let __error = __exception.error
		    
		    throw __error
		}
		
		
	}
	
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Transformer_BuiltInTransformers_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Transformer_BuiltInTransformers_Destroy(self.__handle)
		
	}
	
	
}


public class System_Action /* System.Action */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Action"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Action"
	}}
	
	public typealias ClosureType = () -> Void
	
	
	private static func __createCFunction() -> System_Action_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			__innerClosure()
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Action_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Action_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke() throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		System_Action_Invoke(__selfC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Action_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Action_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_MulticastDelegate /* System.MulticastDelegate */: System_Delegate {
	public override class var typeName: String { get {
		"System.MulticastDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"System.MulticastDelegate"
	}}
	
	public typealias ClosureType = () -> Void
	
	
	private static func __createCFunction() -> System_MulticastDelegate_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			__innerClosure()
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_MulticastDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_MulticastDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_MulticastDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_MulticastDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Delegate /* System.Delegate */: System_Object {
	public override class var typeName: String { get {
		"System.Delegate"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Delegate"
	}}
	
	public typealias ClosureType = () -> Void
	
	
	private static func __createCFunction() -> System_Delegate_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			__innerClosure()
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Delegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Delegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Delegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Delegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

// Type "T" was skipped. Reason: It has no full name.
// Type "T" was skipped. Reason: It has no full name.
public class System_Reflection_TypeFilter /* System.Reflection.TypeFilter */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Reflection.TypeFilter"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Reflection.TypeFilter"
	}}
	
	public typealias ClosureType = (_ m: System_Type /* System.Type */, _ filterCriteria: System_Object? /* System.Object */) -> Bool
	
	
	private static func __createCFunction() -> System_Reflection_TypeFilter_CFunction_t {
		return { __innerContext, m, filterCriteria in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let mSwift = System_Type(handle: m)
			let filterCriteriaSwift = System_Object(handle: filterCriteria)
			
			let __returnValueSwift = __innerClosure(mSwift, filterCriteriaSwift)
		
			return __returnValueSwift
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Reflection_TypeFilter_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Reflection_TypeFilter_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ m: System_Type /* System.Type */, _ filterCriteria: System_Object? /* System.Object */) throws -> Bool {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let mC = m.__handle
		let filterCriteriaC = filterCriteria?.__handle
		
		let __returnValueC = System_Reflection_TypeFilter_Invoke(__selfC, mC, filterCriteriaC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValueC
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_TypeFilter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_TypeFilter_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Threading_TimerCallback /* System.Threading.TimerCallback */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Threading.TimerCallback"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Threading.TimerCallback"
	}}
	
	public typealias ClosureType = (_ state: System_Object? /* System.Object */) -> Void
	
	
	private static func __createCFunction() -> System_Threading_TimerCallback_CFunction_t {
		return { __innerContext, state in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let stateSwift = System_Object(handle: state)
			
			__innerClosure(stateSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Threading_TimerCallback_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Threading_TimerCallback_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ state: System_Object? /* System.Object */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let stateC = state?.__handle
		
		System_Threading_TimerCallback_Invoke(__selfC, stateC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_TimerCallback_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_TimerCallback_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_AsyncCallback /* System.AsyncCallback */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.AsyncCallback"
	}}
	
	public override class var fullTypeName: String { get {
		"System.AsyncCallback"
	}}
	
	public typealias ClosureType = (_ ar: System_IAsyncResult /* System.IAsyncResult */) -> Void
	
	
	private static func __createCFunction() -> System_AsyncCallback_CFunction_t {
		return { __innerContext, ar in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let arSwift = System_IAsyncResult(handle: ar)
			
			__innerClosure(arSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_AsyncCallback_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_AsyncCallback_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ ar: System_IAsyncResult /* System.IAsyncResult */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let arC = ar.__handle
		
		System_AsyncCallback_Invoke(__selfC, arC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AsyncCallback_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AsyncCallback_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Reflection_ModuleResolveEventHandler /* System.Reflection.ModuleResolveEventHandler */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Reflection.ModuleResolveEventHandler"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Reflection.ModuleResolveEventHandler"
	}}
	
	public typealias ClosureType = (_ sender: System_Object /* System.Object */, _ e: System_ResolveEventArgs /* System.ResolveEventArgs */) -> System_Reflection_Module?
	
	
	private static func __createCFunction() -> System_Reflection_ModuleResolveEventHandler_CFunction_t {
		return { __innerContext, sender, e in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let senderSwift = System_Object(handle: sender)
			let eSwift = System_ResolveEventArgs(handle: e)
			
			let __returnValueSwift = __innerClosure(senderSwift, eSwift)
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Reflection_ModuleResolveEventHandler_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Reflection_ModuleResolveEventHandler_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ sender: System_Object /* System.Object */, _ e: System_ResolveEventArgs /* System.ResolveEventArgs */) throws -> System_Reflection_Module? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let senderC = sender.__handle
		let eC = e.__handle
		
		let __returnValueC = System_Reflection_ModuleResolveEventHandler_Invoke(__selfC, senderC, eC, &__exceptionC)
	
		let __returnValue = System_Reflection_Module(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_ModuleResolveEventHandler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_ModuleResolveEventHandler_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Reflection_MemberFilter /* System.Reflection.MemberFilter */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Reflection.MemberFilter"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Reflection.MemberFilter"
	}}
	
	public typealias ClosureType = (_ m: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ filterCriteria: System_Object? /* System.Object */) -> Bool
	
	
	private static func __createCFunction() -> System_Reflection_MemberFilter_CFunction_t {
		return { __innerContext, m, filterCriteria in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let mSwift = System_Reflection_MemberInfo(handle: m)
			let filterCriteriaSwift = System_Object(handle: filterCriteria)
			
			let __returnValueSwift = __innerClosure(mSwift, filterCriteriaSwift)
		
			return __returnValueSwift
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Reflection_MemberFilter_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Reflection_MemberFilter_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ m: System_Reflection_MemberInfo /* System.Reflection.MemberInfo */, _ filterCriteria: System_Object? /* System.Object */) throws -> Bool {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let mC = m.__handle
		let filterCriteriaC = filterCriteria?.__handle
		
		let __returnValueC = System_Reflection_MemberFilter_Invoke(__selfC, mC, filterCriteriaC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValueC
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Reflection_MemberFilter_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Reflection_MemberFilter_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Threading_ContextCallback /* System.Threading.ContextCallback */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Threading.ContextCallback"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Threading.ContextCallback"
	}}
	
	public typealias ClosureType = (_ state: System_Object? /* System.Object */) -> Void
	
	
	private static func __createCFunction() -> System_Threading_ContextCallback_CFunction_t {
		return { __innerContext, state in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let stateSwift = System_Object(handle: state)
			
			__innerClosure(stateSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Threading_ContextCallback_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Threading_ContextCallback_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ state: System_Object? /* System.Object */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let stateC = state?.__handle
		
		System_Threading_ContextCallback_Invoke(__selfC, stateC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ContextCallback_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_ContextCallback_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_UnhandledExceptionEventHandler /* System.UnhandledExceptionEventHandler */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.UnhandledExceptionEventHandler"
	}}
	
	public override class var fullTypeName: String { get {
		"System.UnhandledExceptionEventHandler"
	}}
	
	public typealias ClosureType = (_ sender: System_Object /* System.Object */, _ e: System_UnhandledExceptionEventArgs /* System.UnhandledExceptionEventArgs */) -> Void
	
	
	private static func __createCFunction() -> System_UnhandledExceptionEventHandler_CFunction_t {
		return { __innerContext, sender, e in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let senderSwift = System_Object(handle: sender)
			let eSwift = System_UnhandledExceptionEventArgs(handle: e)
			
			__innerClosure(senderSwift, eSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_UnhandledExceptionEventHandler_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_UnhandledExceptionEventHandler_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ sender: System_Object /* System.Object */, _ e: System_UnhandledExceptionEventArgs /* System.UnhandledExceptionEventArgs */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let senderC = sender.__handle
		let eC = e.__handle
		
		System_UnhandledExceptionEventHandler_Invoke(__selfC, senderC, eC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_UnhandledExceptionEventHandler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_UnhandledExceptionEventHandler_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_EventHandler /* System.EventHandler */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.EventHandler"
	}}
	
	public override class var fullTypeName: String { get {
		"System.EventHandler"
	}}
	
	public typealias ClosureType = (_ sender: System_Object? /* System.Object */, _ e: System_EventArgs /* System.EventArgs */) -> Void
	
	
	private static func __createCFunction() -> System_EventHandler_CFunction_t {
		return { __innerContext, sender, e in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let senderSwift = System_Object(handle: sender)
			let eSwift = System_EventArgs(handle: e)
			
			__innerClosure(senderSwift, eSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_EventHandler_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_EventHandler_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ sender: System_Object? /* System.Object */, _ e: System_EventArgs /* System.EventArgs */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let senderC = sender?.__handle
		let eC = e.__handle
		
		System_EventHandler_Invoke(__selfC, senderC, eC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_EventHandler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_EventHandler_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_AssemblyLoadEventHandler /* System.AssemblyLoadEventHandler */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.AssemblyLoadEventHandler"
	}}
	
	public override class var fullTypeName: String { get {
		"System.AssemblyLoadEventHandler"
	}}
	
	public typealias ClosureType = (_ sender: System_Object? /* System.Object */, _ args: System_AssemblyLoadEventArgs /* System.AssemblyLoadEventArgs */) -> Void
	
	
	private static func __createCFunction() -> System_AssemblyLoadEventHandler_CFunction_t {
		return { __innerContext, sender, args in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let senderSwift = System_Object(handle: sender)
			let argsSwift = System_AssemblyLoadEventArgs(handle: args)
			
			__innerClosure(senderSwift, argsSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_AssemblyLoadEventHandler_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_AssemblyLoadEventHandler_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ sender: System_Object? /* System.Object */, _ args: System_AssemblyLoadEventArgs /* System.AssemblyLoadEventArgs */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let senderC = sender?.__handle
		let argsC = args.__handle
		
		System_AssemblyLoadEventHandler_Invoke(__selfC, senderC, argsC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_AssemblyLoadEventHandler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_AssemblyLoadEventHandler_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_ResolveEventHandler /* System.ResolveEventHandler */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.ResolveEventHandler"
	}}
	
	public override class var fullTypeName: String { get {
		"System.ResolveEventHandler"
	}}
	
	public typealias ClosureType = (_ sender: System_Object? /* System.Object */, _ args: System_ResolveEventArgs /* System.ResolveEventArgs */) -> System_Reflection_Assembly?
	
	
	private static func __createCFunction() -> System_ResolveEventHandler_CFunction_t {
		return { __innerContext, sender, args in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let senderSwift = System_Object(handle: sender)
			let argsSwift = System_ResolveEventArgs(handle: args)
			
			let __returnValueSwift = __innerClosure(senderSwift, argsSwift)
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_ResolveEventHandler_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_ResolveEventHandler_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ sender: System_Object? /* System.Object */, _ args: System_ResolveEventArgs /* System.ResolveEventArgs */) throws -> System_Reflection_Assembly? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let senderC = sender?.__handle
		let argsC = args.__handle
		
		let __returnValueC = System_ResolveEventHandler_Invoke(__selfC, senderC, argsC, &__exceptionC)
	
		let __returnValue = System_Reflection_Assembly(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_ResolveEventHandler_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_ResolveEventHandler_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Threading_ThreadStart /* System.Threading.ThreadStart */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Threading.ThreadStart"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Threading.ThreadStart"
	}}
	
	public typealias ClosureType = () -> Void
	
	
	private static func __createCFunction() -> System_Threading_ThreadStart_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			__innerClosure()
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Threading_ThreadStart_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Threading_ThreadStart_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke() throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		System_Threading_ThreadStart_Invoke(__selfC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ThreadStart_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_ThreadStart_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class System_Threading_ParameterizedThreadStart /* System.Threading.ParameterizedThreadStart */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"System.Threading.ParameterizedThreadStart"
	}}
	
	public override class var fullTypeName: String { get {
		"System.Threading.ParameterizedThreadStart"
	}}
	
	public typealias ClosureType = (_ obj: System_Object? /* System.Object */) -> Void
	
	
	private static func __createCFunction() -> System_Threading_ParameterizedThreadStart_CFunction_t {
		return { __innerContext, obj in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let objSwift = System_Object(handle: obj)
			
			__innerClosure(objSwift)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> System_Threading_ParameterizedThreadStart_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = System_Threading_ParameterizedThreadStart_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ obj: System_Object? /* System.Object */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let objC = obj?.__handle
		
		System_Threading_ParameterizedThreadStart_Invoke(__selfC, objC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: System_Threading_ParameterizedThreadStart_TypeOf())
		
	}}
	
	internal override func destroy() {
		System_Threading_ParameterizedThreadStart_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_MoveDelegate /* Beyond.NET.Sample.MoveDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.MoveDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.MoveDelegate"
	}}
	
	public typealias ClosureType = (_ newStreet: System_String /* System.String */, _ newCity: System_String /* System.String */) -> Beyond_NET_Sample_Address?
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_MoveDelegate_CFunction_t {
		return { __innerContext, newStreet, newCity in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let newStreetSwift = System_String(handle: newStreet)
			let newCitySwift = System_String(handle: newCity)
			
			let __returnValueSwift = __innerClosure(newStreetSwift, newCitySwift)
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_MoveDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_MoveDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ newStreet: System_String /* System.String */, _ newCity: System_String /* System.String */) throws -> Beyond_NET_Sample_Address? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let newStreetC = newStreet.__handle
		let newCityC = newCity.__handle
		
		let __returnValueC = Beyond_NET_Sample_MoveDelegate_Invoke(__selfC, newStreetC, newCityC, &__exceptionC)
	
		let __returnValue = Beyond_NET_Sample_Address(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_MoveDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_MoveDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_AnimalCreatorDelegate /* Beyond.NET.Sample.AnimalCreatorDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.AnimalCreatorDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.AnimalCreatorDelegate"
	}}
	
	public typealias ClosureType = (_ animalName: System_String /* System.String */) -> Beyond_NET_Sample_IAnimal?
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_AnimalCreatorDelegate_CFunction_t {
		return { __innerContext, animalName in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let animalNameSwift = System_String(handle: animalName)
			
			let __returnValueSwift = __innerClosure(animalNameSwift)
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_AnimalCreatorDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_AnimalCreatorDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ animalName: System_String /* System.String */) throws -> Beyond_NET_Sample_IAnimal? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let animalNameC = animalName.__handle
		
		let __returnValueC = Beyond_NET_Sample_AnimalCreatorDelegate_Invoke(__selfC, animalNameC, &__exceptionC)
	
		let __returnValue = Beyond_NET_Sample_IAnimal(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_AnimalCreatorDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_AnimalCreatorDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_AsyncTests_TransformerDelegate /* Beyond.NET.Sample.AsyncTests+TransformerDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.AsyncTests.TransformerDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.AsyncTests+TransformerDelegate"
	}}
	
	public typealias ClosureType = (_ number1: Int32 /* System.Int32 */, _ number2: Int32 /* System.Int32 */) -> Int32
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_AsyncTests_TransformerDelegate_CFunction_t {
		return { __innerContext, number1, number2 in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			let __returnValueSwift = __innerClosure(number1, number2)
		
			return __returnValueSwift
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_AsyncTests_TransformerDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_AsyncTests_TransformerDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ number1: Int32 /* System.Int32 */, _ number2: Int32 /* System.Int32 */) throws -> Int32 {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		let __returnValueC = Beyond_NET_Sample_AsyncTests_TransformerDelegate_Invoke(__selfC, number1, number2, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValueC
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_AsyncTests_TransformerDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_AsyncTests_TransformerDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_DelegatesTest_TransformIntDelegate /* Beyond.NET.Sample.DelegatesTest+TransformIntDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.DelegatesTest.TransformIntDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.DelegatesTest+TransformIntDelegate"
	}}
	
	public typealias ClosureType = (_ i: Int32 /* System.Int32 */) -> Int32
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_DelegatesTest_TransformIntDelegate_CFunction_t {
		return { __innerContext, i in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			let __returnValueSwift = __innerClosure(i)
		
			return __returnValueSwift
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_DelegatesTest_TransformIntDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_DelegatesTest_TransformIntDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ i: Int32 /* System.Int32 */) throws -> Int32 {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		let __returnValueC = Beyond_NET_Sample_DelegatesTest_TransformIntDelegate_Invoke(__selfC, i, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValueC
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_DelegatesTest_TransformIntDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_DelegatesTest_TransformIntDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_DelegatesTest_PointTransformDelegate /* Beyond.NET.Sample.DelegatesTest+PointTransformDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.DelegatesTest.PointTransformDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.DelegatesTest+PointTransformDelegate"
	}}
	
	public typealias ClosureType = (_ point: Beyond_NET_Sample_Point /* Beyond.NET.Sample.Point */) -> Beyond_NET_Sample_Point
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_DelegatesTest_PointTransformDelegate_CFunction_t {
		return { __innerContext, point in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let pointSwift = Beyond_NET_Sample_Point(handle: point)
			
			let __returnValueSwift = __innerClosure(pointSwift)
		
			let __returnValue = __returnValueSwift.__handle
			__returnValueSwift.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_DelegatesTest_PointTransformDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_DelegatesTest_PointTransformDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ point: Beyond_NET_Sample_Point /* Beyond.NET.Sample.Point */) throws -> Beyond_NET_Sample_Point {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let pointC = point.__handle
		
		let __returnValueC = Beyond_NET_Sample_DelegatesTest_PointTransformDelegate_Invoke(__selfC, pointC, &__exceptionC)
	
		let __returnValue = Beyond_NET_Sample_Point(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_DelegatesTest_PointTransformDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_DelegatesTest_PointTransformDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_EventTests_ValueChangedDelegate /* Beyond.NET.Sample.EventTests+ValueChangedDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.EventTests.ValueChangedDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.EventTests+ValueChangedDelegate"
	}}
	
	public typealias ClosureType = (_ sender: System_Object /* System.Object */, _ newValue: Int32 /* System.Int32 */) -> Void
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_EventTests_ValueChangedDelegate_CFunction_t {
		return { __innerContext, sender, newValue in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let senderSwift = System_Object(handle: sender)
			
			__innerClosure(senderSwift, newValue)
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_EventTests_ValueChangedDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_EventTests_ValueChangedDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ sender: System_Object /* System.Object */, _ newValue: Int32 /* System.Int32 */) throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let senderC = sender.__handle
		
		Beyond_NET_Sample_EventTests_ValueChangedDelegate_Invoke(__selfC, senderC, newValue, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_EventTests_ValueChangedDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_EventTests_ValueChangedDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate /* Beyond.NET.Sample.Person+NumberOfChildrenChangedDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.Person.NumberOfChildrenChangedDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Person+NumberOfChildrenChangedDelegate"
	}}
	
	public typealias ClosureType = () -> Void
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			__innerClosure()
		
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke() throws -> Void {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate_Invoke(__selfC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_Person_NewAgeProviderDelegate /* Beyond.NET.Sample.Person+NewAgeProviderDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.Person.NewAgeProviderDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Person+NewAgeProviderDelegate"
	}}
	
	public typealias ClosureType = () -> Int32
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_Person_NewAgeProviderDelegate_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			let __returnValueSwift = __innerClosure()
		
			return __returnValueSwift
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_Person_NewAgeProviderDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_Person_NewAgeProviderDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke() throws -> Int32 {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		let __returnValueC = Beyond_NET_Sample_Person_NewAgeProviderDelegate_Invoke(__selfC, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValueC
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Person_NewAgeProviderDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Person_NewAgeProviderDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate /* Beyond.NET.Sample.SpanTest+ByteArrayToSpanDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.SpanTest.ByteArrayToSpanDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.SpanTest+ByteArrayToSpanDelegate"
	}}
	
	public typealias ClosureType = (_ bytes: System_Byte_Array /* System.Byte[] */) -> Data?
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate_CFunction_t {
		return { __innerContext, bytes in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let bytesSwift = System_Byte_Array(handle: bytes)
			
			let __returnValueSwift = __innerClosure(bytesSwift)
		
			let __returnValue = __returnValueSwift.readOnlySpanOfByte()
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ bytes: System_Byte_Array /* System.Byte[] */) throws -> Data? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let bytesC = bytes.__handle
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate_Invoke(__selfC, bytesC, &__exceptionC)
	
		let __returnValue = __returnValueC.data()
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate /* Beyond.NET.Sample.SpanTest+SpanToByteArrayDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.SpanTest.SpanToByteArrayDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.SpanTest+SpanToByteArrayDelegate"
	}}
	
	public typealias ClosureType = (_ span: Data? /* System.ReadOnlySpan<System.Byte> */) -> System_Byte_Array?
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate_CFunction_t {
		return { __innerContext, span in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let spanSwift = span.data()
			
			let __returnValueSwift = __innerClosure(spanSwift)
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ span: Data? /* System.ReadOnlySpan<System.Byte> */) throws -> System_Byte_Array? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let spanC = span.readOnlySpanOfByte()
		
		let __returnValueC = Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate_Invoke(__selfC, spanC, &__exceptionC)
	
		let __returnValue = System_Byte_Array(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

// TODO: (Beyond_NET_Sample_ByRefReturnValueDelegate) Unsupported delegate type. Reason: Has by ref return type

// TODO: (Beyond_NET_Sample_ByRefParametersDelegate) Unsupported delegate type. Reason: Has by ref parameters

// TODO: (Beyond_NET_Sample_OutParametersDelegate) Unsupported delegate type. Reason: Has out parameters

public class Beyond_NET_Sample_CharReturnerDelegate /* Beyond.NET.Sample.CharReturnerDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.CharReturnerDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.CharReturnerDelegate"
	}}
	
	public typealias ClosureType = () -> DNChar
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_CharReturnerDelegate_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			let __returnValueSwift = __innerClosure()
		
			let __returnValue = __returnValueSwift.cValue
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_CharReturnerDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_CharReturnerDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke() throws -> DNChar {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		let __returnValueC = Beyond_NET_Sample_CharReturnerDelegate_Invoke(__selfC, &__exceptionC)
	
		let __returnValue = DNChar(cValue: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_CharReturnerDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_CharReturnerDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_Transformer_StringTransformerDelegate /* Beyond.NET.Sample.Transformer+StringTransformerDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.Transformer.StringTransformerDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Transformer+StringTransformerDelegate"
	}}
	
	public typealias ClosureType = (_ inputString: System_String /* System.String */) -> System_String?
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_Transformer_StringTransformerDelegate_CFunction_t {
		return { __innerContext, inputString in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			let inputStringSwift = System_String(handle: inputString)
			
			let __returnValueSwift = __innerClosure(inputStringSwift)
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_Transformer_StringTransformerDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_Transformer_StringTransformerDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ inputString: System_String /* System.String */) throws -> System_String? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		let inputStringC = inputString.__handle
		
		let __returnValueC = Beyond_NET_Sample_Transformer_StringTransformerDelegate_Invoke(__selfC, inputStringC, &__exceptionC)
	
		let __returnValue = System_String(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Transformer_StringTransformerDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Transformer_StringTransformerDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_Transformer_DoublesTransformerDelegate /* Beyond.NET.Sample.Transformer+DoublesTransformerDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.Transformer.DoublesTransformerDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Transformer+DoublesTransformerDelegate"
	}}
	
	public typealias ClosureType = (_ number1: Double /* System.Double */, _ number2: Double /* System.Double */) -> Double
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_Transformer_DoublesTransformerDelegate_CFunction_t {
		return { __innerContext, number1, number2 in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			let __returnValueSwift = __innerClosure(number1, number2)
		
			return __returnValueSwift
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_Transformer_DoublesTransformerDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_Transformer_DoublesTransformerDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke(_ number1: Double /* System.Double */, _ number2: Double /* System.Double */) throws -> Double {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		let __returnValueC = Beyond_NET_Sample_Transformer_DoublesTransformerDelegate_Invoke(__selfC, number1, number2, &__exceptionC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValueC
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Transformer_DoublesTransformerDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Transformer_DoublesTransformerDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}

public class Beyond_NET_Sample_Transformer_StringGetterDelegate /* Beyond.NET.Sample.Transformer+StringGetterDelegate */: System_MulticastDelegate {
	public override class var typeName: String { get {
		"Beyond.NET.Sample.Transformer.StringGetterDelegate"
	}}
	
	public override class var fullTypeName: String { get {
		"Beyond.NET.Sample.Transformer+StringGetterDelegate"
	}}
	
	public typealias ClosureType = () -> System_String?
	
	
	private static func __createCFunction() -> Beyond_NET_Sample_Transformer_StringGetterDelegate_CFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			let __innerSwiftContext = NativeBox<ClosureType>.fromPointer(__innerContext)
			let __innerClosure = __innerSwiftContext.value
		
			
			let __returnValueSwift = __innerClosure()
		
			let __returnValue = __returnValueSwift?.__handle
			__returnValueSwift?.__skipDestroy = true // Will be destroyed by .NET
		
			return __returnValue
		}
		
	}
	
	private static func __createCDestructorFunction() -> Beyond_NET_Sample_Transformer_StringGetterDelegate_CDestructorFunction_t {
		return { __innerContext in
			guard let __innerContext else { fatalError("Context is nil") }
		
			NativeBox<ClosureType>.release(__innerContext)
		}
		
	}
	
	public convenience init(_ __closure: @escaping ClosureType) {
		let __cFunction = Self.__createCFunction()
		let __cDestructorFunction = Self.__createCDestructorFunction()
		
		let __outerSwiftContext = NativeBox(__closure)
		let __outerContext = __outerSwiftContext.retainedPointer()
		
		let __delegateC = Beyond_NET_Sample_Transformer_StringGetterDelegate_Create(__outerContext, __cFunction, __cDestructorFunction)
		
		self.init(handle: __delegateC)
		
	}
	
	public func invoke() throws -> System_String? {
		var __exceptionC: System_Exception_t?
	
		let __selfC = self.__handle
	
		
		let __returnValueC = Beyond_NET_Sample_Transformer_StringGetterDelegate_Invoke(__selfC, &__exceptionC)
	
		let __returnValue = System_String(handle: __returnValueC)
	
	    if let __exceptionC {
	        let __exception = System_Exception(handle: __exceptionC)
	        let __error = __exception.error
	        
	        throw __error
	    }
	
		return __returnValue
	}
	
	public override class var typeOf: System_Type /* System.Type */ { get {
		return System_Type(handle: Beyond_NET_Sample_Transformer_StringGetterDelegate_TypeOf())
		
	}}
	
	internal override func destroy() {
		Beyond_NET_Sample_Transformer_StringGetterDelegate_Destroy(self.__handle)
		
	}
	
	
	
	
}


// MARK: - END APIs

// MARK: - BEGIN API Extensions
extension Beyond_NET_Sample_Person? {
	
	
	
	
	
}

extension Beyond_NET_Sample_Person {
	public func increaseAge(_ byYears: Int32 /* System.Int32 */) throws {
		try Beyond_NET_Sample_Person_Extensions.increaseAge(self, byYears)
	}
	
	public func tryGetAddress(_ address: inout Beyond_NET_Sample_Address? /* Beyond.NET.Sample.Address */) throws -> Bool {
		return try Beyond_NET_Sample_Person_Extensions.tryGetAddress(self, &address)
	}
	
	
}


// MARK: - END API Extensions

// MARK: - BEGIN Namespaces

public struct System {
	public typealias TypeCode = System_TypeCode
	public typealias MidpointRounding = System_MidpointRounding
	public typealias DateTimeKind = System_DateTimeKind
	public typealias DayOfWeek = System_DayOfWeek
	public typealias StringComparison = System_StringComparison
	public typealias StringSplitOptions = System_StringSplitOptions
	public typealias GCKind = System_GCKind
	public typealias GCCollectionMode = System_GCCollectionMode
	public typealias GCNotificationStatus = System_GCNotificationStatus
	public typealias Base64FormattingOptions = System_Base64FormattingOptions
	public typealias UriHostNameType = System_UriHostNameType
	public typealias UriPartial = System_UriPartial
	public typealias UriKind = System_UriKind
	public typealias UriComponents = System_UriComponents
	public typealias UriFormat = System_UriFormat
	public typealias Object = System_Object
	public typealias `Type` = System_Type
	public typealias Object_Array = System_Object_Array
	public typealias Array = System_Array
	public typealias ICloneable = System_ICloneable
	public typealias Boolean = System_Boolean
	public typealias ValueType = System_ValueType
	public typealias Int32 = System_Int32
	public typealias IComparable = System_IComparable
	public typealias IConvertible = System_IConvertible
	public typealias Enum = System_Enum
	public typealias ISpanFormattable = System_ISpanFormattable
	public typealias IFormattable = System_IFormattable
	public typealias String = System_String
	public typealias IDisposable = System_IDisposable
	public typealias Char = System_Char
	public typealias IUtf8SpanFormattable = System_IUtf8SpanFormattable
	public typealias IFormatProvider = System_IFormatProvider
	public typealias SByte = System_SByte
	public typealias Byte = System_Byte
	public typealias Byte_Array = System_Byte_Array
	public typealias Int16 = System_Int16
	public typealias UInt16 = System_UInt16
	public typealias UInt32 = System_UInt32
	public typealias Int64 = System_Int64
	public typealias UInt64 = System_UInt64
	public typealias Single = System_Single
	public typealias Double = System_Double
	public typealias Decimal = System_Decimal
	public typealias Int32_Array = System_Int32_Array
	public typealias DateTime = System_DateTime
	public typealias TimeSpan = System_TimeSpan
	public typealias String_Array = System_String_Array
	public typealias DateOnly = System_DateOnly
	public typealias TimeOnly = System_TimeOnly
	public typealias Version = System_Version
	public typealias MarshalByRefObject = System_MarshalByRefObject
	public typealias IAsyncDisposable = System_IAsyncDisposable
	public typealias IntPtr = System_IntPtr
	public typealias Exception = System_Exception
	public typealias RuntimeMethodHandle = System_RuntimeMethodHandle
	public typealias RuntimeTypeHandle = System_RuntimeTypeHandle
	public typealias ModuleHandle = System_ModuleHandle
	public typealias RuntimeTypeHandle_Array = System_RuntimeTypeHandle_Array
	public typealias RuntimeFieldHandle = System_RuntimeFieldHandle
	public typealias Guid = System_Guid
	public typealias Type_Array = System_Type_Array
	public typealias IAsyncResult = System_IAsyncResult
	public typealias AggregateException = System_AggregateException
	public typealias Exception_Array = System_Exception_Array
	public typealias TimeProvider = System_TimeProvider
	public typealias DateTimeOffset = System_DateTimeOffset
	public typealias TimeZoneInfo = System_TimeZoneInfo
	public typealias TimeSpan_Array = System_TimeSpan_Array
	public typealias TimeZoneInfo_Array = System_TimeZoneInfo_Array
	public typealias TimeZoneInfo_AdjustmentRule_Array = System_TimeZoneInfo_AdjustmentRule_Array
	public typealias TimeZoneInfo_AdjustmentRule = System_TimeZoneInfo_AdjustmentRule
	public typealias TimeZoneInfo_TransitionTime = System_TimeZoneInfo_TransitionTime
	public typealias ResolveEventArgs = System_ResolveEventArgs
	public typealias EventArgs = System_EventArgs
	public typealias Char_Array = System_Char_Array
	public typealias CharEnumerator = System_CharEnumerator
	public typealias Int64_Array = System_Int64_Array
	public typealias Attribute = System_Attribute
	public typealias Attribute_Array = System_Attribute_Array
	public typealias Int16_Array = System_Int16_Array
	public typealias Single_Array = System_Single_Array
	public typealias Double_Array = System_Double_Array
	public typealias IntPtr_Array = System_IntPtr_Array
	public typealias NullReferenceException = System_NullReferenceException
	public typealias SystemException = System_SystemException
	public typealias PlatformNotSupportedException = System_PlatformNotSupportedException
	public typealias NotSupportedException = System_NotSupportedException
	public typealias UIntPtr = System_UIntPtr
	public typealias AppContext = System_AppContext
	public typealias GC = System_GC
	public typealias GCMemoryInfo = System_GCMemoryInfo
	public typealias WeakReference = System_WeakReference
	public typealias Math = System_Math
	public typealias Convert = System_Convert
	public typealias LocalDataStoreSlot = System_LocalDataStoreSlot
	public typealias AppDomain = System_AppDomain
	public typealias AppDomainSetup = System_AppDomainSetup
	public typealias UnhandledExceptionEventArgs = System_UnhandledExceptionEventArgs
	public typealias AssemblyLoadEventArgs = System_AssemblyLoadEventArgs
	public typealias Random = System_Random
	public typealias Half = System_Half
	public typealias Int128 = System_Int128
	public typealias UInt128 = System_UInt128
	public typealias Uri = System_Uri
	public typealias UriCreationOptions = System_UriCreationOptions
	public typealias Action = System_Action
	public typealias MulticastDelegate = System_MulticastDelegate
	public typealias Delegate = System_Delegate
	public typealias AsyncCallback = System_AsyncCallback
	public typealias UnhandledExceptionEventHandler = System_UnhandledExceptionEventHandler
	public typealias EventHandler = System_EventHandler
	public typealias AssemblyLoadEventHandler = System_AssemblyLoadEventHandler
	public typealias ResolveEventHandler = System_ResolveEventHandler
	
}


public extension System {
    struct Globalization {
		public typealias CultureTypes = System_Globalization_CultureTypes
		public typealias NumberStyles = System_Globalization_NumberStyles
		public typealias TimeSpanStyles = System_Globalization_TimeSpanStyles
		public typealias DateTimeStyles = System_Globalization_DateTimeStyles
		public typealias CalendarAlgorithmType = System_Globalization_CalendarAlgorithmType
		public typealias CalendarWeekRule = System_Globalization_CalendarWeekRule
		public typealias UnicodeCategory = System_Globalization_UnicodeCategory
		public typealias CompareOptions = System_Globalization_CompareOptions
		public typealias DigitShapes = System_Globalization_DigitShapes
		public typealias CultureInfo = System_Globalization_CultureInfo
		public typealias CultureInfo_Array = System_Globalization_CultureInfo_Array
		public typealias CompareInfo = System_Globalization_CompareInfo
		public typealias Calendar = System_Globalization_Calendar
		public typealias SortKey = System_Globalization_SortKey
		public typealias SortVersion = System_Globalization_SortVersion
		public typealias TextInfo = System_Globalization_TextInfo
		public typealias NumberFormatInfo = System_Globalization_NumberFormatInfo
		public typealias DateTimeFormatInfo = System_Globalization_DateTimeFormatInfo
		public typealias Calendar_Array = System_Globalization_Calendar_Array
		
    }
}



public extension System {
    struct Runtime {
		
    }
}


public extension System.Runtime {
    struct Serialization {
		public typealias StreamingContextStates = System_Runtime_Serialization_StreamingContextStates
		public typealias IDeserializationCallback = System_Runtime_Serialization_IDeserializationCallback
		public typealias ISerializable = System_Runtime_Serialization_ISerializable
		public typealias SerializationInfo = System_Runtime_Serialization_SerializationInfo
		public typealias SerializationInfoEnumerator = System_Runtime_Serialization_SerializationInfoEnumerator
		public typealias SerializationEntry = System_Runtime_Serialization_SerializationEntry
		public typealias IFormatterConverter = System_Runtime_Serialization_IFormatterConverter
		public typealias StreamingContext = System_Runtime_Serialization_StreamingContext
		public typealias IObjectReference = System_Runtime_Serialization_IObjectReference
		
    }
}



public extension System.Runtime {
    struct InteropServices {
		public typealias LayoutKind = System_Runtime_InteropServices_LayoutKind
		public typealias CharSet = System_Runtime_InteropServices_CharSet
		public typealias CustomQueryInterfaceMode = System_Runtime_InteropServices_CustomQueryInterfaceMode
		public typealias GCHandleType = System_Runtime_InteropServices_GCHandleType
		public typealias SafeHandle = System_Runtime_InteropServices_SafeHandle
		public typealias StructLayoutAttribute = System_Runtime_InteropServices_StructLayoutAttribute
		public typealias Marshal = System_Runtime_InteropServices_Marshal
		public typealias GCHandle = System_Runtime_InteropServices_GCHandle
		
    }
}



public extension System.Runtime {
    struct ConstrainedExecution {
		public typealias CriticalFinalizerObject = System_Runtime_ConstrainedExecution_CriticalFinalizerObject
		
    }
}



public extension System.Runtime {
    struct CompilerServices {
		public typealias TaskAwaiter = System_Runtime_CompilerServices_TaskAwaiter
		public typealias ICriticalNotifyCompletion = System_Runtime_CompilerServices_ICriticalNotifyCompletion
		public typealias INotifyCompletion = System_Runtime_CompilerServices_INotifyCompletion
		public typealias ConfiguredTaskAwaitable = System_Runtime_CompilerServices_ConfiguredTaskAwaitable
		public typealias ConfiguredTaskAwaitable_ConfiguredTaskAwaiter = System_Runtime_CompilerServices_ConfiguredTaskAwaitable_ConfiguredTaskAwaiter
		public typealias YieldAwaitable = System_Runtime_CompilerServices_YieldAwaitable
		public typealias YieldAwaitable_YieldAwaiter = System_Runtime_CompilerServices_YieldAwaitable_YieldAwaiter
		public typealias ValueTaskAwaiter = System_Runtime_CompilerServices_ValueTaskAwaiter
		public typealias ConfiguredValueTaskAwaitable = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable
		public typealias ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter = System_Runtime_CompilerServices_ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter
		public typealias ITuple = System_Runtime_CompilerServices_ITuple
		
    }
}



public extension System.Runtime {
    struct Remoting {
		public typealias ObjectHandle = System_Runtime_Remoting_ObjectHandle
		
    }
}




public extension System {
    struct Reflection {
		public typealias ProcessorArchitecture = System_Reflection_ProcessorArchitecture
		public typealias AssemblyContentType = System_Reflection_AssemblyContentType
		public typealias AssemblyNameFlags = System_Reflection_AssemblyNameFlags
		public typealias ParameterAttributes = System_Reflection_ParameterAttributes
		public typealias PortableExecutableKinds = System_Reflection_PortableExecutableKinds
		public typealias ImageFileMachine = System_Reflection_ImageFileMachine
		public typealias MemberTypes = System_Reflection_MemberTypes
		public typealias BindingFlags = System_Reflection_BindingFlags
		public typealias FieldAttributes = System_Reflection_FieldAttributes
		public typealias PropertyAttributes = System_Reflection_PropertyAttributes
		public typealias CallingConventions = System_Reflection_CallingConventions
		public typealias MethodAttributes = System_Reflection_MethodAttributes
		public typealias MethodImplAttributes = System_Reflection_MethodImplAttributes
		public typealias ExceptionHandlingClauseOptions = System_Reflection_ExceptionHandlingClauseOptions
		public typealias EventAttributes = System_Reflection_EventAttributes
		public typealias ResourceLocation = System_Reflection_ResourceLocation
		public typealias GenericParameterAttributes = System_Reflection_GenericParameterAttributes
		public typealias TypeAttributes = System_Reflection_TypeAttributes
		public typealias MemberInfo = System_Reflection_MemberInfo
		public typealias ICustomAttributeProvider = System_Reflection_ICustomAttributeProvider
		public typealias Assembly = System_Reflection_Assembly
		public typealias AssemblyName = System_Reflection_AssemblyName
		public typealias StrongNameKeyPair = System_Reflection_StrongNameKeyPair
		public typealias MethodBase = System_Reflection_MethodBase
		public typealias ParameterInfo_Array = System_Reflection_ParameterInfo_Array
		public typealias ParameterInfo = System_Reflection_ParameterInfo
		public typealias CustomAttributeData = System_Reflection_CustomAttributeData
		public typealias CustomAttributeData_Array = System_Reflection_CustomAttributeData_Array
		public typealias Module = System_Reflection_Module
		public typealias MethodInfo = System_Reflection_MethodInfo
		public typealias Binder = System_Reflection_Binder
		public typealias FieldInfo = System_Reflection_FieldInfo
		public typealias FieldInfo_Array = System_Reflection_FieldInfo_Array
		public typealias MethodBase_Array = System_Reflection_MethodBase_Array
		public typealias ParameterModifier_Array = System_Reflection_ParameterModifier_Array
		public typealias ParameterModifier = System_Reflection_ParameterModifier
		public typealias PropertyInfo = System_Reflection_PropertyInfo
		public typealias MethodInfo_Array = System_Reflection_MethodInfo_Array
		public typealias PropertyInfo_Array = System_Reflection_PropertyInfo_Array
		public typealias ConstructorInfo = System_Reflection_ConstructorInfo
		public typealias CustomAttributeTypedArgument = System_Reflection_CustomAttributeTypedArgument
		public typealias CustomAttributeTypedArgument_Array = System_Reflection_CustomAttributeTypedArgument_Array
		public typealias CustomAttributeNamedArgument = System_Reflection_CustomAttributeNamedArgument
		public typealias CustomAttributeNamedArgument_Array = System_Reflection_CustomAttributeNamedArgument_Array
		public typealias MethodBody = System_Reflection_MethodBody
		public typealias LocalVariableInfo = System_Reflection_LocalVariableInfo
		public typealias LocalVariableInfo_Array = System_Reflection_LocalVariableInfo_Array
		public typealias ExceptionHandlingClause = System_Reflection_ExceptionHandlingClause
		public typealias ExceptionHandlingClause_Array = System_Reflection_ExceptionHandlingClause_Array
		public typealias TypeInfo = System_Reflection_TypeInfo
		public typealias IReflect = System_Reflection_IReflect
		public typealias MemberInfo_Array = System_Reflection_MemberInfo_Array
		public typealias IReflectableType = System_Reflection_IReflectableType
		public typealias EventInfo = System_Reflection_EventInfo
		public typealias ManifestResourceInfo = System_Reflection_ManifestResourceInfo
		public typealias Module_Array = System_Reflection_Module_Array
		public typealias AssemblyName_Array = System_Reflection_AssemblyName_Array
		public typealias ConstructorInfo_Array = System_Reflection_ConstructorInfo_Array
		public typealias EventInfo_Array = System_Reflection_EventInfo_Array
		public typealias InterfaceMapping = System_Reflection_InterfaceMapping
		public typealias Assembly_Array = System_Reflection_Assembly_Array
		public typealias TypeFilter = System_Reflection_TypeFilter
		public typealias ModuleResolveEventHandler = System_Reflection_ModuleResolveEventHandler
		public typealias MemberFilter = System_Reflection_MemberFilter
		
    }
}



public extension System {
    struct Configuration {
		
    }
}


public extension System.Configuration {
    struct Assemblies {
		public typealias AssemblyHashAlgorithm = System_Configuration_Assemblies_AssemblyHashAlgorithm
		public typealias AssemblyVersionCompatibility = System_Configuration_Assemblies_AssemblyVersionCompatibility
		
    }
}




public extension System {
    struct Threading {
		public typealias ThreadPriority = System_Threading_ThreadPriority
		public typealias ThreadState = System_Threading_ThreadState
		public typealias ApartmentState = System_Threading_ApartmentState
		public typealias CancellationToken = System_Threading_CancellationToken
		public typealias WaitHandle = System_Threading_WaitHandle
		public typealias WaitHandle_Array = System_Threading_WaitHandle_Array
		public typealias CancellationTokenRegistration = System_Threading_CancellationTokenRegistration
		public typealias ITimer = System_Threading_ITimer
		public typealias Thread = System_Threading_Thread
		public typealias ExecutionContext = System_Threading_ExecutionContext
		public typealias AsyncFlowControl = System_Threading_AsyncFlowControl
		public typealias CompressedStack = System_Threading_CompressedStack
		public typealias Timer = System_Threading_Timer
		public typealias CancellationTokenSource = System_Threading_CancellationTokenSource
		public typealias CancellationToken_Array = System_Threading_CancellationToken_Array
		public typealias TimerCallback = System_Threading_TimerCallback
		public typealias ContextCallback = System_Threading_ContextCallback
		public typealias ThreadStart = System_Threading_ThreadStart
		public typealias ParameterizedThreadStart = System_Threading_ParameterizedThreadStart
		
    }
}


public extension System.Threading {
    struct Tasks {
		public typealias TaskStatus = System_Threading_Tasks_TaskStatus
		public typealias TaskCreationOptions = System_Threading_Tasks_TaskCreationOptions
		public typealias TaskContinuationOptions = System_Threading_Tasks_TaskContinuationOptions
		public typealias ConfigureAwaitOptions = System_Threading_Tasks_ConfigureAwaitOptions
		public typealias ValueTask = System_Threading_Tasks_ValueTask
		public typealias Task = System_Threading_Tasks_Task
		public typealias TaskScheduler = System_Threading_Tasks_TaskScheduler
		public typealias TaskFactory = System_Threading_Tasks_TaskFactory
		public typealias Task_Array = System_Threading_Tasks_Task_Array
		
    }
}


public extension System.Threading.Tasks {
    struct Sources {
		public typealias ValueTaskSourceStatus = System_Threading_Tasks_Sources_ValueTaskSourceStatus
		public typealias ValueTaskSourceOnCompletedFlags = System_Threading_Tasks_Sources_ValueTaskSourceOnCompletedFlags
		public typealias IValueTaskSource = System_Threading_Tasks_Sources_IValueTaskSource
		
    }
}





public extension System {
    struct IO {
		public typealias SeekOrigin = System_IO_SeekOrigin
		public typealias FileAccess = System_IO_FileAccess
		public typealias FileMode = System_IO_FileMode
		public typealias FileShare = System_IO_FileShare
		public typealias FileOptions = System_IO_FileOptions
		public typealias FileAttributes = System_IO_FileAttributes
		public typealias UnixFileMode = System_IO_UnixFileMode
		public typealias SearchOption = System_IO_SearchOption
		public typealias MatchType = System_IO_MatchType
		public typealias MatchCasing = System_IO_MatchCasing
		public typealias FileStream = System_IO_FileStream
		public typealias Stream = System_IO_Stream
		public typealias FileStreamOptions = System_IO_FileStreamOptions
		public typealias FileStream_Array = System_IO_FileStream_Array
		public typealias Path = System_IO_Path
		public typealias File = System_IO_File
		public typealias StreamReader = System_IO_StreamReader
		public typealias TextReader = System_IO_TextReader
		public typealias StreamWriter = System_IO_StreamWriter
		public typealias TextWriter = System_IO_TextWriter
		public typealias FileSystemInfo = System_IO_FileSystemInfo
		public typealias FileInfo = System_IO_FileInfo
		public typealias DirectoryInfo = System_IO_DirectoryInfo
		public typealias FileInfo_Array = System_IO_FileInfo_Array
		public typealias EnumerationOptions = System_IO_EnumerationOptions
		public typealias FileSystemInfo_Array = System_IO_FileSystemInfo_Array
		public typealias DirectoryInfo_Array = System_IO_DirectoryInfo_Array
		public typealias Directory = System_IO_Directory
		
    }
}



public extension System {
    struct Security {
		public typealias SecurityRuleSet = System_Security_SecurityRuleSet
		public typealias SecureString = System_Security_SecureString
		public typealias PermissionSet = System_Security_PermissionSet
		public typealias ISecurityEncodable = System_Security_ISecurityEncodable
		public typealias SecurityElement = System_Security_SecurityElement
		public typealias IStackWalk = System_Security_IStackWalk
		public typealias IPermission = System_Security_IPermission
		
    }
}


public extension System.Security {
    struct Permissions {
		public typealias PermissionState = System_Security_Permissions_PermissionState
		
    }
}



public extension System.Security {
    struct Principal {
		public typealias PrincipalPolicy = System_Security_Principal_PrincipalPolicy
		public typealias IPrincipal = System_Security_Principal_IPrincipal
		public typealias IIdentity = System_Security_Principal_IIdentity
		
    }
}




public extension System {
    struct Buffers {
		public typealias OperationStatus = System_Buffers_OperationStatus
		
    }
}


public extension System.Buffers {
    struct Binary {
		public typealias BinaryPrimitives = System_Buffers_Binary_BinaryPrimitives
		
    }
}




public extension System {
    struct Text {
		public typealias NormalizationForm = System_Text_NormalizationForm
		public typealias Rune = System_Text_Rune
		public typealias StringRuneEnumerator = System_Text_StringRuneEnumerator
		public typealias CompositeFormat = System_Text_CompositeFormat
		public typealias Encoding = System_Text_Encoding
		public typealias EncodingProvider = System_Text_EncodingProvider
		public typealias EncoderFallback = System_Text_EncoderFallback
		public typealias EncoderFallbackBuffer = System_Text_EncoderFallbackBuffer
		public typealias DecoderFallback = System_Text_DecoderFallback
		public typealias DecoderFallbackBuffer = System_Text_DecoderFallbackBuffer
		public typealias EncodingInfo = System_Text_EncodingInfo
		public typealias EncodingInfo_Array = System_Text_EncodingInfo_Array
		public typealias Decoder = System_Text_Decoder
		public typealias Encoder = System_Text_Encoder
		public typealias StringBuilder = System_Text_StringBuilder
		public typealias StringBuilder_ChunkEnumerator = System_Text_StringBuilder_ChunkEnumerator
		public typealias StringBuilder_AppendInterpolatedStringHandler = System_Text_StringBuilder_AppendInterpolatedStringHandler
		
    }
}



public extension System {
    struct Collections {
		public typealias IList = System_Collections_IList
		public typealias ICollection = System_Collections_ICollection
		public typealias IEnumerable = System_Collections_IEnumerable
		public typealias IEnumerator = System_Collections_IEnumerator
		public typealias IStructuralComparable = System_Collections_IStructuralComparable
		public typealias IComparer = System_Collections_IComparer
		public typealias IStructuralEquatable = System_Collections_IStructuralEquatable
		public typealias IEqualityComparer = System_Collections_IEqualityComparer
		public typealias IDictionary = System_Collections_IDictionary
		public typealias IDictionaryEnumerator = System_Collections_IDictionaryEnumerator
		public typealias DictionaryEntry = System_Collections_DictionaryEntry
		public typealias Hashtable = System_Collections_Hashtable
		public typealias IHashCodeProvider = System_Collections_IHashCodeProvider
		public typealias ArrayList = System_Collections_ArrayList
		
    }
}


public extension System.Collections {
    struct Generic {
		
    }
}



public extension System.Collections {
    struct ObjectModel {
		
    }
}




public extension System {
    struct Numerics {
		
    }
}




public struct Beyond {
	
}


public extension Beyond {
    struct NET {
		
    }
}


public extension Beyond.NET {
    struct Sample {
		public typealias NiceLevels = Beyond_NET_Sample_NiceLevels
		public typealias TestEnum = Beyond_NET_Sample_TestEnum
		public typealias Address = Beyond_NET_Sample_Address
		public typealias IAnimal = Beyond_NET_Sample_IAnimal
		public typealias AnimalFactory = Beyond_NET_Sample_AnimalFactory
		public typealias BaseAnimal = Beyond_NET_Sample_BaseAnimal
		public typealias Cat = Beyond_NET_Sample_Cat
		public typealias Dog = Beyond_NET_Sample_Dog
		public typealias GenericAnimal = Beyond_NET_Sample_GenericAnimal
		public typealias Labrador = Beyond_NET_Sample_Labrador
		public typealias AsyncTests = Beyond_NET_Sample_AsyncTests
		public typealias Point = Beyond_NET_Sample_Point
		public typealias DelegatesTest = Beyond_NET_Sample_DelegatesTest
		public typealias EventTests = Beyond_NET_Sample_EventTests
		public typealias GenericTests = Beyond_NET_Sample_GenericTests
		public typealias GenericTests_SimpleKeyValuePair = Beyond_NET_Sample_GenericTests_SimpleKeyValuePair
		public typealias IndexerTests = Beyond_NET_Sample_IndexerTests
		public typealias NullabilityTests = Beyond_NET_Sample_NullabilityTests
		public typealias OverloadTests = Beyond_NET_Sample_OverloadTests
		public typealias Person = Beyond_NET_Sample_Person
		public typealias Person_Array = Beyond_NET_Sample_Person_Array
		public typealias Person_Extensions = Beyond_NET_Sample_Person_Extensions
		public typealias PropertyTests = Beyond_NET_Sample_PropertyTests
		public typealias SpanTest = Beyond_NET_Sample_SpanTest
		public typealias StructTest = Beyond_NET_Sample_StructTest
		public typealias Book = Beyond_NET_Sample_Book
		public typealias TestClass = Beyond_NET_Sample_TestClass
		public typealias TestRecord = Beyond_NET_Sample_TestRecord
		public typealias TestRecordStruct = Beyond_NET_Sample_TestRecordStruct
		public typealias TestReadOnlyRecordStruct = Beyond_NET_Sample_TestReadOnlyRecordStruct
		public typealias Transformer = Beyond_NET_Sample_Transformer
		public typealias Transformer_BuiltInTransformers = Beyond_NET_Sample_Transformer_BuiltInTransformers
		public typealias MoveDelegate = Beyond_NET_Sample_MoveDelegate
		public typealias AnimalCreatorDelegate = Beyond_NET_Sample_AnimalCreatorDelegate
		public typealias AsyncTests_TransformerDelegate = Beyond_NET_Sample_AsyncTests_TransformerDelegate
		public typealias DelegatesTest_TransformIntDelegate = Beyond_NET_Sample_DelegatesTest_TransformIntDelegate
		public typealias DelegatesTest_PointTransformDelegate = Beyond_NET_Sample_DelegatesTest_PointTransformDelegate
		public typealias EventTests_ValueChangedDelegate = Beyond_NET_Sample_EventTests_ValueChangedDelegate
		public typealias Person_NumberOfChildrenChangedDelegate = Beyond_NET_Sample_Person_NumberOfChildrenChangedDelegate
		public typealias Person_NewAgeProviderDelegate = Beyond_NET_Sample_Person_NewAgeProviderDelegate
		public typealias SpanTest_ByteArrayToSpanDelegate = Beyond_NET_Sample_SpanTest_ByteArrayToSpanDelegate
		public typealias SpanTest_SpanToByteArrayDelegate = Beyond_NET_Sample_SpanTest_SpanToByteArrayDelegate
		public typealias CharReturnerDelegate = Beyond_NET_Sample_CharReturnerDelegate
		public typealias Transformer_StringTransformerDelegate = Beyond_NET_Sample_Transformer_StringTransformerDelegate
		public typealias Transformer_DoublesTransformerDelegate = Beyond_NET_Sample_Transformer_DoublesTransformerDelegate
		public typealias Transformer_StringGetterDelegate = Beyond_NET_Sample_Transformer_StringGetterDelegate
		
    }
}


public extension Beyond.NET.Sample {
    struct SubclassingTests {
		public typealias MyBaseClass = Beyond_NET_Sample_SubclassingTests_MyBaseClass
		public typealias MySubClass = Beyond_NET_Sample_SubclassingTests_MySubClass
		
    }
}






public struct Microsoft {
	
}


public extension Microsoft {
    struct Win32 {
		
    }
}


public extension Microsoft.Win32 {
    struct SafeHandles {
		public typealias SafeWaitHandle = Microsoft_Win32_SafeHandles_SafeWaitHandle
		public typealias SafeHandleZeroOrMinusOneIsInvalid = Microsoft_Win32_SafeHandles_SafeHandleZeroOrMinusOneIsInvalid
		public typealias SafeFileHandle = Microsoft_Win32_SafeHandles_SafeFileHandle
		
    }
}






// MARK: - END Namespaces

// MARK: - BEGIN Footer


// MARK: - END Footer

